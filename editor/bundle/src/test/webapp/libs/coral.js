/* global Typekit */
/* jshint -W033,-W116 */
(function (window, undefined) {

  var typeKitId = 'jwv7ouu';

  if ( window.CUI && window.CUI.options && window.CUI.options.typeKitId )
  {
     typeKitId = window.CUI.options.typeKitId;
  }

  var config = {
    kitId: typeKitId,
    scriptTimeout: 3000
  };

  if (!window.Typekit) { // we load the typescript only once
    var h = document.getElementsByTagName("html")[0];
    h.className += " wf-loading";
    var t = setTimeout(function () {
      h.className = h.className.replace(/(\s|^)wf-loading(\s|$)/g, " ");
      h.className += " wf-inactive"
    }, config.scriptTimeout);
    var tk = document.createElement("script"), d = false;
    tk.src = '//use.typekit.net/' + config.kitId + '.js';
    tk.type = "text/javascript";
    tk.async = "true";
    tk.onload = tk.onreadystatechange = function () {
      var a = this.readyState;
      if (d || a && a != "complete" && a != "loaded")return;
      d = true;
      clearTimeout(t);
      try {
        Typekit.load(config)
      } catch (b) {
      }
    };
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(tk, s);
  }

}(this));

/**
 Crockford's new_constructor pattern, modified to allow walking the prototype chain, automatic constructor/destructor chaining, easy toString methods, and syntactic sugar for calling superclass methods

 @see Base

 @function

 @param {Object} descriptor                        Descriptor object
 @param {String|Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
 @param {Object} descriptor.extend                 The class to extend
 @param {Function} descriptor.construct            The constructor (setup) method for the new class
 @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
 @param {Mixed} descriptor.*                       Other methods and properties for the new class

 @returns {Base} The created class.
 */
var Class;
var Exception;

(function () {
  /**
   @name Base

   @classdesc The abstract class which contains methods that all classes will inherit.
   Base cannot be extended or instantiated and does not exist in the global namespace.
   If you create a class using <code class="prettyprint">new Class()</code> or <code class="prettyprint">MyClass.extend()</code>, it will come with Base' methods.

   @desc Base is an abstract class and cannot be instantiated directly. Constructors are chained automatically, so you never need to call the constructor of an inherited class directly
   @constructs

   @param {Object} options  Instance options. Guaranteed to be defined as at least an empty Object
   */

  /**
   Binds a method of this instance to the execution scope of this instance.

   @name bind
   @memberOf Base.prototype
   @function

   @param {Function} func The this.method you want to bind
   */
  var bindFunc = function (func) {
    // Bind the function to always execute in scope
    var boundFunc = func.bind(this);

    // Store the method name
    boundFunc._methodName = func._methodName;

    // Store the bound function back to the class
    this[boundFunc._methodName] = boundFunc;

    // Return the bound function
    return boundFunc;
  };

  /**
   Extends this class using the passed descriptor.
   Called on the Class itself (not an instance), this is an alternative to using <code class="prettyprint">new Class()</code>.
   Any class created using Class will have this static method on the class itself.

   @name extend
   @memberOf Base
   @function
   @static

   @param {Object} descriptor                        Descriptor object
   @param {String|Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
   @param {Object} descriptor.extend                 The class to extend
   @param {Function} descriptor.construct            The constructor (setup) method for the new class
   @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
   @param {Anything} descriptor.*                    Other methods and properties for the new class
   */
  var extendClass = function (descriptor) {
    descriptor.extend = this;
    return new Class(descriptor);
  };

  Class = function (descriptor) {
    descriptor = descriptor || {};

    if (descriptor.hasOwnProperty('extend') && !descriptor.extend) {
      throw new Class.NonTruthyExtendError(typeof descriptor.toString === 'function' ? descriptor.toString() : descriptor.toString);
    }

    // Extend Object by default
    var extend = descriptor.extend || Object;

    // Construct and destruct are not required
    var construct = descriptor.construct;
    var destruct = descriptor.destruct;

    // Remove special methods and keywords from descriptor
    delete descriptor.bind;
    delete descriptor.extend;
    delete descriptor.destruct;
    delete descriptor.construct;

    // Add toString method, if necessary
    if (descriptor.hasOwnProperty('toString') && typeof descriptor.toString !== 'function') {
      // Return the string provided
      var classString = descriptor.toString;
      descriptor.toString = function () {
        return classString.toString();
      };
    }
    else if (!descriptor.hasOwnProperty('toString') && extend.prototype.hasOwnProperty('toString')) {
      // Use parent's toString
      descriptor.toString = extend.prototype.toString;
    }

    // The remaining properties in descriptor are our methods
    var methodsAndProps = descriptor;

    // Create an object with the prototype of the class we're extending
    var prototype = Object.create(extend && extend.prototype);

    // Store super class as a property of the new class' prototype
    prototype.superClass = extend.prototype;

    // Copy new methods into prototype
    if (methodsAndProps) {
      for (var key in methodsAndProps) {
        if (methodsAndProps.hasOwnProperty(key)) {
          prototype[key] = methodsAndProps[key];

          // Store the method name so calls to inherited() work
          if (typeof methodsAndProps[key] === 'function') {
            prototype[key]._methodName = key;
            prototype[key]._parentProto = prototype;
          }
        }
      }
    }

    /**
     Call the superclass method with the same name as the currently executing method

     @name inherited
     @memberOf Base.prototype
     @function

     @param {Arguments} args  Unadulterated arguments array from calling function
     */
    prototype.inherited = function (args) {
      // Get the function that call us from the passed arguments objected
      var caller = args.callee;

      // Get the name of the method that called us from a property of the method
      var methodName = caller._methodName;

      if (!methodName) {
        throw new Class.MissingCalleeError(this.toString());
      }

      // Start iterating at the prototype that this function is defined in
      var curProto = caller._parentProto;
      var inheritedFunc = null;

      // Iterate up the prototype chain until we find the inherited function
      while (curProto.superClass) {
        curProto = curProto.superClass;
        inheritedFunc = curProto[methodName];
        if (typeof inheritedFunc === 'function')
          break;
      }

      if (typeof inheritedFunc === 'function') {
        // Store our inherited function
        var oldInherited = this.inherited;

        // Overwrite our inherited function with that of the prototype so the called function can call its parent
        this.inherited = curProto.inherited;

        // Call the inherited function our scope, apply the passed args array
        var retVal = inheritedFunc.apply(this, args);

        // Revert our inherited function to the old function
        this.inherited = oldInherited;

        // Return the value called by the inherited function
        return retVal;
      }
      else {
        throw new Class.InheritedMethodNotFoundError(this.toString(), methodName);
      }
    };

    // Add bind to the prototype of the class
    prototype.bind = bindFunc;

    /**
     Destroys this instance and frees associated memory. Destructors are chained automatically, so the <code class="prettyprint">destruct()</code> method of all inherited classes will be called for you

     @name destruct
     @memberOf Base.prototype
     @function
     */
    prototype.destruct = function () {
      // Call our destruct method first
      if (typeof destruct === 'function') {
        destruct.apply(this);
      }

      // Call superclass destruct method after this class' method
      if (extend && extend.prototype && typeof extend.prototype.destruct === 'function') {
        extend.prototype.destruct.apply(this);
      }
    };

    // Create a chained construct function which calls the superclass' construct function
    prototype.construct = function () {
      // Add a blank object as the first arg to the constructor, if none provided
      var args = arguments; // get around JSHint complaining about modifying arguments
      if (args[0] === undefined) {
        args.length = 1;
        args[0] = {};
      }

      // call superclass constructor
      if (extend && extend.prototype && typeof extend.prototype.construct === 'function') {
        extend.prototype.construct.apply(this, arguments);
      }

      // call constructor
      if (typeof construct === 'function') {
        construct.apply(this, arguments);
      }
    };

    // Create a function that generates instances of our class and calls our construct functions
    /** @ignore */
    var instanceGenerator = function () {
      // Create a new object with the prototype we built
      var instance = Object.create(prototype);

      // Call all inherited construct functions
      prototype.construct.apply(instance, arguments);

      return instance;
    };

    instanceGenerator.toString = prototype.toString;

    // Set the prototype of our instance generator to the prototype of our new class so things like MyClass.prototype.method.apply(this) work
    instanceGenerator.prototype = prototype;

    // Add extend to the instance generator for the class
    instanceGenerator.extend = extendClass;

    // The constructor, as far as JS is concerned, is actually our instance generator
    prototype.constructor = instanceGenerator;

    return instanceGenerator;
  };

  if (!Object.create) {
    /**
     Polyfill for Object.create. Creates a new object with the specified prototype.

     @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create/">Mozilla MDN</a>

     @param {Object} prototype  The prototype to create a new object with
     */
    Object.create = function (prototype) {
      if (arguments.length > 1) {
        throw new Error('Object.create implementation only accepts the first parameter.');
      }
      function Func() {
      }

      Func.prototype = prototype;
      return new Func();
    };
  }

  if (!Function.prototype.bind) {
    /**
     Polyfill for Function.bind. Binds a function to always execute in a specific scope.

     @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Mozilla MDN</a>

     @param {Object} scope  The scope to bind the function to
     */
    Function.prototype.bind = function (scope) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1);
      var fToBind = this;
      /** @ignore */
      var NoOp = function () {
      };
      /** @ignore */
      var fBound = function () {
        return fToBind.apply(this instanceof NoOp ? this : scope, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      NoOp.prototype = this.prototype;
      fBound.prototype = new NoOp();

      return fBound;
    };
  }

  Exception = new Class({
    extend: Error,
    construct: function () {
      this.name = 'Error';
      this.message = 'General exception';
    },

    toString: function () {
      return this.name + ': ' + this.message;
    }
  });

  var ClassException = Exception.extend({
    name: 'Class Exception'
  });

  // Exceptions
  Class.NonTruthyExtendError = ClassException.extend({
    construct: function (className) {
      this.message = className + ' attempted to extend a non-truthy object';
    }
  });

  Class.InheritedMethodNotFoundError = ClassException.extend({
    construct: function (className, methodName) {
      this.message = className + " can't call method '" + methodName + "', no method defined in parent classes";
    }
  });

  Class.MissingCalleeError = ClassException.extend({
    construct: function (className) {
      this.message = className + " can't call inherited method: calling method did not have _methodName";
    }
  });
}());

(function ($, window, undefined) {
  /**
   * @classdesc The main CUI namespace.
   * @namespace
   *
   * @property {Object} options Main options for CloudUI components.
   * @property {Boolean} options.debug If true, show debug messages for all components.
   * @property {Boolean} options.dataAPI If true, add listeners for widget data APIs.
   * @property {Object} Templates Contains templates used by CUI widgets
   *
   * @example
   * <caption>Change CUI options</caption>
   * <description>You can change CUI options by defining <code>CUI.options</code> before you load CUI.js</description>
   * &lt;script type=&quot;text/javascript&quot;&gt;
   * var CUI = {
   *   options: {
   *     debug: false,
   *     dataAPI: true
   *   }
   * };
   * &lt;/script&gt;
   * &lt;script src=&quot;js/CUI.js&quot;&gt;&lt;/script&gt;
   *
   * preferable include the CUI.js at the bottom before the body closes
   */
  window.CUI = window.CUI || {};

  CUI.options = $.extend({
    debug: false,
    dataAPI: true
  }, CUI.options);

  // REMARK: disabled for now
  // Register partials for all templates
  // Note: this requires the templates to be included BEFORE CUI.js
  /*for (var template in CUI.Templates) {
   Handlebars.registerPartial(template, CUI.Templates[template]);
   }*/

  /**
   * <p><code>cui-contentloaded</code> event is an event that is triggered when a new content is injected to the DOM,
   * which is very similar to {@link https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/DOMContentLoaded|DOMContentLoaded} event.</p>
   * <p>This event is normally used so that a JavaScript code can be notified when new content needs to be enhanced (applying event handler, layout, etc).
   * The element where the new content is injected is available at event.target, like so:
   * <pre class="prettyprint linenums jsDocExample">$(document).on("cui-contentloaded", function(e) {
   * var container = e.target;
   * // the container is the element where new content is injected.
   * });</pre>
   * This way the listener can limit the scope of the selector accordingly.</p>
   * <p>It will be triggered at DOMContentLoaded event as well, so component can just listen to this event instead of DOMContentLoaded for enhancement purpose.
   * In that case, the value of event.target is <code>document</code>.</p>
   *
   * @event cui-contentloaded
   */
  $(function () {
    $(document).trigger("cui-contentloaded");
  });

}(jQuery, this));

(function ($, window, undefined) {

  var nextId = 1;

  /**
   * Utility functions used by CoralUI widgets
   * @namespace
   */
  CUI.util = {

    /**
     * Flag if a touch device was detected
     * @type {Boolean}
     */
    isTouch: (function () {
      // CUI-2327 Special value for Win8.x/Chrome
      if (/Windows NT 6\.[23];.*Chrome/.test(window.navigator.userAgent)) {
        return false;
      }

      return 'ontouchstart' in window;
    })(),

    /**
     * delivers a unique id within Coral
     * meant to be used in case a id attribute is necessary but missing
     */
    getNextId: function () {
      return 'coral-' + nextId++;
    },

    /**
     * Get the target element of a data API action using the data attributes of an element.
     *
     * @param {jQuery} $element The jQuery object representing the element to get the target from
     * @return {jQuery} The jQuery object representing the target element
     */
    getDataTarget: function ($element) {
      var href = $element.attr('href');
      var $target = $($element.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))); // Strip for ie7
      return $target;
    },

    /**
     * Decapitalize a string by converting the first letter to lowercase.
     *
     * @param {String} str The string to de-capitalize
     * @return {String} The de-capitalized string
     */
    decapitalize: function (str) {
      return str.slice(0, 1).toLowerCase() + str.slice(1);
    },

    /**
     * Capitalize a string by converting the first letter to uppercase.
     *
     * @param {String} str The string to capitalize
     * @return {String} The capitalized string
     */
    capitalize: function (str) {
      return str.slice(0, 1).toUpperCase() + str.slice(1);
    },

    /**
     * Create a jQuery plugin from a class
     * @param {Class} PluginClass The class to create to create the plugin for
     * @param {String} [pluginName=PluginClass.toString()] The name of the plugin to create. The de-capitalized return value of PluginClass.toString() is used if left undefined
     * @param {Function} [callback]                              A function to execute in the scope of the jQuery object when the plugin is activated. Used for tacking on additional initialization procedures or behaviors for other plugin functionality.
     */
    plugClass: function (PluginClass, pluginName, callback) {
      pluginName = pluginName || CUI.util.decapitalize(PluginClass.toString());

      $.fn[pluginName] = function (optionsIn) {
        var pluginArgs = arguments;
        return this.each(function () {
          var $element = $(this);

          // Combine defaults, data, options, and element config
          var options = $.extend({}, $element.data(), typeof optionsIn === 'object' && optionsIn, { element: this });

          // Get instance, if present already
          var instance = $element.data(pluginName) || new PluginClass(options);

          if (typeof optionsIn === 'string') // Call method, pass args
            instance[optionsIn].apply(instance, Array.prototype.slice.call(pluginArgs, 1));
          else if ($.isPlainObject(optionsIn)) // Apply options
            instance.set(optionsIn);

          if (typeof callback === 'function')
            callback.call(this, instance);
        });
      };

      $.fn[pluginName].Constructor = PluginClass;
    },

    /**
     * Register a callback from a string
     *
     * @param {String} callbackAsString The string containing the callback function to register
     * @param {Object} [params] Parameters to provide when executing callback
     * @return {Function} The callback function generated from the provided string
     */
    buildFunction: function (callbackAsString, params) {
      params = params || [];

      if (typeof params === "string") {
        params = [params];
      }

      if (callbackAsString) {
        try {
          var Fn = Function;
          return new Fn(params, "return " + callbackAsString + "(" + params.join(", ") + ");");
        } catch (e) {
          return null;
        }
      }
    },

    /**
     * Selects text in the provided field
     * @param {Number} start (optional) The index where the selection should start (defaults to 0)
     * @param {Number} end (optional) The index where the selection should end (defaults to the text length)
     */
    selectText: function (field, start, end) {
      var value = field.val();

      if (value.length > 0) {
        start = start || 0;
        end = end || value.length;
        var domEl = $(field)[0];
        if (domEl.setSelectionRange) {
          // Mostly all browsers
          domEl.blur();
          domEl.setSelectionRange(start, end);
          domEl.focus();
        } else if (domEl.createTextRange) {
          // IE
          var range = domEl.createTextRange();
          range.collapse(true);
          range.moveEnd("character", end - value.length);
          range.moveStart("character", start);
          range.select();
        }
      }
    },

    /**
     * Utility function to get the value of a nested key within an object
     *
     * @param {Object} object The object to retrieve the value from
     * @param {String} nestedKey The nested key. For instance "foo.bar.baz"
     * @return {Object} The object value for the nested key
     */
    getNested: function (object, nestedKey) {
      if (!nestedKey) {
        return object;
      }

      // Split key into a table
      var keys = typeof nestedKey === "string" ? nestedKey.split(".") : nestedKey;

      // Browse object
      var result = object;
      while (result && keys.length > 0) {
        result = result[keys.shift()];
      }

      return result;
    },

    /**
     * Utility function to transform a string representation of a boolean value into that boolean value
     *
     * @param {String} string representation
     * @return {Boolean} The boolean value of the string
     */
    isTrue: function (str) {
      return str === 'true';
    }

  };

  // add touch class to <html>
  $('html').toggleClass('touch', CUI.util.isTouch);

}(jQuery, this));
(function ($, window, undefined) {

  /**
   * Load remote content in an element with a CUI spinner
   * @param {String} remote The remote URL to pass to $.load
   * @param {Boolean} [force] Set force to true to force the load to happen with every call, even if it has succeeded already. Otherwise, subsequent calls will simply return.
   * @param {Function} [callback] A function to execute in the scope of the jQuery $.load call when the load finishes (whether success or failure). The arguments to the callback are the load results: response, status, xhr.
   */
  $.fn.loadWithSpinner = function (remote, force, callback) {
    var $target = $(this);

    // load remote link, if necessary
    if (remote && (force || $target.data('loaded-remote') !== remote)) {
      // only show the spinner if the request takes an appreciable amount of time, otherwise
      // the flash of the spinner is a little ugly
      var timer = setTimeout(function () {
        $target.html('<div class="spinner large"></div>');
      }, 50);

      $target.load(remote, function (response, status, xhr) {
        clearTimeout(timer); // no need for the spinner anymore!

        if (status === 'error') {
          $target.html('<div class="alert error"><strong>ERROR</strong> Failed to load content: ' + xhr.statusText + ' (' + xhr.status + ')</div>');
          $target.data('loaded-remote', '');
        }

        if (typeof callback === 'function') {
          callback.call(this, response, status, xhr);
        }
      }); // load

      $target.data('loaded-remote', remote);
    } // end if remote
  };

  /**
   * $.fn.on for touch devices only
   * @return {jquery} this, chainable
   */
  $.fn.finger = function () {
    if (CUI.util.isTouch) {
      this.on.apply(this, arguments);
    }
    return this;
  };

  /**
   * $.fn.on for pointer devices only
   * @return {jquery} this, chainable
   */
  $.fn.pointer = function () {
    if (!CUI.util.isTouch) {
      this.on.apply(this, arguments);
    }
    return this;
  };

  /**
   * $.fn.on for touch and pointer devices
   * the first parameter is the finger event the second the pointer event
   * @return {jquery} this, chainable
   */
  $.fn.fipo = function () {
    var args = Array.prototype.slice.call(arguments, 1, arguments.length);

    this.pointer.apply(this, args);

    args[0] = arguments[0];
    this.finger.apply(this, args);

    return this;
  };

  /**
   * :focusable and :tabbable selectors
   * https://raw.github.com/jquery/jquery-ui/master/ui/jquery.ui.core.js
   * @ignore
   */
  function focusable(element, isTabIndexNotNaN) {
    var map, mapName, img,
      nodeName = element.nodeName.toLowerCase();
    if ("area" === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
        return false;
      }
      img = $("img[usemap=#" + mapName + "]")[0];
      return !!img && visible(img);
    }
    return ( /input|select|textarea|button|object/.test(nodeName) ?
      !element.disabled :
      "a" === nodeName ?
        element.href || isTabIndexNotNaN :
        isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible(element);
  }

  /**
   * :focusable and :tabbable selectors
   * https://raw.github.com/jquery/jquery-ui/master/ui/jquery.ui.core.js
   * @ignore
   */
  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
      return $.css(this, "visibility") === "hidden";
    }).length;
  }

  /**
   * create pseudo selectors :focusable and :tabbable
   * https://raw.github.com/jquery/jquery-ui/master/ui/jquery.ui.core.js
   * support: jQuery >= 1.8
   */
  $.extend($.expr[ ":" ], {
    data: $.expr.createPseudo(function (dataName) {
      return function (elem) {
        return !!$.data(elem, dataName);
      };
    }),

    /**
     * pseudo selector :focusable
     */
    focusable: function (element) {
      return focusable(element, !isNaN($.attr(element, "tabindex")));
    },

    /**
     * pseudo selector :tabbable
     */
    tabbable: function (element) {
      var tabIndex = $.attr(element, "tabindex"),
        isTabIndexNaN = isNaN(tabIndex);
      return ( isTabIndexNaN || tabIndex >= 0 ) && focusable(element, !isTabIndexNaN);
    }
  });

}(jQuery, this));
/*!
 * jQuery UI Position 1.11.3
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
(function() {

$.ui = $.ui || {};

var cachedScrollbarWidth, supportsOffsetFractions,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),

			// support: jQuery 1.6.x
			// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
			width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !supportsOffsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function() {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

})();

return $.ui.position;

}));

/*!
* toe.js
* version 3.0.2
* author: Damien Antipa
* https://github.com/dantipa/toe.js
*/
(function ($, window, undefined) {

    var state, gestures = {}, touch = {

        active: false,

        on: function () {
            $(document).on('touchstart', touchstart)
                .on('touchmove', touchmove)
                .on('touchend touchcancel', touchend);

            touch.active = true;
        },

        off: function () {
            $(document).off('touchstart', touchstart)
                .off('touchmove', touchmove)
                .off('touchend touchcancel', touchend);

            touch.active = false;
        },

        track: function (namespace, gesture) {
            gestures[namespace] = gesture;
        },

        addEventParam: function (event, extra) {
            var $t = $(event.target),
                pos = $t.offset(),
                param = {
                    pageX: event.point[0].x,
                    pageY: event.point[0].y,
                    offsetX: pos.left - event.point[0].x,
                    offsetY: pos.top - event.point[0].y
                };

            return $.extend(param, extra);
        },

        Event: function (event) { // normalizes and simplifies the event object
            var normalizedEvent = {
                type: event.type,
                timestamp: new Date().getTime(),
                target: event.target,   // target is always consistent through start, move, end
                point: []
            }, points = event.changedTouches ||
                event.originalEvent.changedTouches ||
                event.touches ||
                event.originalEvent.touches;

            $.each(points, function (i, e) {
                normalizedEvent.point.push({
                    x: e.pageX,
                    y: e.pageY
                });
            });

            return normalizedEvent;
        },

        State: function (start) {
            var p = start.point[0];

            return {   // TODO add screenX etc.
                start: start,
                move: [],
                end: null
            };
        },

        calc: {
            getDuration: function (start, end) {
                return end.timestamp - start.timestamp;
            },

            getDistance: function (start, end) {
                return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            },

            getAngle: function (start, end) {
                return Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;
            },

            getDirection: function (angle) {
                return angle < -45 && angle > -135 ? 'top':
                    angle >= -45 && angle <= 45 ? 'right':
                        angle >= 45 && angle < 135 ? 'down':
                            angle >= 135 || angle <= -135 ? 'left':
                                'unknown';
            },

            getScale: function (start, move) {
                var sp = start.point,
                    mp = move.point;

                if(sp.length === 2 && mp.length === 2) { // needs to have the position of two fingers
                    return (Math.sqrt(Math.pow(mp[0].x - mp[1].x, 2) + Math.pow(mp[0].y - mp[1].y, 2)) / Math.sqrt(Math.pow(sp[0].x - sp[1].x, 2) + Math.pow(sp[0].y - sp[1].y, 2))).toFixed(2);
                }

                return 0;
            },

            getRotation: function (start, move) {
                var sp = start.point,
                    mp = move.point;

                if(sp.length === 2 && mp.length === 2) {
                    return ((Math.atan2(mp[0].y - mp[1].y, mp[0].x - mp[1].x) * 180 / Math.PI) - (Math.atan2(sp[0].y - sp[1].y, sp[0].x - sp[1].x) * 180 / Math.PI)).toFixed(2);
                }

                return 0;
            }
        }

    }; // touch obj

    function loopHandler(type, event, state, point) {
        $.each(gestures, function (i, g) {
            g[type].call(this, event, state, point);
        });
    }

    function touchstart(event) {
        var start = touch.Event(event);
        state = touch.State(start); // create a new State object and add start event

        loopHandler('touchstart', event, state, start);
    }

    function touchmove(event) {
        var move = touch.Event(event);
        state.move.push(move);

        loopHandler('touchmove', event, state, move);
    }

    function touchend(event) {
        var end = touch.Event(event);
        state.end = end;

        loopHandler('touchend', event, state, end);
    }

    touch.on();

    // add to namespace
    $.toe = touch;

}(jQuery, this));
(function ($, touch, window, undefined) {

    var namespace = 'swipe', cfg = {
            distance: 40, // minimum
            duration: 1200, // maximum
            direction: 'all'
        };

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            state[namespace] = {
                finger: start.point.length
            };
        },
        touchmove: function (event, state, move) {
            // if another finger was used then increment the amount of fingers used
            state[namespace].finger = move.point.length > state[namespace].finger ? move.point.length : state[namespace].finger;
        },
        touchend: function (event, state, end) {
            var opt = $.extend(cfg, event.data),
                duration,
                distance;

            // calc
            duration = touch.calc.getDuration(state.start, end);
            distance = touch.calc.getDistance(state.start.point[0], end.point[0]);

            // check if the swipe was valid
            if (duration < opt.duration && distance > opt.distance) {

                state[namespace].angle = touch.calc.getAngle(state.start.point[0], end.point[0]);
                state[namespace].direction = touch.calc.getDirection(state[namespace].angle);

                // fire if the amount of fingers match
                if (opt.direction === 'all' || state[namespace].direction === opt.direction) {
                    $(event.target).trigger($.Event(namespace, touch.addEventParam(state.start, state[namespace])));
                }
            }
        }
    });

}(jQuery, jQuery.toe, this));
(function ($, touch, window, undefined) {

    var namespace = 'tap', cfg = {
        distance: 10,
        duration: 300,
        finger: 1
    };

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            state[namespace] = {
                finger: start.point.length
            };
        },
        touchmove: function (event, state, move) {
            // if another finger was used then increment the amount of fingers used
            state[namespace].finger = move.point.length > state[namespace].finger ? move.point.length : state[namespace].finger;
        },
        touchend: function (event, state, end) {
            var opt = $.extend(cfg, event.data),
                duration,
                distance;

            // calc
            duration = touch.calc.getDuration(state.start, end);
            distance = touch.calc.getDistance(state.start.point[0], end.point[0]);

            // check if the tap was valid
            if (duration < opt.duration && distance < opt.distance) {
                // fire if the amount of fingers match
                if (state[namespace].finger === opt.finger) {
                    $(event.target).trigger(
                        $.Event(namespace, touch.addEventParam(state.start, state[namespace]))
                    );
                }
            }
        }
    });

}(jQuery, jQuery.toe, this));
(function ($, touch, window, undefined) {

    var timer, abort,
        namespace = 'taphold', cfg = {
            distance: 20,
            duration: 500,
            finger: 1
        };

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            var opt = $.extend(cfg, event.data);

            abort = false;
            state[namespace] = {
                finger: start.point.length
            };

            clearTimeout(timer);
            timer = setTimeout(function () {
                if (!abort && touch.active) {
                    if (state[namespace].finger === opt.finger) {
                        $(event.target).trigger($.Event(namespace, touch.addEventParam(start, state[namespace])));
                    }
                }
            }, opt.duration);
        },
        touchmove: function (event, state, move) {
            var opt = $.extend(cfg, event.data),
                distance;

            // if another finger was used then increment the amount of fingers used
            state[namespace].finger = move.point.length > state[namespace].finger ? move.point.length : state[namespace].finger;

            // calc
            distance = touch.calc.getDistance(state.start.point[0], move.point[0]);
            if (distance > opt.distance) { // illegal move
                abort = true;
            }
        },
        touchend: function (event, state, end) {
            abort = true;
            clearTimeout(timer);
        }
    });

}(jQuery, jQuery.toe, this));
(function ($, touch, window, undefined) {

    var namespace = 'transform', cfg = {
            scale: 0.1, // minimum
            rotation: 15
        },
        started;

    touch.track(namespace, {
        touchstart: function (event, state, start) {
            started = false;
            state[namespace] = {
                start: start,
                move: []
            };
        },
        touchmove: function (event, state, move) {
            var opt = $.extend(cfg, event.data);

            if (move.point.length !== 2) {
                return;
            }

            state[namespace].move.push(move);

            if (state[namespace].start.point.length !== 2 && move.point.length === 2) { // in case the user failed to start with 2 fingers
                state[namespace].start = $.extend({}, move);
            }

            state[namespace].rotation = touch.calc.getRotation(state[namespace].start, move);
            state[namespace].scale = touch.calc.getScale(state[namespace].start, move);

            if (Math.abs(1-state[namespace].scale) > opt.scale || Math.abs(state[namespace].rotation) > opt.rotation) {
                if(!started) {
                    $(event.target).trigger($.Event('transformstart', state[namespace]));
                    started = true;
                }

                $(event.target).trigger($.Event('transform', state[namespace]));
            }
        },
        touchend: function (event, state, end) {
            if(started) {
                started = false;

                if (end.point.length !== 2) { // in case the user failed to end with 2 fingers
                    state.end = $.extend({}, state[namespace].move[state[namespace].move.length - 1]);
                }

                state[namespace].rotation = touch.calc.getRotation(state[namespace].start, state.end);
                state[namespace].scale = touch.calc.getScale(state[namespace].start, state.end);

                $(event.target).trigger($.Event('transformend', state[namespace]));
            }
        }
    });

}(jQuery, jQuery.toe, this));
(function ($, window, undefined) {

  CUI.Widget = new Class(/** @lends CUI.Widget# */{
    toString: 'Widget',

    /**
     * @classdesc The base class for all widgets
     *
     * @desc Creates a new widget
     * @constructs
     *
     * @param {Object} options Widget options
     * @param {Boolean} [options.visible=false] If True, show the widget immediately
     */
    construct: function (options) {

      // Store the target element jQuery object:
      this.$element = $(options.element);

      // Get widget name:
      var widgetName = CUI.util.decapitalize(this.toString());

      // See if the target element has a widget instance attached already:
      if (this.$element.data(widgetName) !== undefined) {
        var message = [
          'An instance of',
          this,
          'is already attached to the specified target element.',
          'Future versions of CoralUI will throw an exception at this point.'
        ].join(' ');

        window.console.log(message);
      }

      // Cascade and store options:
      this.options = $.extend(
          {},
          (typeof this.defaults === 'object' && this.defaults),
          this.$element.data(),
          options);

      // Add instance to element's data
      this.$element.data(widgetName, this);

      // Bind functions commonly called by listeners
      this.bind(this.hide);
      this.bind(this.show);
      this.bind(this.toggleVisibility);

      // Show/hide when this.options.visible changes
      this.on('change:visible', function (evt) {
        this[evt.value ? '_show' : '_hide']();
      }.bind(this));
    },

    /**
     * Set a number of options using an object or a string
     * @name set
     * @memberOf CUI.Widget#
     * @function
     *
     * @param {String|Object} option The option to set as a string, or an object of key/value pairs to set
     * @param {String} value The value to set the option to (is ignored when first argument is an object)
     *
     * @return {CUI.Widget} this, chainable
     */
    set: function (optionOrObj, value) {
      if ($.isPlainObject(optionOrObj)) {
        // Set multiple options
        for (var option in optionOrObj) {
          this._set(option, optionOrObj[option]);
        }
      }
      else {
        // Set single option
        this._set(optionOrObj, value);
      }

      return this;
    },

    /**
     * @ignore
     */
    _set: function (option, value) {
      // Trigger a change event
      var e = $.Event('beforeChange:' + option, {
        widget: this, // We want to know who fired this event (used by CUI.Filters, CUI.DropdownList)
        option: option,
        currentValue: this.options[option],
        value: value
      });
      this.$element.trigger(e);

      // Don't set if prevented
      if (e.isDefaultPrevented()) return this;

      // Set value
      this.options[option] = value;

      e = $.Event('change:' + option, {
        widget: this,
        option: option,
        value: value
      });
      this.$element.trigger(e);
    },

    /**
     * Get the value of an option
     * @param {String} option The name of the option to fetch the value of
     * @return {Mixed} Option value
     */
    get: function (option) {
      return this.options[option];
    },

    /**
     * Add an event listener
     * @param {String} evtName The event name to listen for
     * @param {Function} func The function that will be called when the event is triggered
     * @return {CUI.Widget} this, chainable
     */
    on: function (evtName, func) {
      this.$element.on.apply(this.$element, arguments);
      return this;
    },

    /**
     * Remove an event listener
     * @param {String} evtName The event name to stop listening for
     * @param {Function} func     The function that was passed to on()
     * @return {CUI.Widget} this, chainable
     */
    off: function (evtName, func) {
      this.$element.off.apply(this.$element, arguments);
      return this;
    },

    /**
     * Show the widget
     * @return {CUI.Widget} this, chainable
     */
    show: function (evt) {
      evt = evt || {};

      if (this.options.visible)
        return this;

      if (!evt.silent) {
        // Trigger event
        var e = $.Event('show');
        this.$element.trigger(e);

        // Do nothing if event is prevented or we're already visible
        if (e.isDefaultPrevented()) return this;
      }

      this.options.visible = true;

      this._show(evt);

      return this;
    },

    /**
     * @ignore
     */
    _show: function (evt) {
      this.$element.show();
    },

    /**
     * Hide the widget
     *
     * @return {CUI.Widget} this, chainable
     */
    hide: function (evt) {
      evt = evt || {};

      if (!this.options.visible)
        return this;

      if (!evt.silent) {
        // Trigger event
        var e = $.Event('hide');
        this.$element.trigger(e);

        if (e.isDefaultPrevented()) return this;
      }

      this.options.visible = false;

      this._hide(evt);

      return this;
    },

    /**
     * @ignore
     */
    _hide: function (evt) {
      this.$element.hide();
    },

    /**
     * Toggle the visibility of the widget
     * @return {CUI.Widget} this, chainable
     */
    toggleVisibility: function () {
      return this[!this.options.visible ? 'show' : 'hide']();
    },

    /**
     * Set a custom name for this widget.
     *
     * @param {String} customName Component name
     * @return {CUI.Widget} this, chainable
     */
    setName: function (customName) {
      /** @ignore */
      this.toString = function () {
        return customName;
      };

      return this;
    }

    /**
     Triggered when the widget is shown

     @name CUI.Widget#show
     @event
     */

    /**
     Triggered when the widget is hidden

     @name CUI.Widget#hide
     @event
     */

    /**
     Triggered when before an option is changed

     @name CUI.Widget#beforeChange:*
     @event

     @param {Object} evt                    Event object
     @param {Mixed} evt.option              The option that changed
     @param {Mixed} evt.currentValue        The current value
     @param {Mixed} evt.value               The value this option will be changed to
     @param {Function} evt.preventDefault   Call to prevent the option from changing
     */

    /**
     Triggered when an option is changed

     @name CUI.Widget#change:*
     @event

     @param {Object} evt          Event object
     @param {Mixed} evt.option    The option that changed
     @param {Mixed} evt.value     The new value
     */
  });

  /**
   * Utility function to get the widget class instance that's attached to
   * the provided element.
   *
   * @param WidgetClass The type of widget instance to obtain.
   * @param $element The target element to obtain the instance from.
   * @returns The obtained Widget instance, if the target element has an
   * instance attached.
   */
  CUI.Widget.fromElement = function (WidgetClass, $element) {
    return $element.data(CUI.util.decapitalize(WidgetClass.toString()));
  };

  /**
   * The registry object maps data-init selector values to Widget
   * types.
   */
  CUI.Widget.registry = {

    /**
     * Registers the given Widget type as the type that belongs
     * to the provided selector.
     *
     * @param selector String representing the data-init value
     * mapping to Widget.
     * @param Widget Widget subclass that maps to the given
     * selector.
     */
    register: function (selector, Widget) {

      // Register as a jQuery plug-in:
      CUI.util.plugClass(Widget);

      this._widgets[selector] = Widget;

      // Extend the Widget with a static 'init' method:
      Widget.init = function ($element) {
        this._init(Widget, $element);
      }.bind(this);

    },

    /**
     * Look-up the Widget subclass that is mapped to the provided
     * selector String value.
     *
     * @param selector String value to look-up the registered
     * Widget subclass for.
     * @returns a Widget subclass, or undefined if the selector
     * could not be resolved.
     */
    resolve: function (selector) {
      return this._widgets[selector];
    },

    /**
     * Initialize the given jQuery element(s) as Widgets of the
     * type as indicated by the selector argument.
     *
     * @param selector String that indicates what Widget subclass
     * must be used to initialize the element.
     * @param $element The jQuery element(s) that the instances
     * must be bound to.
     */
    init: function (selector, $element) {
      this._init(this.resolve(selector), $element);
    },

    getSelectors: function () {
      var selectors = [];
      for (var selector in this._widgets) {
        selectors.push(selector);
      }
      return selectors;
    },

    /**
     * Maps selector values to Widget types
     * @private
     */
    _widgets: {},

    /**
     * Implementation of the public init method, as well as the
     * init method that gets added to registering Widget classes
     *
     * @param Widget The Widget subclass to instantiate.
     * @param $element The jQuery element(s) that the instances
     * must be bound to.
     * @private
     */
    _init: function (Widget, $element) {
      if (Widget !== undefined) {
        $element.each(function () {
          var $item = $(this);

          if (CUI.Widget.fromElement(Widget, $item) === undefined) {
            new Widget({element: $item});
          }
        });
      }
    }
  };

}(jQuery, this));

(function ($) {

  var CLASS_ACTIVE = "is-active";

  CUI.Accordion = new Class(/** @lends CUI.Accordion# */{
    toString: 'Accordion',
    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc A widget for both accordions and collapsibles

     @desc Creates a new accordion or collapsible
     @constructs

     @param {Object} options                               Widget options.
     @param {Mixed}  [options.active=false]                Index of the initial active tab of the accordion or one of true/false for collapsibles
     @param {boolean} [options.disabled=false]             Set the disabled state of the widget.
     @param {String} [options.iconClassCollapsed="coral-Icon--chevronRight"]
     @param {String} [options.iconClassDisabled="coral-Icon--chevronDown"]
     */
    construct: function (options) {
      this._parseAttributes();
      this._setAccordion();
      this._setListeners();
      this._makeAccessible();
      this._updateDOMForDisabled();
    },

    defaults: {
      active: false,
      disabled: false,
      iconClassCollapsed: 'coral-Icon--chevronRight',
      iconClassExpanded: 'coral-Icon--chevronDown'
    },

    isAccordion: false,

    _parseAttributes: function () {
      var iconClassCollapsed = this.$element.attr('data-icon-class-collapsed');
      if (iconClassCollapsed) {
        this.options.iconClassCollapsed = iconClassCollapsed;
      }
      var iconClassExpanded = this.$element.attr('data-icon-class-expanded');
      if (iconClassExpanded) {
        this.options.iconClassExpanded = iconClassExpanded;
      }
    },

    _setAccordion: function () {
      var $element = this.$element;
      // determines the type of component that it is building
      this.isAccordion = (!$element.hasClass("coral-Collapsible")) && ($element.data("init") !== "collapsible");

      if (this.isAccordion) {
        // adds the required class
        $element.addClass("coral-Accordion");

        var activeIndex = $element.children("." + CLASS_ACTIVE).index();
        if (this.options.active !== false) {
          activeIndex = this.options.active;
        } else {
          // saves the element with the active class as the active element
          this.options.active = activeIndex;
        }
        $element.children().each(function (index, element) {
          this._initElement(element, index != activeIndex);
        }.bind(this));
      } else {

        // checks if the element has the active class.
        this.options.active = $element.hasClass(CLASS_ACTIVE);
        this._initElement($element, !this.options.active);
      }
    },

    _setListeners: function () {
      // header selector
      var selector = this.isAccordion ? '> .coral-Accordion-item > .coral-Accordion-header' : '> .coral-Collapsible-header';
      this.$element.on('click', selector, this._toggle.bind(this));

      this.$element.on("change:active", this._changeActive.bind(this));

      // Prevent text selection on header
      var selectstartSelector = this.isAccordion ? '.coral-Accordion-header' : '.coral-Collapsible-header';
      this.$element.on("selectstart", selectstartSelector, function (event) {
        event.preventDefault();
      });

      this.on('change:disabled', function (event) {
        this._updateDOMForDisabled();
      }.bind(this));
    },

    /**
     * Updates styles and attributes to match the current disabled option value.
     * @ignore */
    _updateDOMForDisabled: function () {
      if (this.options.disabled) {
        this.$element.addClass('is-disabled').attr('aria-disabled', true)
          .find('[role=tab], > [role=button]').removeAttr('tabindex').attr('aria-disabled', true);
      } else {
        this.$element.removeClass('is-disabled').attr('aria-disabled', false)
          .find('[role=tab], > [role=button]').each(function (index, element) {
            var elem = $(element);
            elem.removeAttr('aria-disabled').attr('tabindex', elem.is('[aria-selected=true][aria-controls], [aria-expanded][aria-controls]') ? 0 : -1);
          });
      }
    },

    _toggle: function (event) {
      if (this.options.disabled) {
        return;
      }
      var el = $(event.target).closest(this._getCollapsibleSelector()),
        isCurrentlyActive = el.hasClass(CLASS_ACTIVE),
        active = (isCurrentlyActive) ? false : ((this.isAccordion) ? el.index() : true);
      this.setActive(active);
    },
    _changeActive: function () {
      if (this.isAccordion) {
        this._collapse(this.$element.children("." + CLASS_ACTIVE));
        if (this.options.active !== false) {
          var activeElement = this.$element.children().eq(this.options.active);
          this._expand(activeElement);
        }
      } else {
        if (this.options.active) {
          this._expand(this.$element);
        } else {
          this._collapse(this.$element);
        }
      }
    },
    setActive: function (active) {
      if (active !== this.options.active) {
        this.options.active = active;
        this._changeActive();
      }
    },
    _initElement: function (element, collapse) {
      element = $(element);

      // Add correct header
      if (this._getHeaderElement(element).length === 0) this._prependHeaderElement(element);
      if (this._getHeaderIconElement(element).length === 0) this._prependHeaderIconElement(element);

      // adds the content class
      if (this._getContentElement(element).length === 0) this._prependContentElement(element);

      // adds the corresponding container class
      element.addClass(this.isAccordion ? 'coral-Accordion-item' : 'coral-Collapsible');

      var header = this._getHeaderElement(element),
        content = this._getContentElement(element),
        icon = this._getHeaderIconElement(element);

      // move the heading before the collapsible content
      header.prependTo(element);

      // Set correct initial state
      if (collapse) {
        element.removeClass(CLASS_ACTIVE);
        if (!icon.hasClass("coral-Icon")) {
          icon.addClass("coral-Icon coral-Icon--sizeXS");
        }
        icon.removeClass(this.options.iconClassExpanded).addClass(this.options.iconClassCollapsed);
        content.hide();
      } else {
        element.addClass(CLASS_ACTIVE);
        if (!icon.hasClass("coral-Icon")) {
          icon.addClass("coral-Icon coral-Icon--sizeXS");
        }
        icon.removeClass(this.options.iconClassCollapsed).addClass(this.options.iconClassExpanded);
        content.show();
      }
    },
    _collapse: function (el) {
      var header = this._getHeaderElement(el),
        content = this._getContentElement(el),
        icon = this._getHeaderIconElement(el);

      icon.removeClass(this.options.iconClassExpanded).addClass(this.options.iconClassCollapsed);

      content.slideUp({
        duration: "fast",
        complete: function () {
          el.removeClass(CLASS_ACTIVE); // remove the active class after animation so that background color doesn't change during animation
          el.trigger("deactivate");
        },
        progress: function (animation, progress, remainingMs) {
          el.trigger("collapse", {animation: animation, progress: progress, remainingMs: remainingMs});
        }
      });

      // update WAI-ARIA accessibility properties
      if (this.isAccordion) {
        header.attr({
          "tabindex": header.is(document.activeElement) ? 0 : -1,
          "aria-selected": false
        });
      } else {
        header.attr({
          "aria-expanded": false
        });
      }
      content.attr({
        "aria-hidden": true,
        "aria-expanded": false
      });
    },
    _expand: function (el) {
      var header = this._getHeaderElement(el),
        content = this._getContentElement(el),
        icon = this._getHeaderIconElement(el);

      el.addClass(CLASS_ACTIVE);
      icon.removeClass(this.options.iconClassCollapsed).addClass(this.options.iconClassExpanded);

      content.slideDown({
        duration: "fast",
        complete: function () {
          el.trigger("activate");
        },
        progress: function (animation, progress, remainingMs) {
          el.trigger("expand", {animation: animation, progress: progress, remainingMs: remainingMs});
        }
      });

      // update WAI-ARIA accessibility properties
      if (this.isAccordion) {
        header.attr({
          "tabindex": 0,
          "aria-selected": true
        });
      } else {
        header.attr({
          "aria-expanded": true
        });
      }
      content.attr({
        "aria-hidden": false,
        "aria-expanded": true
      }).show();
    },
    /** @ignore */
    _getCollapsibleSelector: function () {
      return this.isAccordion ? '.coral-Accordion-item' : '.coral-Collapsible';
    },
    /** @ignore */
    _getHeaderElement: function (el) {
      var selector = this.isAccordion ? '> .coral-Accordion-header' : '> .coral-Collapsible-header';
      return el.find(selector);
    },
    /** @ignore */
    _getHeaderFirstElement: function (el) {
      var selector = this.isAccordion ? '> .coral-Accordion-header:first' : '> .coral-Collapsible-header:first';
      return el.find(selector);
    },
    /** @ignore */
    _prependHeaderElement: function (el) {
      var className = this.isAccordion ? 'coral-Accordion-header' : 'coral-Collapsible-header';
      el.prepend("<h3 class=\"" + className + "\">&nbsp;</h3>");
    },
    /** @ignore */
    _getHeaderIconElement: function (el) {
      var selector = this.isAccordion ? '> .coral-Accordion-header > i' : '> .coral-Collapsible-header > i';
      return el.find(selector);
    },
    /** @ignore */
    _prependHeaderIconElement: function (el) {
      this._getHeaderElement(el).prepend("<i></i>");
    },
    /** @ignore */
    _getContentElement: function (el) {
      var selector = this.isAccordion ? '> .coral-Accordion-content' : '> .coral-Collapsible-content';
      return el.find(selector);
    },
    /** @ignore */
    _prependContentElement: function (el) {
      var className = this.isAccordion ? 'coral-Accordion-content' : 'coral-Collapsible-content';
      el.prepend("<div class=\"" + className + "\"></div>");
    },
    /**
     * adds accessibility attributes and features
     * per the WAI-ARIA Accordion widget design pattern:
     * http://www.w3.org/WAI/PF/aria-practices/#accordion
     * @private
     */
    _makeAccessible: function () {
      var idPrefix = 'accordion-' + new Date().getTime() + '-',
        section, header, content, isActive, panelId;
      if (this.isAccordion) {

        this.$element.attr({
          "role": "tablist" // accordion container has the role="tablist"
        });

        this.$element.children(".coral-Accordion-item").each(function (i, e) {
          var section = $(e),
            header = section.find("> .coral-Accordion-header:first"),
            isActive = section.hasClass(CLASS_ACTIVE),
            panelId = idPrefix + 'panel-' + i,
            content = header.next("div");

          section.attr({
            "role": "presentation" // collapsible containers have the role="presentation"
          });

          header.attr({
            "role": "tab", // accordion headers should have the role="tab"
            "id": header.attr("id") || idPrefix + "tab-" + i, // each tab needs an id
            "aria-controls": panelId, // the id for the content wrapper this header controls
            "aria-selected": isActive, // an indication of the current state
            "tabindex": (isActive ? 0 : -1)
          });

          content.attr({
            "role": "tabpanel", // the content wrapper should have the role="tabpanel"
            "id": panelId, // each content wrapper needs a unique id
            "aria-labelledby": header.attr("id"), // the content wrapper is labelled by its header
            "aria-expanded": isActive, // an indication of the current state
            "aria-hidden": !isActive // hide/show content to assistive technology
          });
        });

      } else {
        idPrefix = 'collapsible-' + new Date().getTime() + '-';
        section = this.$element;
        header = this._getHeaderFirstElement(section);
        isActive = section.hasClass(CLASS_ACTIVE);
        panelId = idPrefix + 'panel';
        content = header.next("div");

        header.attr({
          "role": "button", // the header should have the role="button"
          "id": header.attr("id") || idPrefix + "heading", // each header needs an id
          "aria-controls": panelId, // the id for the content wrapper this header controls
          "aria-expanded": isActive, // an indication of the current state
          "tabindex": 0
        });

        content.attr({
          "id": panelId, // each content wrapper needs a unique id
          "aria-labelledby": header.attr("id"), // the content wrapper is labelled by its header
          "aria-expanded": isActive, // an indication of the current state
          "aria-hidden": !isActive // hide/show content to assistive technology
        });
      }

      // handle keydown events from focusable descendants
      this.$element.on('keydown', ':focusable', this._onKeyDown.bind(this));

      // handle focusin/focusout events from focusable descendants
      this.$element.on('focusin.accordion', ':focusable', this._onFocusIn.bind(this));
      this.$element.on('focusout.accordion', '.coral-Accordion-header:focusable', this._onFocusOut.bind(this));

      this.$element.on('touchstart.accordion, mousedown.accordion', '.coral-Accordion-header:focusable', this._onMouseDown.bind(this));
    },

    /**
     * keydown event handler, which defines the keyboard behavior of the accordion control
     * per the WAI-ARIA Accordion widget design pattern:
     * http://www.w3.org/WAI/PF/aria-practices/#accordion
     * @private
     */
    _onKeyDown: function (event) {
      var el = $(event.currentTarget).closest(this._getCollapsibleSelector()),
        header = this._getHeaderFirstElement(el),
        isHead = $(event.currentTarget).is(header),
        keymatch = true;

      switch (event.which) {
        case 13: //enter
        case 32: //space
          if (isHead) {
            header.trigger('click');
          } else {
            keymatch = false;
          }
          break;
        case 33: //page up
        case 37: //left arrow
        case 38: //up arrow
          if ((isHead && this.isAccordion) || (event.which === 33 && (event.metaKey || event.ctrlKey))) {
            // If the event.target is an accordion heading, or the key command is CTRL + PAGE_UP,
            // focus the previous accordion heading, or if none exists, focus the last accordion heading.
            if (this._getHeaderFirstElement(el.prev()).focus().length === 0) {
              this.$element.find("> .coral-Accordion-item:last > .coral-Accordion-header:first").focus();
            }
          } else if (!isHead && (event.metaKey || event.ctrlKey)) {
            // If the event.target is not a collapsible heading,
            // and the key command is CTRL + UP or CTRL + LEFT, focus the collapsible heading.
            header.focus();
          } else {
            keymatch = false;
          }
          break;
        case 34: //page down
        case 39: //right arrow
        case 40: //down arrow
          if (isHead && this.isAccordion) {
            // If the event.target is an accordion heading,
            // focus the next accordion heading, or if none exists, focus the first accordion heading.
            if (this._getHeaderFirstElement(el.next()).focus().length === 0) {
              this.$element.find("> .coral-Accordion-item:first > .coral-Accordion-header:first").focus();
            }
          } else if (!isHead && event.which === 34 && (event.metaKey || event.ctrlKey)) {
            // If the event.target is not a collapsible heading,
            // and the key command is CTRL + PAGE_DOWN, focus the collapsible heading.
            header.focus();
          } else {
            keymatch = false;
          }
          break;
        case 36: //home
          if (isHead && this.isAccordion) {
            this.$element.find("> .coral-Accordion-item:first > .coral-Accordion-header:first").focus();
          } else {
            keymatch = false;
          }
          break;
        case 35: //end
          if (isHead && this.isAccordion) {
            this.$element.find("> .coral-Accordion-item:last > .coral-Accordion-header:first").focus();
          } else {
            keymatch = false;
          }
          break;
        default:
          keymatch = false;
          break;
      }

      if (keymatch === true) {
        event.preventDefault();
      }
    },
    /**
     * focusin event handler, used to update tabindex properties on accordion headers
     * and to display focus style on headers.
     * @private
     */
    _onFocusIn: function (event) {
      var el = $(event.currentTarget).closest(this._getCollapsibleSelector()),
        header = this._getHeaderFirstElement(el),
        isHead = $(event.currentTarget).is(header);
      if (this.options.disabled) return;
      if (isHead) {
        if (this.isAccordion) {
          this.$element.find("> .coral-Accordion-item > .coral-Accordion-header[role=tab]").attr('tabindex', -1);
        }
        if (!header.data('collapsible-mousedown')) {
          // el.addClass(':focus');
          el.focus();
        } else {
          header.removeData('collapsible-mousedown');
        }
      }
      header.attr('tabindex', 0);
    },
    /**
     * focusout event handler, used to clear the focus style on headers.
     * @private
     */
    _onFocusOut: function (event) {
      var el = $(event.currentTarget).closest(this._getCollapsibleSelector()),
        header = this._getHeaderFirstElement(el),
        isHead = $(event.currentTarget).is(header);
      if (isHead) {
        el.blur().removeData('collapsible-mousedown');
        // el.removeClass(':focus').removeData('collapsible-mousedown');
      }
    },
    /**
     * mousedown event handler, used flag
     * @private
     */
    _onMouseDown: function (event) {
      var el = $(event.currentTarget).closest(this._getCollapsibleSelector()),
        header = this._getHeaderFirstElement(el),
        isHead = $(event.currentTarget).is(header);
      if (isHead) {
        header.data('collapsible-mousedown', true);
      }
    }

    /**
     Triggered when the accordion is activated

     @name CUI.Accordion#activate
     @event

     @param {Object} evt                    Event object
     */

    /**
     Triggered when the accordion is deactivated

     @name CUI.Accordion#deactivate
     @event

     @param {Object} evt                    Event object
     */

    /**
     Triggered while the accordion is expanding after each step of the animation

     @name CUI.Accordion#expand
     @event

     @param {Object} evt                    Event object

     @param options
     @param {Promise} options.animation     The animation promise
     @param {Number} options.progress       The progress
     @param {Number} options.remainingMs    The remaining time of the animation in milliseconds
     */

    /**
     Triggered while the accordion is collapsing after each step of the animation

     @name CUI.Accordion#collapse
     @event

     @param {Object} evt                    Event object

     @param options
     @param {Promise} options.animation     The animation promise
     @param {Number} options.progress       The progress
     @param {Number} options.remainingMs    The remaining time of the animation in milliseconds
     */

  });

  CUI.Widget.registry.register("accordion", CUI.Accordion);

// Data API
  $(document).on("cui-contentloaded.data-api", function (e) {
    CUI.Accordion.init($("[data-init~=accordion],[data-init~=collapsible]", e.target));
  });
}(window.jQuery));

(function ($) {
  CUI.Alert = new Class(/** @lends CUI.Alert# */{
    toString: 'Alert',
    extend: CUI.Widget,

    /**
      @extends CUI.Widget
      @classdesc An optionally closeable alert message.

      @desc Creates a new alert
      @constructs

      @param {Object} options                               Component options
      @param {String} [options.heading=Type, capitalized]   Title of the alert
      @param {String} options.content                       Content of the alert
      @param {Boolean} options.closeable                     Array of button descriptors
      @param {String} [options.size=small]                  Size of the alert. Either large or small.
      @param {String} [options.type=error]                  Type of alert to display. One of error, notice, success, help, or info
    */
    construct: function (options) {
      // Catch clicks to dismiss alert
      this.$element.delegate('[data-dismiss="alert"]', 'click.dismiss.alert', this.hide);

      // Add alert class to give styling
      this.$element.addClass('coral-Alert');

      // Listen to changes to configuration
      this.$element.on('change:heading', this._setHeading.bind(this));
      this.$element.on('change:content', this._setContent.bind(this));
      this.$element.on('change:type', this._setType.bind(this));
      this.$element.on('change:closeable', this._setCloseable.bind(this));
      this.$element.on('change:size', this._setSize.bind(this));

      // Read in options "set" by markup so we don't override the values they set
      for (var typeKey in this._types) {
        if (this.$element.hasClass(this._types[typeKey]["class"])) {
          this.options.type = typeKey;
          return false;
        }
      }

      for (var sizeKey in this._sizes) {
        if (this.$element.hasClass(this._sizes[sizeKey])) {
          this.options.size = sizeKey;
          return false;
        }
      }

      this._setCloseable();
      this._setType();
      this._setSize();
      this._setHeading();
      this._setContent();

    },

    defaults: {
      type: 'error',
      size: 'small',
      heading: undefined,
      visible: true,
      closeable: true
    },

    _types: {
      "error" : { "class": "coral-Alert--error", "iconClass": "coral-Icon--alert"},
      "notice" : { "class":  "coral-Alert--notice", "iconClass": "coral-Icon--alert"},
      "success" : { "class":  "coral-Alert--success", "iconClass": "coral-Icon--checkCircle"},
      "help" : { "class":  "coral-Alert--help", "iconClass": "coral-Icon--helpCircle"},
      "info" : { "class":  "coral-Alert--info", "iconClass": "coral-Icon--infoCircle"}
    },

    _sizes: {
      "small" : "",
      "large" : "coral-Alert--large"
    },

    /** @ignore */
    _setContent: function () {
      if (typeof this.options.content === 'string') {
        this.$element.find('div').html(this.options.content);
      }
    },

    /** @ignore */
    _setHeading: function () {
      if (typeof this.options.heading === 'string') {
        this.$element.find('strong').html(this.options.heading);
      }
    },

    /** @ignore */
    _setType: function () {
      if (this._isValidType(this.options.type)) {
        var icon = this.$element.find('> .coral-Icon');
        for (var key in this._types) {
           this.$element.removeClass(this._types[key]["class"]);
           icon.removeClass(this._types[key]["iconClass"]);
        }
        this.$element.addClass(this._types[this.options.type]["class"]);
        var iconClass = this._types[this.options.type]["iconClass"];
        icon.addClass(iconClass);
      }

    },

    /** @ignore */
    _setSize: function () {
      if (this._isValidSize(this.options.size)) {
        if (this.options.size === 'small') {
          this.$element.removeClass(this._sizes['large']);
        }
        else {
          this.$element.addClass(this._sizes['large']);
        }
      }
    },

    /** @ignore */
    _setCloseable: function () {
      var el = this.$element.find('.coral-Alert-closeButton');
      if (!el.length && this.options.closeable) {
        // Add the close element if it's not present
        this.$element.prepend('<button class="coral-MinimalButton coral-Alert-closeButton" title="Close" data-dismiss="alert"><i class="coral-Icon coral-Icon--sizeXS coral-Icon--close coral-MinimalButton-icon"></i></button>');
      }
      else {
        el[this.options.closeable ? 'show' : 'hide']();
      }
    },

    /** @ignore */
    _isValidType: function (value) {
      return typeof value == 'string' && this._types.hasOwnProperty(value);
    },

    /** @ignore */
    _isValidSize: function (value) {
      return typeof value == 'string' && this._sizes.hasOwnProperty(value);
    },

    /** @ignore */
    _fixType: function (value) {
      return this._isValidType(value) ? value : this.defaults.type;
    },

    /** @ignore */
    _fixHeading: function (value) {
      return value === undefined ? this._fixType(this.options.type).toUpperCase() : value;
    }

  });

  CUI.Widget.registry.register('alert', CUI.Alert);

  // Data API
  if (CUI.options.dataAPI) {
    $(function () {
      $(document).on('click.alert.data-api', '[data-dismiss="alert"]', function (evt) {
        $(evt.currentTarget).parent().hide();
        evt.preventDefault();
      });
    });
  }
}(window.jQuery));

(function ($) {
  CUI.CharacterCount = new Class(/** @lends CUI.CharacterCount# */{
    toString: 'CharacterCount',
    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc Give visual feedback of the maximum length for textfields/textarea to the user.
     <p>This widget will not restrict the
     user to the max length given: The user can enter as much text
     as he/she wants and will only get visual feedback.</p>
     <p>For textareas some browsers count newline characters differently: While they count as 2 chars in the browsers builtin maxlength support,
     they only count as 1 char in this widget.</p>

     @desc Create a character count for a textfield or textarea.
     @constructs

     @param {Object} options Component options
     @param {Object} [options.related] The related Textfield or TextArea for this component.
     @param {String} [options.maxlength] Maximum length for the Textfield/Textarea (will be read from markup if given)
     */
    construct: function (options) {

      this.$input = $(this.options.related);

      if (this.$input.attr("maxlength")) {
        this.options.maxlength = this.$input.attr("maxlength");
      }
      this.$input.removeAttr("maxlength"); // Remove so that we can do our own error handling

      this.$input.on("input", this._render.bind(this));
      this.$element.on("change:maxlength", this._render.bind(this));
      this.$element.attr("aria-live", "polite");

      this._render();

    },

    defaults: {
      maxlength: null
    },

    /**
     * @private
     * @return {Number} [description]
     */
    _getLength: function () {
      return this.$input.is("input,textarea") ? this.$input.val().length :
        this.$input.text().length;
    },

    _render: function () {
      var len = this._getLength(),
        exceeded = this.options.maxlength ? (len > this.options.maxlength) : false;

      this.$input.toggleClass("is-invalid", exceeded);
      this.$element.toggleClass("is-invalid", exceeded);

      this.$element.text(this.options.maxlength ? (this.options.maxlength - len) : len);
    }
  });

  CUI.Widget.registry.register("character-count", CUI.CharacterCount);

  // Data API
  $(document).on("cui-contentloaded.data-api", function (e) {
    CUI.CharacterCount.init($("[data-init~=character-count]", e.target));
  });
}(window.jQuery));



(function ($) {
  "use strict";

  function getNext($collection, current) {
    var currentIndex = current ? $collection.index(current) : -1;

    if (currentIndex === -1 || currentIndex === $collection.length - 1) {
      // current one was not found or current one is the last one
      return $collection.eq(0);
    }
    else {
      // current one was found => return next one
      return $collection.eq(currentIndex + 1);
    }
  }

  CUI.CycleButton = new Class(/** @lends CUI.CycleButton# */{
    toString: "CycleButton",
    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc
     A component that show the current active item. Only one item can be active at the same time.
     When clicked, the next item of the active is shown and the click is triggered at that next item instead.
     If the last item is clicked, then the first item is shown and triggered accordingly.

     @desc Creates a new instance
     @constructs

     @param {Object} options Widget options
     */
    construct: function () {
      // Currently doesn't support form submission
      // When you need it please raise the issue in the mailing first, as the
      // feature should not be necessarily implemented in this component

      this.$element.on("click", ".coral-CycleButton-button", function (e) {
        if (e._cycleButton) {
          return;
        }

        e.stopImmediatePropagation();
        e.preventDefault();

        var buttons = $(e.delegateTarget).find(".coral-CycleButton-button");
        var next    = getNext(buttons, this);

        buttons.removeClass("is-active");
        next.addClass("is-active").focus();

        var click = $.Event("click", {
          _cycleButton: true
        });
        next.trigger(click);
      });
    }
  });

  CUI.Widget.registry.register("cyclebutton", CUI.CycleButton);

  // Data API
  $(document).on("cui-contentloaded.data-api", function (e) {
    CUI.CycleButton.init($("[data-init~='cyclebutton']", e.target));
  });
}(window.jQuery));

/**
 HTTP Utility functions used by CoralUI widgets

 @namespace
 */
CUI.util.HTTP = {
  /**
   * Checks whether the specified status code is OK.
   * @static
   * @param {Number} status The status code
   * @return {Boolean} True if the status is OK, else false
   */
  isOkStatus: function(status) {
    try {
      return (String(status).indexOf("2") === 0);
    } catch (e) {
      return false;
    }
  },

  /**
   * Returns <code>true</code> if HTML5 Upload is supported
   * @return {Boolean} HTML5 Upload support status
   */
  html5UploadSupported: function() {
    var xhr = new XMLHttpRequest();
    return !! (
      xhr && ('upload' in xhr) && ('onprogress' in xhr.upload)
    );
  }
};

(function ($) {
  CUI.FileUpload = new Class(/** @lends CUI.FileUpload# */{
    toString: 'FileUpload',
    extend: CUI.Widget,

    /**
     Triggered when a file is selected and accepted into the queue

     @name CUI.FileUpload#fileselected
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when a selected file is rejected before upload

     @name CUI.FileUpload#filerejected
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {String} evt.message            The reason why the file has been rejected
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when the internal upload queue changes (file added, file uploaded, etc.)

     @name CUI.FileUpload#queuechanged
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {String} evt.operation          The operation on the queue (ADD or REMOVE)
     @param {int} evt.queueLength           The number of items in the queue
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when selected files list is processed

     @name CUI.FileUpload#filelistprocessed
     @event

     @param {Object} evt                    Event object
     @param {int} evt.addedCount            The number of files that have been added to the processing list
     @param {int} evt.rejectedCount         The number of files that have been rejected
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when upload of a file starts

     @name CUI.FileUpload#fileuploadstart
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {Object} evt.originalEvent      The original upload event
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when upload of a file progresses

     @name CUI.FileUpload#fileuploadprogress
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {Object} evt.originalEvent      The original upload event (from which the upload ratio can be calculated)
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when upload of a file is completed (for non-HTML5 uploads only, regardless of success status)

     @name CUI.FileUpload#fileuploadload
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {String} evt.content            The server response to the upload request, which needs to be analyzed to determine if upload was successful
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when upload of a file succeeded

     @name CUI.FileUpload#fileuploadsuccess
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {Object} evt.originalEvent      The original upload event
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when upload of a file failed

     @name CUI.FileUpload#fileuploaderror
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {Object} evt.originalEvent      The original upload event
     @param {String} evt.message            The reason why the file upload failed
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when upload of a file has been cancelled

     @name CUI.FileUpload#fileuploadcanceled
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.item               Object representing a file item
     @param {Object} evt.originalEvent      The original upload event
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when dragging into a drop zone

     @name CUI.FileUpload#dropzonedragenter
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.originalEvent      The original mouse drag event
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when dragging over a drop zone

     @name CUI.FileUpload#dropzonedragover
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.originalEvent      The original mouse drag event
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when dragging out of a drop zone

     @name CUI.FileUpload#dropzonedragleave
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.originalEvent      The original mouse drag event
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     Triggered when dropping files in a drop zone

     @name CUI.FileUpload#dropzonedrop
     @event

     @param {Object} evt                    Event object
     @param {Object} evt.originalEvent      The original mouse drop event
     @param {FileList} evt.files            The list of dropped files
     @param {Object} evt.fileUpload         The file upload widget
     */

    /**
     @extends CUI.Widget
     @classdesc A file upload widget

     @desc Creates a file upload field
     @constructs

     @param {Object}   options                                    Component options
     @param {String}   [options.name="file"]                      (Optional) name for an underlying form field.
     @param {String}   [options.placeholder=null]                 Define a placeholder for the input field
     @param {String}   [options.uploadUrl=null]                   URL where to upload the file. (If none is provided, the wigdet is disabled)
     @param {String}   [options.uploadUrlBuilder=null]            Upload URL builder
     @param {boolean}  [options.disabled=false]                   Is this component disabled?
     @param {boolean}  [options.multiple=false]                   Can the user upload more than one file?
     @param {int}      [options.sizeLimit=null]                   File size limit
     @param {Array}    [options.mimeTypes=[]]                     Mime types allowed for uploading (proper mime types, wildcard "*" and file extensions are supported)
     @param {boolean}  [options.autoStart=false]                  Should upload start automatically once the file is selected?
     @param {String}   [options.fileNameParameter=null]           Name of File name's parameter
     @param {boolean}  [options.useHTML5=true]                    (Optional) Prefer HTML5 to upload files (if browser allows it)
     @param {Mixed}    [options.dropZone=null]                    (Optional) jQuery selector or DOM element to use as dropzone (if browser allows it)
     @param {Object}   [options.events={}]                        (Optional) Event handlers
     */
    construct: function (options) {
      // Adjust DOM to our needs
      this._render();

      this.inputElement.on("change", function (event) {
        if (this.options.disabled) {
          return;
        }
        this._onFileSelectionChange(event);
      }.bind(this));

      this._makeAccessible();
    },

    defaults: {
      name: "file",
      placeholder: null,
      uploadUrl: null,
      uploadUrlBuilder: null,
      disabled: false,
      multiple: false,
      sizeLimit: null,
      mimeTypes: [], // Default case: no restriction on mime types
      autoStart: false,
      fileNameParameter: null,
      useHTML5: true,
      dropZone: null,
      events: {}
    },

    inputElement: null,
    $inputContainer: null,
    fileNameElement: null,
    uploadQueue: [],

    /** @ignore */
    _render: function () {
      var self = this;

      // container for the input
      this.$inputContainer = this.$element.find(".coral-FileUpload-trigger");

      // Get the input element
      this.inputElement = this.$inputContainer.find(".coral-FileUpload-input");

      // Read configuration from markup
      this._readDataFromMarkup();

      if (!CUI.util.HTTP.html5UploadSupported()) {
        this.options.useHTML5 = false;
      }

      this._createMissingElements();

      // Register event handlers
      if (this.options.events) {
        if (typeof this.options.events === "object") {
          for (var name in this.options.events) {
            this._registerEventHandler(name, this.options.events[name]);
          }
        }
      }

      // Register drop zone
      if (this.options.useHTML5) {
        this._registerDropZone();
      } else {
        this.options.dropZone = null;
      }

      if (!this.options.placeholder) {
        this.options.placeholder = this.inputElement.attr("placeholder");
      }

      if (this.options.autoStart) {
        this._registerEventHandler("fileselected", function (event) {
          event.fileUpload.uploadFile(event.item);
        });
      }

      // URL built via JavaScript function
      if (this.options.uploadUrlBuilder) {
        this.options.uploadUrl = this.options.uploadUrlBuilder(this);
      }

      if (!this.options.uploadUrl || /\$\{.+\}/.test(this.options.uploadUrl)) {
        this.options.disabled = true;
      }

      this._update();
    },

    /** @ignore */
    _makeAccessible: function() {
      if (this.$inputContainer.is('button')) {
        var $span = $('<span>'),
            attributes = this.$inputContainer.prop('attributes');

        // loop through <button> attributes and apply them on <span>
        $.each(attributes, function() {
            $span.attr(this.name, this.value);
        });

        $span.insertBefore(this.$inputContainer);
        $span.append(this.$inputContainer.children());

        this.$inputContainer.remove();
        this.$inputContainer = $span;
      }

      if ((this.inputElement.attr('id') && $('label[for="' + this.inputElement.attr('id') + '"]').length === 0) || this.inputElement.closest('label').text().trim().length === 0) {
        if (this.inputElement.is('[title]:not([aria-label]):not([aria-labelledby])')) {
          if (!this.inputElement.attr('id')) {
            this.inputElement.attr('id', CUI.util.getNextId());
          }
          var $label = $('<label>'),
              $target = this.$element.find('.coral-FileUpload-trigger .coral-Icon');
          if (!$target.length) {
              $target = this.$element.find('.coral-FileUpload-trigger input');
          }

          $label.attr('for', this.inputElement.attr('id'))
            .text(this.inputElement.attr('title'));

          if (this.inputElement.closest('.coral-Icon').length) {
            $label.addClass('u-coral-screenReaderOnly');
          }

          $target.after($label);
        }
      }

      this.inputElement
        .on("focusin.cui-fileupload focusout.cui-fileupload", this._toggleIsFocused.bind(this));
    },

    /** @ignore */
    _toggleIsFocused: function(event) {
      this.$inputContainer.toggleClass('is-focused', event.type === 'focusin');
    },

    _registerDropZone: function () {
      var self = this;

      if (!self.options.dropZone) {
        // No dropZone specified, a default one that wraps the whole fileupload is then created
        self.$element.addClass("coral-FileUpload--dropSupport");

        self.options.dropZone = self.$element;
      }

      // Try to get the drop zone via a jQuery selector
      try {
        self.options.dropZone = $(self.options.dropZone);
      } catch (e) {
        delete self.options.dropZone;
      }

      if (self.options.dropZone) {
        self.options.dropZone
            .on("dragenter", function (e) {
              if (self._isActive()) {

                if (e.stopPropagation) {
                  e.stopPropagation();
                }
                if (e.preventDefault) {
                  e.preventDefault();
                }

                self.$element.trigger({
                  type: "dropzonedragenter",
                  originalEvent: e,
                  fileUpload: self
                });
              }

              return false;
            })
          .on("dragover", function (e) {
            if (self._isActive()) {
              self.isDragOver = true;

              if (e.stopPropagation) {
                e.stopPropagation();
              }
              if (e.preventDefault) {
                e.preventDefault();
              }

              self.$element.trigger({
                type: "dropzonedragover",
                originalEvent: e,
                fileUpload: self
              });
            }

            return false;
          })
          .on("dragleave", function (e) {
            if (self._isActive()) {
              if (e.stopPropagation) {
                e.stopPropagation();
              }
              if (e.preventDefault) {
                e.preventDefault();
              }

              self.isDragOver = false;

              window.setTimeout(function () {
                if (!self.isDragOver) {
                  self.$element.trigger({
                    type: "dropzonedragleave",
                    originalEvent: e,
                    fileUpload: self
                  });
                }
              }, 1);
            }

            return false;
          })
          .on("drop", function (e) {
            if (self._isActive()) {
              if (e.stopPropagation) {
                e.stopPropagation();
              }
              if (e.preventDefault) {
                e.preventDefault();
              }

              var files = e.originalEvent.dataTransfer.files;

              self.$element.trigger({
                type: "dropzonedrop",
                originalEvent: e,
                files: files,
                fileUpload: self
              });

              self._onFileSelectionChange(e, files);
            }

            return false;
          })
        ;
      }
    },

    _registerEventHandler: function (name, handler) {
      this.$element.on(name, handler);
    },

    _createMissingElements: function () {
      var self = this;

      var multiple = self.options.useHTML5 && self.options.multiple;
      if (self.inputElement.length === 0) {
        self.inputElement = $("<input/>", {
          type: "file",
          'class': 'coral-FileUpload-input',
          name: self.options.name,
          multiple: multiple
        });
        self.$inputContainer.prepend(self.inputElement);
      } else {
        self.inputElement.attr("multiple", multiple);
      }
    },

    /** @ignore */
    _readDataFromMarkup: function () {
      var self = this;
      if (this.inputElement.attr("name")) {
        this.options.name = this.inputElement.attr("name");
      }
      if (this.inputElement.attr("placeholder")) {
        this.options.placeholder = this.inputElement.attr("placeholder");
      }
      if (this.inputElement.data("placeholder")) {
        this.options.placeholder = this.inputElement.data("placeholder");
      }
      if (this.inputElement.attr("disabled") || this.inputElement.data("disabled")) {
        this.options.disabled = true;
      }
      if (this.inputElement.attr("multiple") || this.inputElement.data("multiple")) {
        this.options.multiple = true;
      }
      if (this.inputElement.data("uploadUrl")) {
        this.options.uploadUrl = this.inputElement.data("uploadUrl");
      }
      if (this.inputElement.data("uploadUrlBuilder")) {
        this.options.uploadUrlBuilder = CUI.util.buildFunction(this.inputElement.data("uploadUrlBuilder"), ["fileUpload"]);
      }
      if (this.inputElement.data("mimeTypes")) {
        this.options.mimeTypes = this.inputElement.data("mimeTypes");
      }
      if (this.inputElement.data("sizeLimit")) {
        this.options.sizeLimit = this.inputElement.data("sizeLimit");
      }
      if (this.inputElement.data("autoStart")) {
        this.options.autoStart = true;
      }
      if (this.inputElement.data("usehtml5")) {
        this.options.useHTML5 = this.inputElement.data("usehtml5") === true;
      }
      if (this.inputElement.data("dropzone")) {
        this.options.dropZone = this.inputElement.data("dropzone");
      }
      if (this.inputElement.data("fileNameParameter")) {
        this.options.fileNameParameter = this.inputElement.data("fileNameParameter");
      }
      var inputElementHTML = this.inputElement.length ? this.inputElement.get(0) : undefined;
      if (inputElementHTML) {
        $.each(inputElementHTML.attributes, function (i, attribute) {
          var match = /^data-event-(.*)$/.exec(attribute.name);
          if (match && match.length > 1) {
            var eventHandler = CUI.util.buildFunction(attribute.value, ["event"]);
            if (eventHandler) {
              self.options.events[match[1]] = eventHandler.bind(self);
            }
          }
        });
      }
    },

    /** @ignore */
    _update: function () {
      if (this.options.placeholder) {
        this.inputElement.attr("placeholder", this.options.placeholder);
      }

      if (this.options.disabled) {
        this.$element.addClass("is-disabled");
        this.$inputContainer.addClass("is-disabled");
        this.inputElement.attr("disabled", "disabled");
      } else {
        this.$element.removeClass("is-disabled");
        this.$inputContainer.removeClass("is-disabled");
        this.inputElement.removeAttr("disabled");
      }
    },

    /** @ignore */
    _onFileSelectionChange: function (event, files) {
      var addedCount = 0, rejectedCount = 0;
      if (this.options.useHTML5) {
        files = files || event.target.files;
        for (var i = 0; i < files.length; i++) {
          if (this._addFile(files[i])) {
            addedCount++;
          } else {
            rejectedCount++;
          }
        }
      } else {
        if (this._addFile(event.target)) {
          addedCount++;
        } else {
          rejectedCount++;
        }
      }

      this.$element.trigger({
        type: "filelistprocessed",
        addedCount: addedCount,
        rejectedCount: rejectedCount,
        fileUpload: this
      });
    },

    /** @ignore */
    _addFile: function (file) {
      var self = this;

      var fileName,
        fileMimeType;
      if (this.options.useHTML5) {
        fileName = file.name;
        fileMimeType = file.type;
      } else {
        fileName = $(file).attr("value") || file.value;
      }

      fileMimeType = fileMimeType || CUI.FileUpload.MimeTypes.getMimeTypeFromFileName(fileName);

      if (fileName.lastIndexOf("\\") !== -1) {
        fileName = fileName.substring(fileName.lastIndexOf("\\") + 1);
      }

      // if no autostart is used we need to set fileNameParameter as an additional form input field
      // to be submitted with the form.
      if (self.options.fileNameParameter && !this.options.autoStart) {
        if (!self.fileNameElement) {
          // check if there is already a form input field defined to store the parameter
          self.fileNameElement = $("input[name=\"" + self.options.fileNameParameter + "\"]");
          if (self.fileNameElement.length === 0) {
            // create and append
            self.fileNameElement = $("<input/>", {
              type: "hidden",
              name: self.options.fileNameParameter
            });
            self.fileNameElement.appendTo(self.$element);
          }
        }
        self.fileNameElement.val(fileName);
      }

      if (!self._getQueueItemByFileName(fileName)) {
        var item = {
          fileName: fileName
        };
        if (this.options.useHTML5) {
          item.file = file;
          item.fileSize = file.size;

          // Check file size
          if (self.options.sizeLimit && file.size > self.options.sizeLimit) {
            self.$element.trigger({
              type: "filerejected",
              item: item,
              message: "File is too big",
              fileUpload: self
            });
            return false;
          }
        }

        // Check file mime type against allowed mime types
        if (!self._checkMimeTypes(fileMimeType)) {
          self.$element.trigger({
            type: "filerejected",
            item: item,
            message: "File mime type is not allowed",
            fileUpload: self
          });
          return false;
        }

        // Add item to queue
        self.uploadQueue.push(item);
        self.$element.trigger({
          type: "queuechanged",
          item: item,
          operation: "ADD",
          queueLength: self.uploadQueue.length,
          fileUpload: self
        });

        self.$element.trigger({
          type: "fileselected",
          item: item,
          fileUpload: self
        });

        return true;
      }

      return false;
    },

    /** @ignore */
    _checkMimeTypes: function (fileMimeType) {
      function isMimeTypeAllowed(fileMimeType, allowedMimeType) {
        var mimeTypeRegEx = /(.+)\/(.+)$/,      // "text/plain"
          fileExtensionRegEx = /\.(.+)$/,     // ".txt"
          shortcutRegEx = /.*/,               // "text"
          isAllowed = false;

        if (allowedMimeType === "*" || allowedMimeType === ".*" || allowedMimeType === "*/*") {
          // Explicit wildcard case: allow any file
          isAllowed = true;
        } else if (!fileMimeType || !fileMimeType.match(mimeTypeRegEx)) {
          // File mime type is erroneous
          isAllowed = false;
        } else if (allowedMimeType.match(mimeTypeRegEx)) {
          // Proper mime type case: directly compare with file mime type
          isAllowed = (fileMimeType === allowedMimeType);
        } else if (allowedMimeType.match(fileExtensionRegEx)) {
          // File extension case: map extension to proper mime type and then compare
          isAllowed = (fileMimeType === CUI.FileUpload.MimeTypes[allowedMimeType]);
        } else if (allowedMimeType.match(shortcutRegEx)) {
          // "Shortcut" case: only compare first part of the file mime type with the shortcut
          isAllowed = (fileMimeType.split("/")[0] === allowedMimeType);
        }
        return isAllowed;
      }

      var length = this.options.mimeTypes.length,
        i;

      if (length === 0) {
        // No restriction has been defined (default case): allow any file
        return true;
      } else {
        // Some restrictions have been defined
        for (i = 0; i < length; i += 1) {
          if (isMimeTypeAllowed(fileMimeType, this.options.mimeTypes[i])) {
            return true;
          }
        }
        // The file mime type matches none of the mime types allowed
        return false;
      }

    },

    /** @ignore */
    _getQueueIndex: function (fileName) {
      var index = -1;
      $.each(this.uploadQueue, function (i, item) {
        if (item.fileName === fileName) {
          index = i;
          return false;
        }
      });
      return index;
    },

    /** @ignore */
    _getQueueItem: function (index) {
      return index > -1 ? this.uploadQueue[index] : null;
    },

    /** @ignore */
    _getQueueItemByFileName: function (fileName) {
      return this._getQueueItem(this._getQueueIndex(fileName));
    },

    /**
     Upload a file item

     @param {Object} item                   Object representing a file item
     */
    uploadFile: function (item) {
      var self = this;

      if (self.options.useHTML5) {
        item.xhr = new XMLHttpRequest();
        item.xhr.addEventListener("loadstart", function (e) {
          self._onUploadStart(e, item);
        }, false);
        item.xhr.addEventListener("load", function (e) {
          self._onUploadLoad(e, item);
        }, false);
        item.xhr.addEventListener("error", function (e) {
          self._onUploadError(e, item);
        }, false);
        item.xhr.addEventListener("abort", function (e) {
          self._onUploadCanceled(e, item);
        }, false);

        var upload = item.xhr.upload;
        upload.addEventListener("progress", function (e) {
          self._onUploadProgress(e, item);
        }, false);

        // TODO: encoding of special characters in file names
        var file = item.file;
        var fileName = item.fileName;
        if (window.FormData) {
          var f = new FormData();
          if (self.options.fileNameParameter) {
            // Custom file and file name parameter
            f.append(self.inputElement.attr("name"), file);
            f.append(self.options.fileNameParameter || "fileName", fileName);
          } else {
            f.append(fileName, file);
          }
          f.append("_charset_", "utf-8");

          item.xhr.open("POST", self.options.uploadUrl + "?:ck=" + new Date().getTime(), true);
          item.xhr.send(f);
        } else {
          item.xhr.open("PUT", self.options.uploadUrl + "/" + fileName, true);
          item.xhr.send(file);
        }

      } else {
        var $body = $(document.body);

        // Build an iframe
        var iframeName = "upload-" + new Date().getTime();
        var $iframe = $("<iframe/>", {
          name: iframeName,
          "class": "coral-FileUpload-iframe"
        }).appendTo($body);

        // Build a form
        var $form = $("<form/>", {
          method: "post",
          enctype: "multipart/form-data",
          action: self.options.uploadUrl,
          target: iframeName,
          "class": "coral-FileUpload-form"
        }).appendTo($body);

        var $charset = $("<input/>", {
          type: "hidden",
          name: "_charset_",
          value: "utf-8"
        });
        $form.prepend($charset);

        // Define value of the file name element
        if (this.options.fileNameParameter) {
          this.fileNameElement = $("<input/>", {
            type: "hidden",
            name: this.options.fileNameParameter,
            value: item.fileName
          });
          $form.prepend(this.fileNameElement);
        }

        $iframe.one("load", function () {
          var content = this.contentWindow.document.body.innerHTML;
          self.inputElement.appendTo(self.$inputContainer);
          $form.remove();
          $iframe.remove();

          self.$element.trigger({
            type: "fileuploadload",
            item: item,
            content: content,
            fileUpload: self
          });
        });

        self.inputElement.prependTo($form);
        $form.submit();
      }
    },

    /**
     Cancel upload of a file item

     @param {Object} item                   Object representing a file item
     */
    cancelUpload: function (item) {
      item.xhr.abort();
    },

    /** @ignore */
    _onUploadStart: function (e, item) {
      this.$element.trigger({
        type: "fileuploadstart",
        item: item,
        originalEvent: e,
        fileUpload: this
      });
    },

    /** @ignore */
    _onUploadProgress: function (e, item) {
      // Update progress bar
      this.$element.trigger({
        type: "fileuploadprogress",
        item: item,
        originalEvent: e,
        fileUpload: this
      });
    },

    /** @ignore */
    _onUploadLoad: function (e, item) {
      var request = e.target;
      if (request.readyState === 4) {
        this._internalOnUploadLoad(e, item, request.status, request.responseText);
      }
    },

    /** @ignore */
    _internalOnUploadLoad: function (e, item, requestStatus, responseText) {
      if (CUI.util.HTTP.isOkStatus(requestStatus)) {
        this.$element.trigger({
          type: "fileuploadsuccess",
          item: item,
          originalEvent: e,
          fileUpload: this
        });
      } else {
        this.$element.trigger({
          type: "fileuploaderror",
          item: item,
          originalEvent: e,
          message: responseText,
          fileUpload: this
        });
      }

      // Remove file name element if needed
      if (this.fileNameElement) {
        this.fileNameElement.remove();
      }

      // Remove queue item
      this.uploadQueue.splice(this._getQueueIndex(item.fileName), 1);
      this.$element.trigger({
        type: "queuechanged",
        item: item,
        operation: "REMOVE",
        queueLength: this.uploadQueue.length,
        fileUpload: this
      });
    },

    /** @ignore */
    _onUploadError: function (e, item) {
      this.$element.trigger({
        type: "fileuploaderror",
        item: item,
        originalEvent: e,
        fileUpload: this
      });
    },

    /** @ignore */
    _onUploadCanceled: function (e, item) {
      this.$element.trigger({
        type: "fileuploadcanceled",
        item: item,
        originalEvent: e,
        fileUpload: this
      });
    },

    /** @ignore */
    _isActive: function () {
      return !this.inputElement.is(':disabled');
    }

  });

  CUI.Widget.registry.register("fileupload", CUI.FileUpload);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      CUI.FileUpload.init($("[data-init~='fileupload']", e.target));
    });
  }

}(window.jQuery));

(function ($) {
  CUI.FileUpload.MimeTypes =
  {
    ".123": "application/vnd.lotus-1-2-3",
    ".3dml": "text/vnd.in3d.3dml",
    ".3g2": "video/3gpp2",
    ".3gp": "video/3gpp",
    ".a": "application/octet-stream",
    ".aab": "application/x-authorware-bin",
    ".aac": "audio/x-aac",
    ".aam": "application/x-authorware-map",
    ".aas": "application/x-authorware-seg",
    ".abw": "application/x-abiword",
    ".acc": "application/vnd.americandynamics.acc",
    ".ace": "application/x-ace-compressed",
    ".acu": "application/vnd.acucobol",
    ".acutc": "application/vnd.acucorp",
    ".adp": "audio/adpcm",
    ".aep": "application/vnd.audiograph",
    ".afm": "application/x-font-type1",
    ".afp": "application/vnd.ibm.modcap",
    ".ai": "application/postscript",
    ".aif": "audio/x-aiff",
    ".aifc": "audio/x-aiff",
    ".aiff": "audio/x-aiff",
    ".air": "application/vnd.adobe.air-application-installer-package+zip",
    ".ami": "application/vnd.amiga.ami",
    ".apk": "application/vnd.android.package-archive",
    ".application": "application/x-ms-application",
    ".apr": "application/vnd.lotus-approach",
    ".asc": "application/pgp-signature",
    ".asf": "video/x-ms-asf",
    ".asm": "text/x-asm",
    ".aso": "application/vnd.accpac.simply.aso",
    ".asx": "video/x-ms-asf",
    ".atc": "application/vnd.acucorp",
    ".atom": "application/atom+xml",
    ".atomcat": "application/atomcat+xml",
    ".atomsvc": "application/atomsvc+xml",
    ".atx": "application/vnd.antix.game-component",
    ".au": "audio/basic",
    ".avi": "video/x-msvideo",
    ".aw": "application/applixware",
    ".azf": "application/vnd.airzip.filesecure.azf",
    ".azs": "application/vnd.airzip.filesecure.azs",
    ".azw": "application/vnd.amazon.ebook",
    ".bat": "application/x-msdownload",
    ".bcpio": "application/x-bcpio",
    ".bdf": "application/x-font-bdf",
    ".bdm": "application/vnd.syncml.dm+wbxml",
    ".bh2": "application/vnd.fujitsu.oasysprs",
    ".bin": "application/octet-stream",
    ".bmi": "application/vnd.bmi",
    ".bmp": "image/bmp",
    ".book": "application/vnd.framemaker",
    ".box": "application/vnd.previewsystems.box",
    ".boz": "application/x-bzip2",
    ".bpk": "application/octet-stream",
    ".btif": "image/prs.btif",
    ".bz": "application/x-bzip",
    ".bz2": "application/x-bzip2",
    ".c": "text/x-c",
    ".c4d": "application/vnd.clonk.c4group",
    ".c4f": "application/vnd.clonk.c4group",
    ".c4g": "application/vnd.clonk.c4group",
    ".c4p": "application/vnd.clonk.c4group",
    ".c4u": "application/vnd.clonk.c4group",
    ".cab": "application/vnd.ms-cab-compressed",
    ".car": "application/vnd.curl.car",
    ".cat": "application/vnd.ms-pki.seccat",
    ".cc": "text/x-c",
    ".cct": "application/x-director",
    ".ccxml": "application/ccxml+xml",
    ".cdbcmsg": "application/vnd.contact.cmsg",
    ".cdf": "application/x-netcdf",
    ".cdkey": "application/vnd.mediastation.cdkey",
    ".cdx": "chemical/x-cdx",
    ".cdxml": "application/vnd.chemdraw+xml",
    ".cdy": "application/vnd.cinderella",
    ".cer": "application/pkix-cert",
    ".cgm": "image/cgm",
    ".chat": "application/x-chat",
    ".chm": "application/vnd.ms-htmlhelp",
    ".chrt": "application/vnd.kde.kchart",
    ".cif": "chemical/x-cif",
    ".cii": "application/vnd.anser-web-certificate-issue-initiation",
    ".cil": "application/vnd.ms-artgalry",
    ".cla": "application/vnd.claymore",
    ".class": "application/java-vm",
    ".clkk": "application/vnd.crick.clicker.keyboard",
    ".clkp": "application/vnd.crick.clicker.palette",
    ".clkt": "application/vnd.crick.clicker.template",
    ".clkw": "application/vnd.crick.clicker.wordbank",
    ".clkx": "application/vnd.crick.clicker",
    ".clp": "application/x-msclip",
    ".cmc": "application/vnd.cosmocaller",
    ".cmdf": "chemical/x-cmdf",
    ".cml": "chemical/x-cml",
    ".cmp": "application/vnd.yellowriver-custom-menu",
    ".cmx": "image/x-cmx",
    ".cod": "application/vnd.rim.cod",
    ".com": "application/x-msdownload",
    ".conf": "text/plain",
    ".cpio": "application/x-cpio",
    ".cpp": "text/x-c",
    ".cpt": "application/mac-compactpro",
    ".crd": "application/x-mscardfile",
    ".crl": "application/pkix-crl",
    ".crt": "application/x-x509-ca-cert",
    ".csh": "application/x-csh",
    ".csml": "chemical/x-csml",
    ".csp": "application/vnd.commonspace",
    ".css": "text/css",
    ".cst": "application/x-director",
    ".csv": "text/csv",
    ".cu": "application/cu-seeme",
    ".curl": "text/vnd.curl",
    ".cww": "application/prs.cww",
    ".cxt": "application/x-director",
    ".cxx": "text/x-c",
    ".daf": "application/vnd.mobius.daf",
    ".dataless": "application/vnd.fdsn.seed",
    ".davmount": "application/davmount+xml",
    ".dcr": "application/x-director",
    ".dcurl": "text/vnd.curl.dcurl",
    ".dd2": "application/vnd.oma.dd2+xml",
    ".ddd": "application/vnd.fujixerox.ddd",
    ".deb": "application/x-debian-package",
    ".def": "text/plain",
    ".deploy": "application/octet-stream",
    ".der": "application/x-x509-ca-cert",
    ".dfac": "application/vnd.dreamfactory",
    ".dic": "text/x-c",
    ".diff": "text/plain",
    ".dir": "application/x-director",
    ".dis": "application/vnd.mobius.dis",
    ".dist": "application/octet-stream",
    ".distz": "application/octet-stream",
    ".djv": "image/vnd.djvu",
    ".djvu": "image/vnd.djvu",
    ".dll": "application/x-msdownload",
    ".dmg": "application/octet-stream",
    ".dms": "application/octet-stream",
    ".dna": "application/vnd.dna",
    ".doc": "application/msword",
    ".docm": "application/vnd.ms-word.document.macroenabled.12",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".dot": "application/msword",
    ".dotm": "application/vnd.ms-word.template.macroenabled.12",
    ".dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    ".dp": "application/vnd.osgi.dp",
    ".dpg": "application/vnd.dpgraph",
    ".dsc": "text/prs.lines.tag",
    ".dtb": "application/x-dtbook+xml",
    ".dtd": "application/xml-dtd",
    ".dts": "audio/vnd.dts",
    ".dtshd": "audio/vnd.dts.hd",
    ".dump": "application/octet-stream",
    ".dvi": "application/x-dvi",
    ".dwf": "model/vnd.dwf",
    ".dwg": "image/vnd.dwg",
    ".dxf": "image/vnd.dxf",
    ".dxp": "application/vnd.spotfire.dxp",
    ".dxr": "application/x-director",
    ".ecelp4800": "audio/vnd.nuera.ecelp4800",
    ".ecelp7470": "audio/vnd.nuera.ecelp7470",
    ".ecelp9600": "audio/vnd.nuera.ecelp9600",
    ".ecma": "application/ecmascript",
    ".edm": "application/vnd.novadigm.edm",
    ".edx": "application/vnd.novadigm.edx",
    ".efif": "application/vnd.picsel",
    ".ei6": "application/vnd.pg.osasli",
    ".elc": "application/octet-stream",
    ".eml": "message/rfc822",
    ".emma": "application/emma+xml",
    ".eol": "audio/vnd.digital-winds",
    ".eot": "application/vnd.ms-fontobject",
    ".eps": "application/postscript",
    ".epub": "application/epub+zip",
    ".es3": "application/vnd.eszigno3+xml",
    ".esf": "application/vnd.epson.esf",
    ".et3": "application/vnd.eszigno3+xml",
    ".etx": "text/x-setext",
    ".exe": "application/x-msdownload",
    ".ext": "application/vnd.novadigm.ext",
    ".ez": "application/andrew-inset",
    ".ez2": "application/vnd.ezpix-album",
    ".ez3": "application/vnd.ezpix-package",
    ".f": "text/x-fortran",
    ".f4v": "video/x-f4v",
    ".f77": "text/x-fortran",
    ".f90": "text/x-fortran",
    ".fbs": "image/vnd.fastbidsheet",
    ".fdf": "application/vnd.fdf",
    ".fe_launch": "application/vnd.denovo.fcselayout-link",
    ".fg5": "application/vnd.fujitsu.oasysgp",
    ".fgd": "application/x-director",
    ".fh": "image/x-freehand",
    ".fh4": "image/x-freehand",
    ".fh5": "image/x-freehand",
    ".fh7": "image/x-freehand",
    ".fhc": "image/x-freehand",
    ".fig": "application/x-xfig",
    ".fli": "video/x-fli",
    ".flo": "application/vnd.micrografx.flo",
    ".flv": "video/x-flv",
    ".flw": "application/vnd.kde.kivio",
    ".flx": "text/vnd.fmi.flexstor",
    ".fly": "text/vnd.fly",
    ".fm": "application/vnd.framemaker",
    ".fnc": "application/vnd.frogans.fnc",
    ".for": "text/x-fortran",
    ".fpx": "image/vnd.fpx",
    ".frame": "application/vnd.framemaker",
    ".fsc": "application/vnd.fsc.weblaunch",
    ".fst": "image/vnd.fst",
    ".ftc": "application/vnd.fluxtime.clip",
    ".fti": "application/vnd.anser-web-funds-transfer-initiation",
    ".fvt": "video/vnd.fvt",
    ".fzs": "application/vnd.fuzzysheet",
    ".g3": "image/g3fax",
    ".gac": "application/vnd.groove-account",
    ".gdl": "model/vnd.gdl",
    ".geo": "application/vnd.dynageo",
    ".gex": "application/vnd.geometry-explorer",
    ".ggb": "application/vnd.geogebra.file",
    ".ggt": "application/vnd.geogebra.tool",
    ".ghf": "application/vnd.groove-help",
    ".gif": "image/gif",
    ".gim": "application/vnd.groove-identity-message",
    ".gmx": "application/vnd.gmx",
    ".gnumeric": "application/x-gnumeric",
    ".gph": "application/vnd.flographit",
    ".gqf": "application/vnd.grafeq",
    ".gqs": "application/vnd.grafeq",
    ".gram": "application/srgs",
    ".gre": "application/vnd.geometry-explorer",
    ".grv": "application/vnd.groove-injector",
    ".grxml": "application/srgs+xml",
    ".gsf": "application/x-font-ghostscript",
    ".gtar": "application/x-gtar",
    ".gtm": "application/vnd.groove-tool-message",
    ".gtw": "model/vnd.gtw",
    ".gv": "text/vnd.graphviz",
    ".gz": "application/x-gzip",
    ".h": "text/x-c",
    ".h261": "video/h261",
    ".h263": "video/h263",
    ".h264": "video/h264",
    ".hbci": "application/vnd.hbci",
    ".hdf": "application/x-hdf",
    ".hh": "text/x-c",
    ".hlp": "application/winhlp",
    ".hpgl": "application/vnd.hp-hpgl",
    ".hpid": "application/vnd.hp-hpid",
    ".hps": "application/vnd.hp-hps",
    ".hqx": "application/mac-binhex40",
    ".htke": "application/vnd.kenameaapp",
    ".htm": "text/html",
    ".html": "text/html",
    ".hvd": "application/vnd.yamaha.hv-dic",
    ".hvp": "application/vnd.yamaha.hv-voice",
    ".hvs": "application/vnd.yamaha.hv-script",
    ".icc": "application/vnd.iccprofile",
    ".ice": "x-conference/x-cooltalk",
    ".icm": "application/vnd.iccprofile",
    ".ico": "image/x-icon",
    ".ics": "text/calendar",
    ".ief": "image/ief",
    ".ifb": "text/calendar",
    ".ifm": "application/vnd.shana.informed.formdata",
    ".iges": "model/iges",
    ".igl": "application/vnd.igloader",
    ".igs": "model/iges",
    ".igx": "application/vnd.micrografx.igx",
    ".iif": "application/vnd.shana.informed.interchange",
    ".imp": "application/vnd.accpac.simply.imp",
    ".ims": "application/vnd.ms-ims",
    ".in": "text/plain",
    ".ipk": "application/vnd.shana.informed.package",
    ".irm": "application/vnd.ibm.rights-management",
    ".irp": "application/vnd.irepository.package+xml",
    ".iso": "application/octet-stream",
    ".itp": "application/vnd.shana.informed.formtemplate",
    ".ivp": "application/vnd.immervision-ivp",
    ".ivu": "application/vnd.immervision-ivu",
    ".jad": "text/vnd.sun.j2me.app-descriptor",
    ".jam": "application/vnd.jam",
    ".jar": "application/java-archive",
    ".java": "text/x-java-source",
    ".jisp": "application/vnd.jisp",
    ".jlt": "application/vnd.hp-jlyt",
    ".jnlp": "application/x-java-jnlp-file",
    ".joda": "application/vnd.joost.joda-archive",
    ".jpe": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".jpg": "image/jpeg",
    ".jpgm": "video/jpm",
    ".jpgv": "video/jpeg",
    ".jpm": "video/jpm",
    ".js": "application/javascript",
    ".json": "application/json",
    ".kar": "audio/midi",
    ".karbon": "application/vnd.kde.karbon",
    ".kfo": "application/vnd.kde.kformula",
    ".kia": "application/vnd.kidspiration",
    ".kil": "application/x-killustrator",
    ".kml": "application/vnd.google-earth.kml+xml",
    ".kmz": "application/vnd.google-earth.kmz",
    ".kne": "application/vnd.kinar",
    ".knp": "application/vnd.kinar",
    ".kon": "application/vnd.kde.kontour",
    ".kpr": "application/vnd.kde.kpresenter",
    ".kpt": "application/vnd.kde.kpresenter",
    ".ksh": "text/plain",
    ".ksp": "application/vnd.kde.kspread",
    ".ktr": "application/vnd.kahootz",
    ".ktz": "application/vnd.kahootz",
    ".kwd": "application/vnd.kde.kword",
    ".kwt": "application/vnd.kde.kword",
    ".latex": "application/x-latex",
    ".lbd": "application/vnd.llamagraphics.life-balance.desktop",
    ".lbe": "application/vnd.llamagraphics.life-balance.exchange+xml",
    ".les": "application/vnd.hhe.lesson-player",
    ".lha": "application/octet-stream",
    ".link66": "application/vnd.route66.link66+xml",
    ".list": "text/plain",
    ".list3820": "application/vnd.ibm.modcap",
    ".listafp": "application/vnd.ibm.modcap",
    ".log": "text/plain",
    ".lostxml": "application/lost+xml",
    ".lrf": "application/octet-stream",
    ".lrm": "application/vnd.ms-lrm",
    ".ltf": "application/vnd.frogans.ltf",
    ".lvp": "audio/vnd.lucent.voice",
    ".lwp": "application/vnd.lotus-wordpro",
    ".lzh": "application/octet-stream",
    ".m13": "application/x-msmediaview",
    ".m14": "application/x-msmediaview",
    ".m1v": "video/mpeg",
    ".m2a": "audio/mpeg",
    ".m2v": "video/mpeg",
    ".m3a": "audio/mpeg",
    ".m3u": "audio/x-mpegurl",
    ".m4u": "video/vnd.mpegurl",
    ".m4v": "video/x-m4v",
    ".ma": "application/mathematica",
    ".mag": "application/vnd.ecowin.chart",
    ".maker": "application/vnd.framemaker",
    ".man": "text/troff",
    ".mathml": "application/mathml+xml",
    ".mb": "application/mathematica",
    ".mbk": "application/vnd.mobius.mbk",
    ".mbox": "application/mbox",
    ".mc1": "application/vnd.medcalcdata",
    ".mcd": "application/vnd.mcd",
    ".mcurl": "text/vnd.curl.mcurl",
    ".mdb": "application/x-msaccess",
    ".mdi": "image/vnd.ms-modi",
    ".me": "text/troff",
    ".mesh": "model/mesh",
    ".mfm": "application/vnd.mfmp",
    ".mgz": "application/vnd.proteus.magazine",
    ".mht": "message/rfc822",
    ".mhtml": "message/rfc822",
    ".mid": "audio/midi",
    ".midi": "audio/midi",
    ".mif": "application/vnd.mif",
    ".mime": "message/rfc822",
    ".mj2": "video/mj2",
    ".mjp2": "video/mj2",
    ".mlp": "application/vnd.dolby.mlp",
    ".mmd": "application/vnd.chipnuts.karaoke-mmd",
    ".mmf": "application/vnd.smaf",
    ".mmr": "image/vnd.fujixerox.edmics-mmr",
    ".mny": "application/x-msmoney",
    ".mobi": "application/x-mobipocket-ebook",
    ".mov": "video/quicktime",
    ".movie": "video/x-sgi-movie",
    ".mp2": "audio/mpeg",
    ".mp2a": "audio/mpeg",
    ".mp3": "audio/mpeg",
    ".mp4": "video/mp4",
    ".mp4a": "audio/mp4",
    ".mp4s": "application/mp4",
    ".mp4v": "video/mp4",
    ".mpa": "video/mpeg",
    ".mpc": "application/vnd.mophun.certificate",
    ".mpe": "video/mpeg",
    ".mpeg": "video/mpeg",
    ".mpg": "video/mpeg",
    ".mpg4": "video/mp4",
    ".mpga": "audio/mpeg",
    ".mpkg": "application/vnd.apple.installer+xml",
    ".mpm": "application/vnd.blueice.multipass",
    ".mpn": "application/vnd.mophun.application",
    ".mpp": "application/vnd.ms-project",
    ".mpt": "application/vnd.ms-project",
    ".mpy": "application/vnd.ibm.minipay",
    ".mqy": "application/vnd.mobius.mqy",
    ".mrc": "application/marc",
    ".ms": "text/troff",
    ".mscml": "application/mediaservercontrol+xml",
    ".mseed": "application/vnd.fdsn.mseed",
    ".mseq": "application/vnd.mseq",
    ".msf": "application/vnd.epson.msf",
    ".msh": "model/mesh",
    ".msi": "application/x-msdownload",
    ".msl": "application/vnd.mobius.msl",
    ".msty": "application/vnd.muvee.style",
    ".mts": "model/vnd.mts",
    ".mus": "application/vnd.musician",
    ".musicxml": "application/vnd.recordare.musicxml+xml",
    ".mvb": "application/x-msmediaview",
    ".mwf": "application/vnd.mfer",
    ".mxf": "application/mxf",
    ".mxl": "application/vnd.recordare.musicxml",
    ".mxml": "application/xv+xml",
    ".mxs": "application/vnd.triscape.mxs",
    ".mxu": "video/vnd.mpegurl",
    ".n-gage": "application/vnd.nokia.n-gage.symbian.install",
    ".nb": "application/mathematica",
    ".nc": "application/x-netcdf",
    ".ncx": "application/x-dtbncx+xml",
    ".ngdat": "application/vnd.nokia.n-gage.data",
    ".nlu": "application/vnd.neurolanguage.nlu",
    ".nml": "application/vnd.enliven",
    ".nnd": "application/vnd.noblenet-directory",
    ".nns": "application/vnd.noblenet-sealer",
    ".nnw": "application/vnd.noblenet-web",
    ".npx": "image/vnd.net-fpx",
    ".nsf": "application/vnd.lotus-notes",
    ".nws": "message/rfc822",
    ".o": "application/octet-stream",
    ".oa2": "application/vnd.fujitsu.oasys2",
    ".oa3": "application/vnd.fujitsu.oasys3",
    ".oas": "application/vnd.fujitsu.oasys",
    ".obd": "application/x-msbinder",
    ".obj": "application/octet-stream",
    ".oda": "application/oda",
    ".odb": "application/vnd.oasis.opendocument.database",
    ".odc": "application/vnd.oasis.opendocument.chart",
    ".odf": "application/vnd.oasis.opendocument.formula",
    ".odft": "application/vnd.oasis.opendocument.formula-template",
    ".odg": "application/vnd.oasis.opendocument.graphics",
    ".odi": "application/vnd.oasis.opendocument.image",
    ".odp": "application/vnd.oasis.opendocument.presentation",
    ".ods": "application/vnd.oasis.opendocument.spreadsheet",
    ".odt": "application/vnd.oasis.opendocument.text",
    ".oga": "audio/ogg",
    ".ogg": "audio/ogg",
    ".ogv": "video/ogg",
    ".ogx": "application/ogg",
    ".onepkg": "application/onenote",
    ".onetmp": "application/onenote",
    ".onetoc": "application/onenote",
    ".onetoc2": "application/onenote",
    ".opf": "application/oebps-package+xml",
    ".oprc": "application/vnd.palm",
    ".org": "application/vnd.lotus-organizer",
    ".osf": "application/vnd.yamaha.openscoreformat",
    ".osfpvg": "application/vnd.yamaha.openscoreformat.osfpvg+xml",
    ".otc": "application/vnd.oasis.opendocument.chart-template",
    ".otf": "application/x-font-otf",
    ".otg": "application/vnd.oasis.opendocument.graphics-template",
    ".oth": "application/vnd.oasis.opendocument.text-web",
    ".oti": "application/vnd.oasis.opendocument.image-template",
    ".otm": "application/vnd.oasis.opendocument.text-master",
    ".otp": "application/vnd.oasis.opendocument.presentation-template",
    ".ots": "application/vnd.oasis.opendocument.spreadsheet-template",
    ".ott": "application/vnd.oasis.opendocument.text-template",
    ".oxt": "application/vnd.openofficeorg.extension",
    ".p": "text/x-pascal",
    ".p10": "application/pkcs10",
    ".p12": "application/x-pkcs12",
    ".p7b": "application/x-pkcs7-certificates",
    ".p7c": "application/pkcs7-mime",
    ".p7m": "application/pkcs7-mime",
    ".p7r": "application/x-pkcs7-certreqresp",
    ".p7s": "application/pkcs7-signature",
    ".pas": "text/x-pascal",
    ".pbd": "application/vnd.powerbuilder6",
    ".pbm": "image/x-portable-bitmap",
    ".pcf": "application/x-font-pcf",
    ".pcl": "application/vnd.hp-pcl",
    ".pclxl": "application/vnd.hp-pclxl",
    ".pct": "image/x-pict",
    ".pcurl": "application/vnd.curl.pcurl",
    ".pcx": "image/x-pcx",
    ".pdb": "application/vnd.palm",
    ".pdf": "application/pdf",
    ".pfa": "application/x-font-type1",
    ".pfb": "application/x-font-type1",
    ".pfm": "application/x-font-type1",
    ".pfr": "application/font-tdpfr",
    ".pfx": "application/x-pkcs12",
    ".pgm": "image/x-portable-graymap",
    ".pgn": "application/x-chess-pgn",
    ".pgp": "application/pgp-encrypted",
    ".pic": "image/x-pict",
    ".pkg": "application/octet-stream",
    ".pki": "application/pkixcmp",
    ".pkipath": "application/pkix-pkipath",
    ".pl": "text/plain",
    ".plb": "application/vnd.3gpp.pic-bw-large",
    ".plc": "application/vnd.mobius.plc",
    ".plf": "application/vnd.pocketlearn",
    ".pls": "application/pls+xml",
    ".pml": "application/vnd.ctc-posml",
    ".png": "image/png",
    ".pnm": "image/x-portable-anymap",
    ".portpkg": "application/vnd.macports.portpkg",
    ".pot": "application/vnd.ms-powerpoint",
    ".potm": "application/vnd.ms-powerpoint.template.macroenabled.12",
    ".potx": "application/vnd.openxmlformats-officedocument.presentationml.template",
    ".ppa": "application/vnd.ms-powerpoint",
    ".ppam": "application/vnd.ms-powerpoint.addin.macroenabled.12",
    ".ppd": "application/vnd.cups-ppd",
    ".ppm": "image/x-portable-pixmap",
    ".pps": "application/vnd.ms-powerpoint",
    ".ppsm": "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    ".ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    ".ppt": "application/vnd.ms-powerpoint",
    ".pptm": "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ".pqa": "application/vnd.palm",
    ".prc": "application/x-mobipocket-ebook",
    ".pre": "application/vnd.lotus-freelance",
    ".prf": "application/pics-rules",
    ".ps": "application/postscript",
    ".psb": "application/vnd.3gpp.pic-bw-small",
    ".psd": "image/vnd.adobe.photoshop",
    ".psf": "application/x-font-linux-psf",
    ".ptid": "application/vnd.pvi.ptid1",
    ".pub": "application/x-mspublisher",
    ".pvb": "application/vnd.3gpp.pic-bw-var",
    ".pwn": "application/vnd.3m.post-it-notes",
    ".pwz": "application/vnd.ms-powerpoint",
    ".py": "text/x-python",
    ".pya": "audio/vnd.ms-playready.media.pya",
    ".pyc": "application/x-python-code",
    ".pyo": "application/x-python-code",
    ".pyv": "video/vnd.ms-playready.media.pyv",
    ".qam": "application/vnd.epson.quickanime",
    ".qbo": "application/vnd.intu.qbo",
    ".qfx": "application/vnd.intu.qfx",
    ".qps": "application/vnd.publishare-delta-tree",
    ".qt": "video/quicktime",
    ".qwd": "application/vnd.quark.quarkxpress",
    ".qwt": "application/vnd.quark.quarkxpress",
    ".qxb": "application/vnd.quark.quarkxpress",
    ".qxd": "application/vnd.quark.quarkxpress",
    ".qxl": "application/vnd.quark.quarkxpress",
    ".qxt": "application/vnd.quark.quarkxpress",
    ".ra": "audio/x-pn-realaudio",
    ".ram": "audio/x-pn-realaudio",
    ".rar": "application/x-rar-compressed",
    ".ras": "image/x-cmu-raster",
    ".rcprofile": "application/vnd.ipunplugged.rcprofile",
    ".rdf": "application/rdf+xml",
    ".rdz": "application/vnd.data-vision.rdz",
    ".rep": "application/vnd.businessobjects",
    ".res": "application/x-dtbresource+xml",
    ".rgb": "image/x-rgb",
    ".rif": "application/reginfo+xml",
    ".rl": "application/resource-lists+xml",
    ".rlc": "image/vnd.fujixerox.edmics-rlc",
    ".rld": "application/resource-lists-diff+xml",
    ".rm": "application/vnd.rn-realmedia",
    ".rmi": "audio/midi",
    ".rmp": "audio/x-pn-realaudio-plugin",
    ".rms": "application/vnd.jcp.javame.midlet-rms",
    ".rnc": "application/relax-ng-compact-syntax",
    ".roff": "text/troff",
    ".rpm": "application/x-rpm",
    ".rpss": "application/vnd.nokia.radio-presets",
    ".rpst": "application/vnd.nokia.radio-preset",
    ".rq": "application/sparql-query",
    ".rs": "application/rls-services+xml",
    ".rsd": "application/rsd+xml",
    ".rss": "application/rss+xml",
    ".rtf": "application/rtf",
    ".rtx": "text/richtext",
    ".s": "text/x-asm",
    ".saf": "application/vnd.yamaha.smaf-audio",
    ".sbml": "application/sbml+xml",
    ".sc": "application/vnd.ibm.secure-container",
    ".scd": "application/x-msschedule",
    ".scm": "application/vnd.lotus-screencam",
    ".scq": "application/scvp-cv-request",
    ".scs": "application/scvp-cv-response",
    ".scurl": "text/vnd.curl.scurl",
    ".sda": "application/vnd.stardivision.draw",
    ".sdc": "application/vnd.stardivision.calc",
    ".sdd": "application/vnd.stardivision.impress",
    ".sdkd": "application/vnd.solent.sdkm+xml",
    ".sdkm": "application/vnd.solent.sdkm+xml",
    ".sdp": "application/sdp",
    ".sdw": "application/vnd.stardivision.writer",
    ".see": "application/vnd.seemail",
    ".seed": "application/vnd.fdsn.seed",
    ".sema": "application/vnd.sema",
    ".semd": "application/vnd.semd",
    ".semf": "application/vnd.semf",
    ".ser": "application/java-serialized-object",
    ".setpay": "application/set-payment-initiation",
    ".setreg": "application/set-registration-initiation",
    ".sfd-hdstx": "application/vnd.hydrostatix.sof-data",
    ".sfs": "application/vnd.spotfire.sfs",
    ".sgl": "application/vnd.stardivision.writer-global",
    ".sgm": "text/sgml",
    ".sgml": "text/sgml",
    ".sh": "application/x-sh",
    ".shar": "application/x-shar",
    ".shf": "application/shf+xml",
    ".si": "text/vnd.wap.si",
    ".sic": "application/vnd.wap.sic",
    ".sig": "application/pgp-signature",
    ".silo": "model/mesh",
    ".sis": "application/vnd.symbian.install",
    ".sisx": "application/vnd.symbian.install",
    ".sit": "application/x-stuffit",
    ".sitx": "application/x-stuffitx",
    ".skd": "application/vnd.koan",
    ".skm": "application/vnd.koan",
    ".skp": "application/vnd.koan",
    ".skt": "application/vnd.koan",
    ".sl": "text/vnd.wap.sl",
    ".slc": "application/vnd.wap.slc",
    ".sldm": "application/vnd.ms-powerpoint.slide.macroenabled.12",
    ".sldx": "application/vnd.openxmlformats-officedocument.presentationml.slide",
    ".slt": "application/vnd.epson.salt",
    ".smf": "application/vnd.stardivision.math",
    ".smi": "application/smil+xml",
    ".smil": "application/smil+xml",
    ".snd": "audio/basic",
    ".snf": "application/x-font-snf",
    ".so": "application/octet-stream",
    ".spc": "application/x-pkcs7-certificates",
    ".spf": "application/vnd.yamaha.smaf-phrase",
    ".spl": "application/x-futuresplash",
    ".spot": "text/vnd.in3d.spot",
    ".spp": "application/scvp-vp-response",
    ".spq": "application/scvp-vp-request",
    ".spx": "audio/ogg",
    ".src": "application/x-wais-source",
    ".srx": "application/sparql-results+xml",
    ".sse": "application/vnd.kodak-descriptor",
    ".ssf": "application/vnd.epson.ssf",
    ".ssml": "application/ssml+xml",
    ".stc": "application/vnd.sun.xml.calc.template",
    ".std": "application/vnd.sun.xml.draw.template",
    ".stf": "application/vnd.wt.stf",
    ".sti": "application/vnd.sun.xml.impress.template",
    ".stk": "application/hyperstudio",
    ".stl": "application/vnd.ms-pki.stl",
    ".str": "application/vnd.pg.format",
    ".stw": "application/vnd.sun.xml.writer.template",
    ".sus": "application/vnd.sus-calendar",
    ".susp": "application/vnd.sus-calendar",
    ".sv4cpio": "application/x-sv4cpio",
    ".sv4crc": "application/x-sv4crc",
    ".svd": "application/vnd.svd",
    ".svg": "image/svg+xml",
    ".svgz": "image/svg+xml",
    ".swa": "application/x-director",
    ".swf": "application/x-shockwave-flash",
    ".swi": "application/vnd.arastra.swi",
    ".sxc": "application/vnd.sun.xml.calc",
    ".sxd": "application/vnd.sun.xml.draw",
    ".sxg": "application/vnd.sun.xml.writer.global",
    ".sxi": "application/vnd.sun.xml.impress",
    ".sxm": "application/vnd.sun.xml.math",
    ".sxw": "application/vnd.sun.xml.writer",
    ".t": "text/troff",
    ".tao": "application/vnd.tao.intent-module-archive",
    ".tar": "application/x-tar",
    ".tcap": "application/vnd.3gpp2.tcap",
    ".tcl": "application/x-tcl",
    ".teacher": "application/vnd.smart.teacher",
    ".tex": "application/x-tex",
    ".texi": "application/x-texinfo",
    ".texinfo": "application/x-texinfo",
    ".text": "text/plain",
    ".tfm": "application/x-tex-tfm",
    ".tgz": "application/x-gzip",
    ".tif": "image/tiff",
    ".tiff": "image/tiff",
    ".tmo": "application/vnd.tmobile-livetv",
    ".torrent": "application/x-bittorrent",
    ".tpl": "application/vnd.groove-tool-template",
    ".tpt": "application/vnd.trid.tpt",
    ".tr": "text/troff",
    ".tra": "application/vnd.trueapp",
    ".trm": "application/x-msterminal",
    ".tsv": "text/tab-separated-values",
    ".ttc": "application/x-font-ttf",
    ".ttf": "application/x-font-ttf",
    ".twd": "application/vnd.simtech-mindmapper",
    ".twds": "application/vnd.simtech-mindmapper",
    ".txd": "application/vnd.genomatix.tuxedo",
    ".txf": "application/vnd.mobius.txf",
    ".txt": "text/plain",
    ".u32": "application/x-authorware-bin",
    ".udeb": "application/x-debian-package",
    ".ufd": "application/vnd.ufdl",
    ".ufdl": "application/vnd.ufdl",
    ".umj": "application/vnd.umajin",
    ".unityweb": "application/vnd.unity",
    ".uoml": "application/vnd.uoml+xml",
    ".uri": "text/uri-list",
    ".uris": "text/uri-list",
    ".urls": "text/uri-list",
    ".ustar": "application/x-ustar",
    ".utz": "application/vnd.uiq.theme",
    ".uu": "text/x-uuencode",
    ".vcd": "application/x-cdlink",
    ".vcf": "text/x-vcard",
    ".vcg": "application/vnd.groove-vcard",
    ".vcs": "text/x-vcalendar",
    ".vcx": "application/vnd.vcx",
    ".vis": "application/vnd.visionary",
    ".viv": "video/vnd.vivo",
    ".vor": "application/vnd.stardivision.writer",
    ".vox": "application/x-authorware-bin",
    ".vrml": "model/vrml",
    ".vsd": "application/vnd.visio",
    ".vsf": "application/vnd.vsf",
    ".vss": "application/vnd.visio",
    ".vst": "application/vnd.visio",
    ".vsw": "application/vnd.visio",
    ".vtu": "model/vnd.vtu",
    ".vxml": "application/voicexml+xml",
    ".w3d": "application/x-director",
    ".wad": "application/x-doom",
    ".wav": "audio/x-wav",
    ".wax": "audio/x-ms-wax",
    ".wbmp": "image/vnd.wap.wbmp",
    ".wbs": "application/vnd.criticaltools.wbs+xml",
    ".wbxml": "application/vnd.wap.wbxml",
    ".wcm": "application/vnd.ms-works",
    ".wdb": "application/vnd.ms-works",
    ".wiz": "application/msword",
    ".wks": "application/vnd.ms-works",
    ".wm": "video/x-ms-wm",
    ".wma": "audio/x-ms-wma",
    ".wmd": "application/x-ms-wmd",
    ".wmf": "application/x-msmetafile",
    ".wml": "text/vnd.wap.wml",
    ".wmlc": "application/vnd.wap.wmlc",
    ".wmls": "text/vnd.wap.wmlscript",
    ".wmlsc": "application/vnd.wap.wmlscriptc",
    ".wmv": "video/x-ms-wmv",
    ".wmx": "video/x-ms-wmx",
    ".wmz": "application/x-ms-wmz",
    ".wpd": "application/vnd.wordperfect",
    ".wpl": "application/vnd.ms-wpl",
    ".wps": "application/vnd.ms-works",
    ".wqd": "application/vnd.wqd",
    ".wri": "application/x-mswrite",
    ".wrl": "model/vrml",
    ".wsdl": "application/wsdl+xml",
    ".wspolicy": "application/wspolicy+xml",
    ".wtb": "application/vnd.webturbo",
    ".wvx": "video/x-ms-wvx",
    ".x32": "application/x-authorware-bin",
    ".x3d": "application/vnd.hzn-3d-crossword",
    ".xap": "application/x-silverlight-app",
    ".xar": "application/vnd.xara",
    ".xbap": "application/x-ms-xbap",
    ".xbd": "application/vnd.fujixerox.docuworks.binder",
    ".xbm": "image/x-xbitmap",
    ".xdm": "application/vnd.syncml.dm+xml",
    ".xdp": "application/vnd.adobe.xdp+xml",
    ".xdw": "application/vnd.fujixerox.docuworks",
    ".xenc": "application/xenc+xml",
    ".xer": "application/patch-ops-error+xml",
    ".xfdf": "application/vnd.adobe.xfdf",
    ".xfdl": "application/vnd.xfdl",
    ".xht": "application/xhtml+xml",
    ".xhtml": "application/xhtml+xml",
    ".xhvml": "application/xv+xml",
    ".xif": "image/vnd.xiff",
    ".xla": "application/vnd.ms-excel",
    ".xlam": "application/vnd.ms-excel.addin.macroenabled.12",
    ".xlb": "application/vnd.ms-excel",
    ".xlc": "application/vnd.ms-excel",
    ".xlm": "application/vnd.ms-excel",
    ".xls": "application/vnd.ms-excel",
    ".xlsb": "application/vnd.ms-excel.sheet.binary.macroenabled.12",
    ".xlsm": "application/vnd.ms-excel.sheet.macroenabled.12",
    ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".xlt": "application/vnd.ms-excel",
    ".xltm": "application/vnd.ms-excel.template.macroenabled.12",
    ".xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    ".xlw": "application/vnd.ms-excel",
    ".xml": "application/xml",
    ".xo": "application/vnd.olpc-sugar",
    ".xop": "application/xop+xml",
    ".xpdl": "application/xml",
    ".xpi": "application/x-xpinstall",
    ".xpm": "image/x-xpixmap",
    ".xpr": "application/vnd.is-xpr",
    ".xps": "application/vnd.ms-xpsdocument",
    ".xpw": "application/vnd.intercon.formnet",
    ".xpx": "application/vnd.intercon.formnet",
    ".xsl": "application/xml",
    ".xslt": "application/xslt+xml",
    ".xsm": "application/vnd.syncml+xml",
    ".xspf": "application/xspf+xml",
    ".xul": "application/vnd.mozilla.xul+xml",
    ".xvm": "application/xv+xml",
    ".xvml": "application/xv+xml",
    ".xwd": "image/x-xwindowdump",
    ".xyz": "chemical/x-xyz",
    ".zaz": "application/vnd.zzazz.deck+xml",
    ".zip": "application/zip",
    ".zir": "application/vnd.zul",
    ".zirz": "application/vnd.zul",
    ".zmm": "application/vnd.handheld-entertainment+xml"
  };

  /**
   Returns the mime type corresponding to the given file name's extension

   @param {String}                   fileName Name of the file
   */
  CUI.FileUpload.MimeTypes.getMimeTypeFromFileName = function (fileName) {
    var fileExtensionMatch = fileName.match(/.+(\..+)/);

    return (fileExtensionMatch ?
      CUI.FileUpload.MimeTypes[fileExtensionMatch[1]] :
      undefined);
  };
}(window.jQuery));

(function ($) {
  CUI.NumberInput = new Class(/** @lends CUI.NumberInput# */{
    toString: 'NumberInput',
    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc A number input widget with increment and decrement buttons.

     @desc Creates a Number Input object
     @constructs
     @param {Object} options Component options
     @param {numberic} [options.min=NaN] (Optional) Minimum value allowed for input.
     @param {numberic} [options.max=NaN] (Optional) Maximum value allowed for input.
     @param {numberic} [options.step=1] Amount increment/decrement for input.
     @param {numberic} [options.defaultValue=0] Fallback value in case the input is empty at the beginning.
     @param {boolean} [options.hasError=false] Set the error state of the widget.
     @param {boolean} [options.disabled=false] Set the disabled state of the widget.
     */

    construct: function (options) {

      this._initMarkup();
      this._setListeners();
      this._setAttributes();
      this._makeAccessible();

    },

    defaults: {
      defaultValue: 0,
      max: null,
      min: null,
      step: 1,
      hasError: false,
      disabled: false
    },

    /**
     Increments value by step amount
     */
    increment: function () {
      if (this._isNumber()) {
        var value = this.getValue(),
            precision = this._getPrecision();
        value += this.getStep();
        value = value > this.getMax() ? this.getMax() : value;
        if (precision > 0) {
          value = parseFloat(value.toFixed(precision));
        }
        this.setValue(value);
      }
    },

    /**
     Decrements value by step amount
     */
    decrement: function () {
      if (this._isNumber()) {
        var value = this.getValue(),
            precision = this._getPrecision();
        value -= this.getStep();
        value = value < this.getMin() ? this.getMin() : value;
        if (precision > 0) {
          value = parseFloat(value.toFixed(precision));
        }
        this.setValue(value);
      }
    },

    /**
     Sets the value, which triggers the change event.  Note that value will be
     limited to the range defined by the min and max properties.
     @param value {numberic} The input value to set.
     */
    setValue: function (value) {
      this.$input.val(value);
      this.$input.trigger('change');
    },

    /**
     Sets the minimum value allowed.
     @param value {numberic} The min value to set.
     */
    setMin: function (value) {
      this.set('min', value);
      if (this.$input.attr('aria-valuemin')) {
        this.$input.attr('aria-valuemin', this.options.min); //a11y
      }

      this.$input.attr('min', this.options.min);
    },

    /**
     Sets the maximum value allowed.
     @param value {numberic} The max value to set.
     */
    setMax: function (value) {
      this.set('max', value);
      if (this.$input.attr('aria-valuemax')) {
        this.$input.attr('aria-valuemax', this.options.max); //a11y
      }

      this.$input.attr('max', this.options.max);
    },


    /**
     Sets the step value for increment and decrement.
     @param value {numberic} The step value to set.
     */
    setStep: function (value) {
      this.set('step', value);

      if (this.options.step !== 1 && this.$input.attr('step') !== this.options.step) {
        this.$input.attr('step', this.options.step);
      }
    },

    /**
     Attempts to return parseFloat for value.
     Does not attempt to parse null, undefined, or empty string.
     @return The current input value.
     */
    getValue: function () {
      var result = this.$input.val();
      if (typeof result == 'undefined' ||
        result == null ||
        result.length < 1) {
        result = '';
      } else {
        result = parseFloat(result);
      }
      return result;
    },

    /**
     @return The minimum input value allowed.
     */
    getMin: function () {
      return parseFloat(this.options.min);
    },

    /**
     @return The maximum input value allowed.
     */
    getMax: function () {
      return parseFloat(this.options.max);
    },

    /**
     @return The current increment/decrement step amount .
     */
    getStep: function () {
      return parseFloat(this.options.step);
    },

    /** @ignore */
    _initMarkup: function () {
      this.$element.addClass('coral-NumberInput');

      // get the input, and correct the input type depending on the platform
      this.$input = this.$element.find('.js-coral-NumberInput-input');
      this._switchInputType(this.$input);

      this.$decrementElement = this.$element.find('.js-coral-NumberInput-decrementButton');
      this.$incrementElement = this.$element.find('.js-coral-NumberInput-incrementButton');

      this.$liveRegion = $('<span/>')
        .addClass('u-coral-screenReaderOnly')
        .attr({
               'aria-live': 'assertive'
              }).insertAfter(this.$input);
    },

    /** @ignore */
    _liveRegionTimeout: null,
    /** @ignore */
    _clearLiveRegionTimeout: null,
    /** @ignore */
    _updateLiveRegion: function (value) {
      var self = this,
          val = value;

      clearTimeout(this._liveRegionTimeout);
      clearTimeout(this._clearLiveRegionTimeout);

      if (val === undefined || val.length === 0) {
        this.$liveRegion.text('');
      } else {
        this._liveRegionTimeout = setTimeout(function () {
          self.$liveRegion.text(val);
          self._clearLiveRegionTimeout = setTimeout(function () {
            self.$liveRegion.text('');
          }, 2000);
        }, 200);
      }
    },

    /** @ignore */
    _setListeners: function () {
      this.$input.on('change.cui-numberinput', this._changeHandler.bind(this));

      this.on('beforeChange:step', this._optionBeforeChangeHandler.bind(this));

      this.on('beforeChange:min', this._optionBeforeChangeHandler.bind(this));

      this.on('beforeChange:max', this._optionBeforeChangeHandler.bind(this));

      this.on('change:disabled', this._toggleDisabled.bind(this));

      this.on('change:hasError', this._toggleError.bind(this));

      this.on('click.cui-numberinput', 'button', this._clickIncrementOrDecrement.bind(this));

      this.on('keydown.cui-numberinput', 'input, button', this._keyDown.bind(this))
        .on('focusin.cui-numberinput', 'input, button', this._focusIn.bind(this))
        .on('focusout.cui-numberinput', 'input, button', this._focusOut.bind(this));
    },

    /** @ignore */
    _setAttributes: function () {

      if (this.$input.attr('max')) {
        this.setMax(this.$input.attr('max'));
      } else if ($.isNumeric(this.options.max)) {
        this.setMax(this.options.max);
      }

      if (this.$input.attr('min')) {
        this.setMin(this.$input.attr('min'));
      } else if ($.isNumeric(this.options.min)) {
        this.setMin(this.options.min);
      }

      if (this.$element.attr("error")) {
        this.options.hasError = true;
      }

      this.setStep(this.$input.attr('step') || this.options.step);

      this.setValue(this.$input.val() !== '' ? this.$input.val() : this.options.defaultValue);

      if (this.$element.attr('disabled') || this.$element.attr('data-disabled')) {
        this._toggleDisabled();
      }

      if (this.$element.hasClass('is-invalid') || this.$element.attr('data-error')) {
        this.set('hasError', true);
      }
    },

    /** @ignore */
    _makeAccessible: function () {
      var valueNow = this.getValue(),
          input = this.$input.get(0),
          useAriaSpinbuttonRole = input.type === 'text';

      // Determine if input[type=number] is fully supported;
      // if not, implement the WAI-ARIA design pattern for a spinbutton.
      if (!useAriaSpinbuttonRole) {
        if (typeof input.stepUp === 'function') {
          try {
            // IE10-11 triggers an INVALID_STATE_ERR
            // when the stepUp or stepDown method is called.
            input.stepUp();
            input.value = valueNow;
          } catch (err) {
            // If an error is caught,
            // implement the WAI-ARIA 'spinbutton' design pattern.
            useAriaSpinbuttonRole = true;
          }
        } else {
          useAriaSpinbuttonRole = true;
        }
      }

      if (useAriaSpinbuttonRole) {
        this.$input.attr({
          'role': 'spinbutton',
          'aria-valuenow': valueNow,
          'aria-valuetext': valueNow,
          'aria-valuemax': this.options.max,
          'aria-valuemin': this.options.min
        });
      }

      this.$incrementElement.add(this.$decrementElement)
        .attr('tabindex', -1)
        .filter('[title]:not([aria-label])')
        .each(function (i, button) {
          var $button = $(button);
          if ($.trim($button.text()).length === 0) {
            $button.append('<span class="u-coral-screenReaderOnly">' + $button.attr('title') + '</span>');
          }
        });
    },

    /** @ignore */
    _changeHandler: function (event) {
        var isSpinbutton = this.$input.is('[role="spinbutton"]');
        this._checkMinMaxViolation();
        this._adjustValueLimitedToRange();
        this._checkValidity();

        var valueNow = this.getValue();

        this.$input.attr({
          'aria-valuenow': isSpinbutton ? valueNow : null,
          'aria-valuetext': valueNow
        });  //a11y

        if (isSpinbutton && this.$input.is(':focus')) {
          this._updateLiveRegion('');
        } else {
          this._updateLiveRegion(valueNow);
        }
      },

    /** @ignore */
    _keyDown: function (event) {
      var incrementOrDecrement,
          focusInput = false,
          captureEvent = false;
      switch (event.which) {
        case 33: // pageup
        case 38: // up
          incrementOrDecrement = this.increment;
          focusInput = true;
          captureEvent = true;
          break;
        case 34: // pagedown
        case 40: // down
          incrementOrDecrement = this.decrement;
          focusInput = true;
          captureEvent = true;
          break;
        case 35: // end
          if (this.options.max !== null) {
            this.setValue(this.options.max);
          }
          focusInput = true;
          captureEvent = true;
          break;
        case 36: // home
          if (this.options.min !== null) {
            this.setValue(this.options.min);
          }
          focusInput = true;
          captureEvent = true;
          break;
      }

      if (captureEvent) {
        event.preventDefault(); //Prevents change in caret position
        event.stopImmediatePropagation();
      }

      if (incrementOrDecrement) {
        incrementOrDecrement.call(this);
      }

      // Set focus to input
      if (focusInput &&  !this.$input.is(document.activeElement)) {
        this.$input.trigger('focus');
      }
    },

    /** @ignore */
    _focusIn: function (event) {
      this.$element.addClass('is-focused');
    },

    /** @ignore */
    _focusOut: function (event) {
      this.$element.removeClass('is-focused');
      this._updateLiveRegion('');
    },

    /** @ignore */
    _clickIncrementOrDecrement: function (event) {
      var incrementOrDecrement,
          $currentTarget = $(event.currentTarget);
      if ($currentTarget.is(this.$incrementElement)) {
        incrementOrDecrement = this.increment;
      } else if ($currentTarget.is(this.$decrementElement)) {
        incrementOrDecrement = this.decrement;
      }
      if (incrementOrDecrement) {
        if (!$currentTarget.is(document.activeElement)) {
          $currentTarget.trigger('focus');
        }
        incrementOrDecrement.call(this);
      }
    },

    /** @ignore */
    _adjustValueLimitedToRange: function () {
      var value = this.getValue(),
          precision = this._getPrecision();

      if (!isNaN(value)) {
        if (value > this.getMax()) {
          value = this.getMax();
        } else if (value < this.getMin()) {
          value = this.getMin();
        }
        if (precision > 0) {
          value = parseFloat(value.toFixed(precision));
        }
      }
      this.$input.val(value);
    },

    /** @ignore */
    _checkMinMaxViolation: function () {
      var hasFocus = false;

      if (this._isNumber()) {
        this.$incrementElement.removeAttr('disabled');
        this.$decrementElement.removeAttr('disabled');

        if (this.options.max !== null && this.getValue() >= this.getMax()) {
          hasFocus = this.$incrementElement.is(document.activeElement);
          this.$incrementElement.attr('disabled', 'disabled');
        } else if (this.options.min !== null && this.getValue() <= this.getMin()) {
          hasFocus = this.$decrementElement.is(document.activeElement);
          this.$decrementElement.attr('disabled', 'disabled');
        }

        if (hasFocus) {
          this.$input.trigger('focus');
        }
      }
    },

    _checkValidity: function() {
      if (this.$input.val() === '' && this.options.defaultValue !== null) {
        this.set('hasError', false);
      } else {
        this.set('hasError', this.getValue() !== this._getSnappedValue());
      }
    },

    /** @ignore */
    _getSnappedValue:function(value) {
      var rawValue = value === undefined ? this.getValue() : value,
          snappedValue = rawValue,
          min = this.getMin(),
          max = this.getMax(),
          step = this.getStep(),
          remainder,
          precision = this._getPrecision();

      remainder = ((rawValue - (isNaN(min) ? 0 : min)) % step);

      if (Math.abs(remainder) * 2 >= step) {
        snappedValue = (rawValue - remainder) + step;
      } else {
        snappedValue = rawValue - remainder;
      }

      if (!isNaN(min) && !isNaN(max)) {
        if (snappedValue < min) {
          snappedValue = min;
        } else if (snappedValue > max) {
          snappedValue = min + Math.floor((max - min) / step) * step;
        }
      }

      // correct floating point behavior by rounding to step precision
      if (precision > 0) {
        snappedValue = parseFloat(snappedValue.toFixed(precision));
      }

      return snappedValue;
    },

    /** @ignore */
    _getPrecision: function() {
      var value = this.getValue(),
          step = this.getStep(),
          regex = /^(?:-?\d+)(?:\.(\d+))?$/g,
          valuePrecision = value.toString().replace(regex, '$1').length,
          stepPrecision = step.toString().replace(regex, '$1').length;

      return valuePrecision > stepPrecision ? valuePrecision : stepPrecision;
    },

    /** @ignore */
    _switchInputType: function ($input) {
      var correctType = 'number';

      if ($input.get(0).type === correctType) return;

      $input
        .detach()
        .attr('type', correctType)
        .insertBefore(this.$element.children(':last'));
    },

    /** @ignore */
    _isNumber: function () {
      return !isNaN(this.$input.val());
    },

    /** @ignore */
    _optionBeforeChangeHandler: function (event) {
      if (isNaN(parseFloat(event.value))) {
        // console.error('CUI.NumberInput cannot set option \'' + event.option + '\' to NaN value');
        event.preventDefault();
      } else {
        this.$input.attr(event.option, event.value);
      }
    },

    /** @ignore */
    _toggleDisabled: function () {
      if (this.options.disabled) {
        this.$incrementElement.attr('disabled', 'disabled');
        this.$decrementElement.attr('disabled', 'disabled');
        this.$input.attr('disabled', 'disabled');
      } else {
        this.$incrementElement.removeAttr('disabled');
        this.$decrementElement.removeAttr('disabled');
        this.$input.removeAttr('disabled');
      }
    },

    /** @ignore */
    _toggleError: function () {
      if (this.options.hasError) {
        this.$element.addClass('is-invalid');
        this.$input.addClass('is-invalid').attr('aria-invalid', true);
      } else {
        this.$element.removeClass('is-invalid');
        this.$input.removeClass('is-invalid').removeAttr('aria-invalid');
      }
    }
  });

  CUI.Widget.registry.register("numberinput", CUI.NumberInput);

  // Data API
  $(document).on("cui-contentloaded.data-api", function (e) {
    CUI.NumberInput.init($("[data-init~=numberinput]", e.target));
  });

}(window.jQuery));

(function($) {
  var uuid = 0;

  CUI.Popover = new Class(/** @lends CUI.Popover# */{
    toString: 'Popover',
    extend: CUI.Widget,
    /**
     @extends CUI.Widget
     @classdesc A box which points at an element or point.

     @desc Creates a new popover
     @constructs

     @param {Object} options                               Component options
     @param {Object} options.pointAt                       The element or coordinate to which the popover should point.
     A coordinate should be provided as an array where the first
     item is the X coordinate and the second item is a Y
     coordinate. The coordinate should be in the document
     coordinate space.
     @param {String} [options.content]                     Content of the popover (HTML).
     @param {String} [options.pointFrom=bottom]            The side of the target element or coordinate the popover
     @param {Object} [options.within=window]               Popover collision detection container
     should be pointing from. Possible values include
     <code>top</code>, <code>right</code>, <code>bottom</code>,
     or <code>left</code>.
     @param {boolean} [options.preventAutoHide=false]      When set to <code>false</code>, the popover will close when
     the user clicks outside the popover. When set to
     <code>true</code>, the popover will only close when the
     target element is clicked or <code>hide()</code> is
     manually called.
     @param {String} [options.alignFrom=left]              When set to left, the popover will be anchored to the left
     side of its offset parent (in other words, it will use the
     <code>left</code> CSS property). When set to right, the
     popover will be anchored to the right side of its offset
     parent (in other words, it will use the <code>right</code>
     CSS property). When the element the popover is pointing at
     is right-aligned, it can be useful to set the value to
     <code>right</code> so the popover will appear to stay
     attached to the element when the user resizes the window
     horizontally.

     */
    construct: function(options) {

      // listens to configuration changes
      this.$element.on('change:content', this._setContent.bind(this));
      this.$element.on('change:pointAt', this._position.bind(this));
      this.$element.on('change:pointFrom', this._position.bind(this));
      this.$element.on('change:alignFrom', this._position.bind(this));

      // main class of the component
      this.$element.addClass('coral-Popover');

      // checks if the content element exists
      if (this._getContentElement(this.$element).length === 0) {
        this._wrapContent(this.$element);
      }

      // gets the content element
      this._$content = this._getContentElement(this.$element);

      // adds the content if the current is blank.
      if(this._$content.html() === '') {
        this._setContent();
      }

      this._popoverOffsets();

      this.uuid = (uuid += 1);
      this.popoverId = this.$element.attr('id');

      this._makeAccessible();
    },

    defaults: {
      pointFrom: 'bottom',
      preventAutoHide: false,
      alignFrom: 'left',
      visible: false
    },

    _directions: [
      'top',
      'bottom',
      'right',
      'left'
    ],

    /**
     * Creates an object that contains the offsets of the popover on every direction.
     *
     * @private
     */
    _popoverOffsets: function() {

      this._popoverOffsets = {};

      // Cache the tail dimensions when the popover is on the left or right of the target.
      this._popoverOffsets.leftRight = {
        width: 5,
        height: 5
      };

      // While it's possible that the dimensions are different depending on whether it's left/right vs top/bottom,
      // it likely (and is currently) just a rotated version of the arrow. To reduce the cost of measuring, we'll
      // just invert the dimensions until more complex tails are introduced.
      this._popoverOffsets.topBottom = {
        width: 5,
        height: 5
      };
    },

    /**
     * Wrapps the content of the popover inside a
     * coral-Popover-content class.
     *
     * @ignore
     */
    _wrapContent: function(el) {
      el.wrapInner('<div class="coral-Popover-content"/>');
    },
    /** @ignore */
    _getContentElement: function(el) {
      return el.find('> .coral-Popover-content');
    },

    /**
     * Positions the popover (if visible). Leverages [jQueryUI's Position utility]{@link http://jqueryui.com/position}.
     *
     * @private
     */
    _position: function() {
      // Let's not use the cycles to position if the popover is not visible. When show() is called, the element will
      // run through positioning again.
      if (!this.options.visible || !this.options.pointAt) {
        return;
      }

      var $popover = this.$element,
        target = this.options.pointAt,
        pointFrom = this.options.pointFrom,
        tailDimensions = this._popoverOffsets,
        instructions;

      if ($.isArray(target)) {
        if (target.length !== 2) {
          return;
        }
        target = this._convertCoordsToEvent(target);
      }

      // Using the 'flip' collision option, jQueryUI's positioning logic will flip the position of the popover to
      // whichever side will expose most of the popover within the window viewport. However, this can sometimes place
      // the popover so that it is cropped by the top or left of the document. While it's great that the user would
      // be able to initially see more of the popover than if it had been placed in the opposite position, the user
      // would not be able to even scroll to see the cropped portion. We would rather show less of the popover and
      // still allow the user to scroll to see the rest of the popover. Here we detect if such cropping is taking
      // place and, if so, we re-run the positioning algorithm while forcing the position to the bottom or right
      // directions.
      // Fixes https://issues.adobe.com/browse/CUI-794
      var validateFinalPosition = function(position, feedback) {
        var offsetParentOffset = $popover.offsetParent().offset(),
          forcePointFrom;

        if ((pointFrom == 'top' || pointFrom == 'bottom') && offsetParentOffset.top + position.top < 0) {
          forcePointFrom = 'bottom';
        } else if ((pointFrom == 'left' || pointFrom == 'right') && offsetParentOffset.left + position.left < 0) {
          forcePointFrom = 'right';
        }

        if (forcePointFrom) {
          instructions = this._instructionFactory[forcePointFrom]({
            target: target,
            tailDimensions: tailDimensions,
            allowFlip: false,
            callback: this._applyFinalPosition.bind(this),
            within: this.options.within || window
          });
          $popover.position(instructions);
        } else {
          this._applyFinalPosition(position, feedback);
        }
      }.bind(this);

      instructions = this._instructionFactory[pointFrom]({
        target: target,
        tailDimensions: tailDimensions,
        allowFlip: true,
        callback: validateFinalPosition,
        within: this.options.within || window
      });

      $popover.position(instructions);
    },

    /**
     * Converts an array containing a coordinate into an event (needed for jQueryUI's Position utility)..
     * @param {Array} pointAt An array where the first item is the x coordinate and the second item is the y coordinate.
     * @returns {Object} A jquery event object with the pageX and pageY properties set.
     * @private
     */
    _convertCoordsToEvent: function(pointAt) {
      // If target is an array, it should contain x and y coords for absolute positioning.
      // Transform coords for jQueryUI Position which requires an event object with pageX and pageY.
      var event = $.Event();
      event.pageX = pointAt[0];
      event.pageY = pointAt[1];
      return event;
    },

    /**
     * Applies the final position to the popover (both bubble and tail).
     * @param position The position to be applied to the bubble.
     * @param feedback Additional information useful for positioning the tail.
     * @private
     */
    _applyFinalPosition: function(position, feedback) {
      var css = {
        top: position.top
      };

      if (this.options.alignFrom === 'right') {
        // Convert the "left" position to a "right" position.

        var offsetParent = this.$element.offsetParent();
        var offsetParentWidth;

        // If the offset parent is the root HTML element, we need to do some finagling. We really need to get the width
        // of the viewpane minus the scrollbar width since the "right" position will be relative to the left of the
        // scrollbar. We do this by getting the outerWidth(true) of body (so it includes any margin, border, and padding).
        if (offsetParent.prop('tagName').toLowerCase() == 'html') {
          offsetParent = $('body');
          offsetParentWidth = offsetParent.outerWidth(true);
        } else {
          offsetParentWidth = offsetParent.innerWidth();
        }

        css.left = 'auto';
        css.right = offsetParentWidth - position.left - this.$element.outerWidth(true);
      } else {
        css.left = position.left;
        css.right = 'auto';
      }

      this.$element.css(css);
    },

    /**
     * Factory for creating instruction objects to be used by jQuery's Position utility.
     * @private
     */
    _instructionFactory: {
      top: function(options) {
        return {
          my: 'left bottom-' + options.tailDimensions.topBottom.height,
          at: 'left top',
          of: options.target,
          collision: 'flipfit ' + (options.allowFlip ? 'flip' : 'none'),
          using: options.callback,
          within: options.within
        };
      },
      right: function(options) {
        return {
          my: 'left+' + options.tailDimensions.leftRight.width + ' top',
          at: 'right top',
          of: options.target,
          collision: (options.allowFlip ? 'flipfit' : 'none') + ' flipfit',
          using: options.callback,
          within: options.within
        };
      },
      bottom: function(options) {
        return {
          my: 'left top+' + options.tailDimensions.topBottom.height,
          at: 'left bottom',
          of: options.target,
          collision: 'flipfit ' + (options.allowFlip ? 'flip' : 'none'),
          using: options.callback,
          within: options.within
        };
      },
      left: function(options) {
        return {
          my: 'right-' + options.tailDimensions.leftRight.width + ' top',
          at: 'left top',
          of: options.target,
          collision: (options.allowFlip ? 'flipfit' : 'none') + ' flipfit',
          using: options.callback,
          within: options.within
        };
      }
    },

    /** @ignore */
    _show: function() {
      var self = this,
          $focusable = $(this._lastFocused),
          $contentElements;
      this.$element.show().attr('aria-hidden', false);

      if (!this.$element.find(':focusable').length && this.$element.is(':not([aria-labelledby]):not([aria-label])')) {
        $contentElements = this._getContentElement(this.$element);
        this.$element.attr('aria-labelledby', $contentElements.first().attr('id'));
      }

      this._position();
      this._previousFocus = $(document.activeElement); //save previously focused element

      // as a way to indicate a link between the popover and its activator we add .is-selected. per SUIT, components
      // can simply override this and define their own behavior
      if (this._previousFocus.length !== 0) {
        // we check if the class was already there, to keep the state as we found it
        this._restoreClass = this._previousFocus.hasClass('is-selected');
        this._previousFocus.addClass('is-selected');
      }

      if (!this.options.preventAutoHide) {
        clearTimeout(this.autoHideInitTimeout);
        this.autoHideInitTimeout = setTimeout(function() {
          // Must watch touchstart because click events don't bubble as expected on iOS Safari.
          $(document).on('touchstart.popover-hide-' + self.uuid, self._clickOutsideHandler.bind(self));
          $(document).on('click.popover-hide-' + self.uuid, self._clickOutsideHandler.bind(self));
          self._moveLastEventToFrontOfQueue(document, 'touchstart');
          self._moveLastEventToFrontOfQueue(document, 'click');
        }, 0);
      }
      if($focusable.length){
        $focusable.focus();
      } else {
        $focusable = this.$element.find(':tabbable').first();
        if ($focusable.length) {
          $focusable.focus();
        } else {
          this.$element.focus();
        }
      }
      $(document).on('keydown.popover-'+this.uuid, this._keyDown.bind(this));
      this._moveLastEventToFrontOfQueue(document, 'keydown');

      // keyboard handling
      this.$element
        .on('keydown.popover-focusLoop', ':focusable', this._tabKeyHandler.bind(this))
        // Adds is-focused class so that if more than one Popover is displayed,
        // the Popover with focus will remain on top in the z-index order.
        .on('focusin.popover', this._focusInHandler.bind(this))
        .on('focusout.popover', this._focusOutHandler.bind(this));
    },

    /**
     * Swaps order of execution of popover event listeners. With more than
     * one popover open, we need to make sure that the last
     * popover closes before any preceding popovers.
     *
     * @param {HTMLElement} element   The element target to capture the event.
     * @param {String} eventName   The event name.
     * @ignore
     */
    _moveLastEventToFrontOfQueue: function(element, eventName) {
      var eventList = $._data($(element)[0], 'events'),
          keydownEvents = eventList[eventName],
          popoverIndexes = [];
      keydownEvents.forEach(function(e, index) {
        if (e.namespace.indexOf('popover-') === 0) {
          popoverIndexes.push(index);
        }
      });
      if (popoverIndexes.length > 1) {
        keydownEvents.splice(popoverIndexes[0], 0, keydownEvents.pop());
      }
    },

    /** @ignore */
    _hide: function() {
      // remove escape handler
      $(document).off('keydown.popover-' + this.uuid);
      clearTimeout(this.autoHideInitTimeout);
      this._unforceBlur();
      this.$element.hide().attr('aria-hidden', true);
      $(document).off('.popover-hide-' + this.uuid);

      // we remove the .is-selected class, just like in the show() method
      if (this._previousFocus.length !== 0) {
        // if the class was already there before the popover added it, then we leave it
        this._previousFocus.toggleClass('is-selected', this._restoreClass);
      }

      this._lastFocused = null;

      // keyboard handling
      this.$element
        .off('keydown.popover-focusLoop, focusin.popover, focusout.popover');
    },

    /** @ignore */
    _setContent: function() {
      if (typeof this.options.content !== 'string') return;

      // adds the content
      this._$content.html(this.options.content);

      this._position();
    },

    /**
     * Deprecated.
     * @param position
     * @deprecated Please use set('pointAt', [x, y]) instead.
     */
    setPosition: function(position) {
      this.set('pointAt', position);
    },

    /**
     keydown event handler
     @private
     */
    _keyDown: function(event) {
      switch(event.which) {
        case 27: // Esc
          this._escapeKeyHandler(event);
          break;
        case 117: // F6
          this._gotoTriggerHandler(event);
          break;
      }
    },

    /**
     handler to close the dialog on escape key
     @private
     */
    _escapeKeyHandler: function(event) {
      if ($(document.activeElement).is(this.$element) || $(document.activeElement).closest(this.$element).length) {
        this._previousFocus.focus();
      }
      this.hide();
      event.preventDefault();
      event.stopImmediatePropagation();
    },

    /**
     handler to close the popover on click outside
     @private
     */
    _clickOutsideHandler: function(event) {
      var $targ = $(event.target);
      if ($targ.closest('.coral-Popover').length === 0) {
        if ($(document.activeElement).is(document.body)) {
          this._previousFocus.focus();
        }
        this.hide();
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    },

    /**
     handler to shift focus between the dialog and the main document
     @private
     */
    _gotoTriggerHandler: function(event) {
      if ($(document.activeElement).is(this.$element) || $(document.activeElement).closest(this.$element).length) {
        this._previousFocus.focus();
        this._forceBlur();
      } else {
        this._unforceBlur();
        if (!this._lastFocused) {
          this.$element.find(':focusable').addBack().first().focus();
        } else {
          this._lastFocused.focus();
        }
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    },

    /**
     Handle tab key to manage focus loop within the Popover.
     @private
     */
    _tabKeyHandler: function(event) {
      // enables keyboard support
      var elem = $(event.currentTarget),
        tabbables = this.$element.find(':tabbable'),
        focusElem;

      switch (event.which) {
        case 9: //tab
          if (event.shiftKey && event.currentTarget === tabbables[0]) {
            // in case it is the first one, we switch to the last one
            focusElem = tabbables.last();
          } else if (!event.shiftKey && event.currentTarget === tabbables[tabbables.length - 1]) {
            // in case it is the last one, we switch to the first one
            focusElem = tabbables.first();
          }
          break;
      }

      if (focusElem && focusElem.length) { // if a key matched then we set the currently focused element
        event.preventDefault();
        focusElem.focus();
      }
      this._lastFocused = document.activeElement;
    },

    /**
      Timeout id used to test the focus.

      @private
    */
    _focusTimeoutInt: -1,

    /**
      Adds is-focused class so that if more than one Popover is displayed,
      the Popover with focus will remain on top in the z-index order.
      @private
      */
    _focusInHandler: function(event) {
      clearTimeout(this._focusTimeoutInt);
      $(event.currentTarget).addClass('is-focused');
    },

    /**
      Removes is-focused class so that if more than one Popover is displayed,
      the Popover without focus will go back to its original position in the z-order.
      @private
      */
    _focusOutHandler: function (event) {
      var $currentTarget = $(event.currentTarget),
          self = this;
      clearTimeout(this._focusTimeoutInt);
      this._focusTimeoutInt =  setTimeout(function() {
        $currentTarget.removeClass('is-focused');
        if (!self.options.preventAutoHide &&
          self.$element.is(event.target) &&
          $(document.activeElement).closest(self.$element).length === 0) {
          self.hide();
        }
      }, 50);
    },

    /** @private */
    _forcedBlur: false,

    /**
      Removes Popover from document focus loop and hides it from screen readers.
      @private
      */
    _forceBlur: function() {
      if (this._forcedBlur) {
        return;
      }
      this._forcedBlur = true;

      var $focusables = this.$element.find(':focusable').addBack();
      // for each focusable element including the $element,
      $focusables.each(function(i, focusable) {
        var $focusable = $(focusable);
        // cache any existing tabindex value.
        if ($focusable.data('cached-tabindex') === undefined) {
          $focusable.data('cached-tabindex', $focusable.attr('tabindex'));
        }
        // set the tabindex to -1, so that the focusable is not included in the document tab order.
        $focusable.attr('tabindex', -1);
      });
      // hide the Popover from assistive technology and add a focusin handler.
      this.$element.attr('aria-hidden', true).on('focusin.popover-' + this.uuid, this._unforceBlur.bind(this));
    },

    /**
      Restore focus from the document to the Popover focus loop.
      @private
      */
    _unforceBlur:  function() {
      if (!this._forcedBlur) {
        return;
      }
      this._forcedBlur = false;

      var $focusables = this.$element.find(':focusable').addBack();
      // for each focusable element including the $element,
      $focusables.each(function(i, focusable) {
        var $focusable = $(focusable);
        // restore the tabindex from the cached data value.
        if ($focusable.data('cached-tabindex') === undefined) {
          $focusable.removeAttr('tabindex');
        } else {
          $focusable.attr('tabindex', $focusable.data('cached-tabindex')).removeData('cached-tabindex');
        }
      });
      // reveal the Popover to assistive technology and remove the focusin handler.
      this.$element.attr('aria-hidden', false).off('focusin.popover-' + this.uuid);
    },

    _makeAccessible: function() {
      var $contentElements = this._getContentElement(this.$element);

      // the element has the role dialog
      this.$element.attr({
        'role': 'dialog',
        'tabindex': '-1'
      });

      $contentElements
        .attr('role', $contentElements.length > 1 ? 'group' : null)
        .not('[id]').each(function(i, contentElement) {
          contentElement.setAttribute('id', CUI.util.getNextId());
        });
    }
  });

  CUI.Widget.registry.register("popover", CUI.Popover);

  $(function() {
    // Must watch touchstart because click events don't bubble as expected on iOS Safari.
    $(document).on('touchstart.popover.data-api click.popover.data-api', '[data-toggle="popover"]',function(event) {

      var $trigger = $(this),
        $target = CUI.util.getDataTarget($trigger);

      // if data target is not defined try to find the popover as a sibling
      $target = $target && $target.length > 0 ? $target : $trigger.next('.coral-Popover');

      var popover = $target.popover($.extend({pointAt: $trigger}, $target.data(), $trigger.data())).data('popover');
      popover.toggleVisibility();
      event.preventDefault();
    });
  });
}(window.jQuery));

(function ($, window, undefined) {
  CUI.SelectList = new Class(/** @lends CUI.SelectList# */{
    toString: 'SelectList',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc A select list for drop down widgets. This widget is intended to be used by other widgets.
     *
     * @description Creates a new select list
     * @constructs
     *
     * @param  {Object} options Component options
     * @param  {Mixed} options.element jQuery selector or DOM element to use for panel
     * @param  {String} [options.type=static] static or dynamic list
     * @param  {Boolean} [options.multiple=false] multiple selection or not
     * @param  {Object} options.relatedElement DOM element to position at
     * @param  {Boolean} [options.autofocus=true] automatically sets the
     * caret to the first item in the list
     * @param  {Boolean} [options.autohide=true] automatically closes the
     * list when clicking the toggle button or clicking outside of the list
     * @param  {String} [options.dataurl] URL to receive values dynamically
     * @param  {String} [options.dataurlformat=html] format of the dynamic data load
     * @param  {Object} [options.dataadditional] additonal data to be sent with a remote loading request
     * @param  {Function} [options.loadData] function to be called if more data is needed. The function should return a $.Promise, which will be done, when all requested items where added to the list. This must not be used with a set dataurl.
     * @param {String} [options.collisionAdjustment] the collision option to be passed to jquery.ui.position. Use "none" to omit flipping.
     *
     *
     */
    construct: function (options) {
      this.applyOptions();

      this.$element
        .on('change:type', this._setType.bind(this))
        .on('click', this._SELECTABLE_SELECTOR, this._triggerSelected.bind(this))
        .on('mouseenter', this._SELECTABLE_SELECTOR, this._handleMouseEnter.bind(this));

      // accessibility
      this._makeAccessible();
    },

    defaults: {
      type: 'static', // static or dynamic
      multiple: false,
      relatedElement: null,
      autofocus: true, // autofocus on show
      autohide: true,
      dataurl: null,
      dataurlformat: 'html',
      datapaging: true,
      datapagesize: 10,
      dataadditional: null,
      loadData: $.noop, // function to receive more data
      position: 'center bottom-1',  // -1 to override the border,
      collisionAdjustment: ''
    },

    /**
     * Retrieve list of first level list items (groups or options). NB: The list
     * represents a snapshot of the current state. If items are added or
     * removed, the list will become invalid.
     *
     * @return {Array} List of CUI.SelectList.Option and CUI.SelectList.Group
     *                 instances
     */
    getItems: function () {
      return this.$element.children(".coral-SelectList-item").toArray().map(function (element) {
        var $element = $(element);
        if ($element.is(".coral-SelectList-item--option")) {
          return new CUI.SelectList.Option({element : $element});
        }
        else if ($element.is(".coral-SelectList-item--optgroup")) {
          return new CUI.SelectList.Group({element : $element});
        }
      });
    },

    /**
     * Get CUI.SelectList.Option representing the option at the given position.
     *
     * @returns option
     * @throws {TypeError} if position is not numeric or if position points to
     *         group element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getOption : function (position) {
      if (!$.isNumeric(position)) {
        throw new TypeError("Position should be numeric");
      }

      var items = this.$element.children(".coral-SelectList-item"),
          element = items.eq(position);

      if (position < 0 || element.length === 0) {
        throw new RangeError("Position >" + position + "< is not within expected range [0," + (items.length - 1) + "]");
      }

      if (!element.is(".coral-SelectList-item--option")) {
        throw new TypeError("Position does not point to option element");
      }

      return new CUI.SelectList.Option({element: element});
    },

    /**
     * Get CUI.SelectList.Group representing the group at the given position.
     *
     * @returns group
     * @throws {TypeError} if position is not numeric or if position points to
     *         option element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getGroup : function (position) {
      if (!$.isNumeric(position)) {
        throw new TypeError("Position should be numeric");
      }

      var items = this.$element.children(".coral-SelectList-item"),
          element = items.eq(position);

      if (position < 0 || element.length === 0) {
        throw new RangeError("Position >" + position + "< is not within expected range [0," + (items.length - 1) + "]");
      }

      if (!element.is(".coral-SelectList-item--optgroup")) {
        throw new TypeError("Position does not point to group element");
      }

      return new CUI.SelectList.Group({element: element});
    },

    /**
     * Adds option at the given position. If position is undefined, the option
     * is added at the end of the list.
     *
     * @param {Object|CUI.SelectList.Option|Element|jQuery|Array} option that
     *        should be added. If type is Object, the keys `value` and `display`
     *        are used to create the option. If type is CUI.SelectList.Option,
     *        the underlying element is added to the list. If type is Element,
     *        the node is added to the list. If type is jQuery <b>all</b>
     *        elements within the collection are added to the list. If type is
     *        Array, then the array is expected to contain one of the other
     *        types.
     * @param {Number} Position at which the element should be inserted. If
     *        undefined, the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addOption : function (optionDescription, position) {
      var item, element, i;

      if ($.isArray(optionDescription) || (optionDescription && optionDescription.jquery)) {
        for (i = 0; i < optionDescription.length; i++) {
          this.addOption(optionDescription[i], position !== undefined ? position + i : undefined);
        }
        return;
      }
      else if (optionDescription && optionDescription.$element) {
        this.addOption(optionDescription.$element);
        return;
      }
      else if ($.isPlainObject(optionDescription)) {
        item = optionDescription;
      }
      else if (optionDescription instanceof Element) {
        element = $(optionDescription);
        item = {
          value: element.data("value"),
          display: element.text()
        };
      }
      else {
        throw new TypeError("Only Object, Element, CUI.SelectList.Option, jQuery and Array type arguments allowed.");
      }

      if (!element) {
        element = $("<li>", {
          "class": "coral-SelectList-item coral-SelectList-item--option",
          "data-value": item.value
        }).text(item.display);
      }

      this._addItem(element, position);
      this.$element.trigger($.Event("itemadded", {item: new CUI.SelectList.Option({element: element})}));
    },

    /**
     * Adds option group at the given position. If position is undefined, the group
     * is added to the end of the list.
     *
     * @param {String|CUI.SelectList.Group|Element|jQuery|Array} group that
     *        should be added. If type is String, it is used as display value.
     *        If type is CUI.SelectList.Group, the underlying element is added
     *        to the list. If type is Element, the node is added to the list.
     *        If type is jQuery <b>all</b> element within the collection are
     *        added to the list. If type is Array, then the array is expected to
     *        contain one of the other types.
     * @param {Number} Position at which the element should be inserted. If
     *        undefined, the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addGroup : function (groupDescription, position) {
      var item, element, i;

      if ($.isArray(groupDescription) || (groupDescription && groupDescription.jquery)) {
        for (i = 0; i < groupDescription.length; i++) {
          this.addGroup(groupDescription[i], position !== undefined ? position + i : undefined);
        }
        return;
      }
      else if (groupDescription && groupDescription.$element) {
        this.addGroup(groupDescription.$element);
        return;
      }
      else if ($.type(groupDescription) === "string") {
        item = {
          display: groupDescription
        };
      }
      else if (groupDescription instanceof Element) {
        element = $(groupDescription);
        item = {
          display: element.children(".coral-SelectList-groupHeader").text()
        };
      }
      else {
        throw new TypeError("Only String, Element, CUI.SelectList.Group, jQuery and Array type arguments allowed.");
      }

      if (!element) {
        element = $("<li>", {"class": "coral-SelectList-item coral-SelectList-item--optgroup"});
      }
      if (element.find(".coral-SelectList-groupHeader").length === 0) {
        element.prepend($("<span>", {"class": "coral-SelectList-groupHeader"}).text(item.display));
      }
      if (element.find(".coral-SelectList-sublist").length === 0) {
        element.append($("<ul>", {"class": "coral-SelectList-sublist"}));
      }

      this._addItem(element, position);
      this.$element.trigger($.Event("itemadded", {item: new CUI.SelectList.Group({element: element})}));
    },

    /**
     * @private
     */
    _addItem : function (element, position) {
      this._makeAccessibleListOption(element);

      var list = this._getList(),
          items = this._getItems();


      if (position === undefined || position === items.length) {
        list.append(element);
        return items.length;
      }

      if (position === 0) {
        list.prepend(element);
        return 0;
      }

      var ref = items.eq(position);

      if (position > 0 && ref.length) {
        ref.before(element);
        return position;
      }

      throw new RangeError("Position " + position + " is not within " +
                           "accepted range [0..." + items.length + "].");
    },

    /**
     * @private
     */
    _getList : function () {
      return this.$element;
    },

    /**
     * @private
     */
    _getItems : function () {
      return this._getList().children(".coral-SelectList-item");
    },

    /**
     * Selector used to find selectable items.
     * @private
     */
    _SELECTABLE_SELECTOR: '.coral-SelectList-item--option:not(.is-disabled):not(.is-hidden)',

    applyOptions: function () {
      this._setType();
    },

    /**
     * @private
     */
    _setType: function () {
      var self = this,
        timeout;

      function timeoutLoadFunc() {
        var elem = self.$element.get(0),
          scrollHeight = elem.scrollHeight,
          scrollTop = elem.scrollTop;

        if ((scrollHeight - self.$element.height()) <= (scrollTop + 30)) {
          self._handleLoadData();
        }
      }

      // we have a dynamic list of values
      if (this.options.type === 'dynamic') {

        this.$element.on('scroll.cui-selectlist-dynamic-load', function (event) {
          // debounce
          if (timeout) {
            clearTimeout(timeout);
          }

          if (self._loadingComplete || this._loadingIsActive) {
            return;
          }

          timeout = setTimeout(timeoutLoadFunc, 500);
        });
      } else { // static
        this.$element.off('scroll.cui-selectlist-dynamic-load');
      }
    },

    /**
     * The element that "owns" this SelectList element for accessibility purposes.
     * It should be an element that has an aria-owns attribute containing the id of this.$element,
     * if such an element doesn't exist, the _ownerElement will be the same as the _relatedElement.
     * @private
     */
    _ownerElement: null,

    /**
     * adds some accessibility attributes and features
     * http://www.w3.org/WAI/PF/aria/roles#listbox
     * @private
     */
    _makeAccessible: function () {
      var self = this,
          $relatedElement = $(this.options.relatedElement),
          isVisible = this.$element.hasClass('is-visible');

      this._ownerElement = $('[aria-owns*="' + this.$element.attr('id') + '"]');

      if ($relatedElement.length) {
        if (!this._ownerElement.length) {
          this._ownerElement = $relatedElement;
        }
      }

      this._ownerElement.attr({
        'id': this._ownerElement.attr('id') || CUI.util.getNextId(),
        'aria-haspopup': true,
        'aria-expanded': isVisible
      });

      $relatedElement.not(this._ownerElement).removeAttr('aria-haspopup').removeAttr('aria-expanded');

      this.$element.attr({
        'role': 'listbox',
        'aria-hidden': !isVisible,
        'aria-multiselectable': this.options.multiple || null,
        'tabindex': -1
      });

      if (isVisible) {
          this.$element.attr('tabindex', 0);
          this.$element.not('.is-inline').addClass('is-inline');
      }

      this.$element
          .off('focusin.cui-selectlist focusout.cui-selectlist')
          .on('focusin.cui-selectlist', this._handleFocusIn.bind(this))
          .on('focusout.cui-selectlist', this._handleFocusOut.bind(this));

      this._makeAccessibleListOption(this.$element.children());
    },

    /**
     * Determine if the SelectList has focus.
     * @private
     */
    _hasFocus: function () {
      return this._ownerElement.is(document.activeElement) || $(document.activeElement).closest(this.$element).length === 1;
    },

    /**
     * Handles focusin events for accessibility purposes.
     * @param event The focusin event.
     * @private
     */
    _handleFocusIn: function (event) {
      var currentFocusEntry = this.$element.find(this._SELECTABLE_SELECTOR+'[aria-selected="true"], ' + this._SELECTABLE_SELECTOR+'[tabindex="0"], '+ this._SELECTABLE_SELECTOR+'.is-highlighted').first();
      if (currentFocusEntry.length === 0) {
        this.setCaretToItem(
          this.$element.find(this._SELECTABLE_SELECTOR).first(),
          true);
        this.$element.attr('tabindex', -1);
      }

      if (this.$element.is('.is-inline')) {
        this.$element.addClass('is-focused');
        this.$element.off('keydown.cui-selectlist keypress.cui-selectlist')
          .on('keydown.cui-selectlist', this._handleKeyDown.bind(this))
          .on('keypress.cui-selectlist', this._handleKeyPress.bind(this));
      }
    },

    /**
     * Handles focusout events for accessibility purposes.
     * @param event The focusout event.
     * @private
     */
    _handleFocusOut: function (event) {
      if (this.$element.is('.is-inline')) {
        this.$element.removeClass('is-focused');
        this.$element.off('keydown.cui-selectlist keypress.cui-selectlist');
      }
    },

    _restoreFocusToOwnerElement: function() {
      var self = this,
          $ownerElement = this._ownerElement;

      if (!$ownerElement.is(':tabbable')) {
        $ownerElement = $ownerElement.find('input[type="text"], input[type="search"], button, input[type="button"]').filter(':tabbable').first();
      }
      $ownerElement.trigger('focus');
    },

    /**
     * Handles key down events for accessibility purposes.
     * @param event The keydown event.
     * @private
     */
    _handleKeyDown: function(event) {
      // enables keyboard support
      var entries = this.$element.find(this._SELECTABLE_SELECTOR),
        currentFocusEntry = entries.filter('.is-highlighted'),
        currentFocusIndex = entries.index(currentFocusEntry),
        newFocusEntry;

      if (!entries.length) {
        return;
      }

      switch (event.which) {
        case 13: // enter
        case 32: // space
          // If the toggle button for the select list has focus and
          // the user hits enter or space when a list item is
          // highlighted, they would expect the item
          // to be selected. If no item is highlighted, they
          // would expect the toggle to hide the list.
          // This is why we only preventDefault() when an entry
          // is highlighted.
          if (currentFocusEntry.length && $(document.activeElement).closest(this.$element).length === 1) {
            currentFocusEntry.trigger('click');
            event.preventDefault();
          }
          break;
        case 27: //esc
          this.hide();
          event.preventDefault();
          break;
        case 33: //page up
        case 38: //up arrow
          // According to spec, don't loop to the bottom of the list.
          if (currentFocusIndex > 0) {
            newFocusEntry = entries[currentFocusIndex-1];
          } else if (currentFocusIndex == -1) {
            newFocusEntry = entries[entries.length-1];
          }
          event.preventDefault();
          break;
        case 34: //page down
        case 40: //down arrow
          // According to spec, don't loop to the top of the list.
          if (currentFocusIndex + 1 < entries.length) {
            newFocusEntry = entries[currentFocusIndex+1];
          }
          event.preventDefault();
          break;
        case 36: //home
          newFocusEntry = entries[0];
          event.preventDefault();
          break;
        case 35: //end
          newFocusEntry = entries[entries.length-1];
          event.preventDefault();
          break;
        case 9:  //tab
          if (this.options.visible && this.options.autohide) {
            event.preventDefault();
          }
          break;
      }

      if (newFocusEntry !== undefined && this._hasFocus()) {
        this.setCaretToItem($(newFocusEntry), true);
      }
    },

    _keypressTimeoutID: null,
    _keypressTimeoutDuration: 1000,
    _keypressSearchString: "",
    _unicodeRangesRegExp: /[\u0000-\u007F|\u0080-\u00FF|\u0100-\u017F|\u0180-\u024F|\u0250-\u02AF|\u02B0-\u02FF|\u0300-\u036F|\u0370-\u03FF|\u0400-\u04FF|\u0500-\u052F|\u0530-\u058F|\u0590-\u05FF|\u0600-\u06FF|\u0700-\u074F|\u0780-\u07BF|\u0900-\u097F|\u0980-\u09FF|\u0A00-\u0A7F|\u0A80-\u0AFF|\u0B00-\u0B7F|\u0B80-\u0BFF|\u0C00-\u0C7F|\u0C80-\u0CFF|\u0D00-\u0D7F|\u0D80-\u0DFF|\u0E00-\u0E7F|\u0E80-\u0EFF|\u0F00-\u0FFF|\u1000-\u109F|\u10A0-\u10FF|\u1100-\u11FF|\u1200-\u137F|\u13A0-\u13FF|\u1400-\u167F|\u1680-\u169F|\u16A0-\u16FF|\u1700-\u171F|\u1720-\u173F|\u1740-\u175F|\u1760-\u177F|\u1780-\u17FF|\u1800-\u18AF|\u1900-\u194F|\u1950-\u197F|\u19E0-\u19FF|\u1D00-\u1D7F|\u1E00-\u1EFF|\u1F00-\u1FFF|\u2000-\u206F|\u2070-\u209F|\u20A0-\u20CF|\u20D0-\u20FF|\u2100-\u214F|\u2150-\u218F|\u2190-\u21FF|\u2200-\u22FF|\u2300-\u23FF|\u2400-\u243F|\u2440-\u245F|\u2460-\u24FF|\u2500-\u257F|\u2580-\u259F|\u25A0-\u25FF|\u2600-\u26FF|\u2700-\u27BF|\u27C0-\u27EF|\u27F0-\u27FF|\u2800-\u28FF|\u2900-\u297F|\u2980-\u29FF|\u2A00-\u2AFF|\u2B00-\u2BFF|\u2E80-\u2EFF|\u2F00-\u2FDF|\u2FF0-\u2FFF|\u3000-\u303F|\u3040-\u309F|\u30A0-\u30FF|\u3100-\u312F|\u3130-\u318F|\u3190-\u319F|\u31A0-\u31BF|\u31F0-\u31FF|\u3200-\u32FF|\u3300-\u33FF|\u3400-\u4DBF|\u4DC0-\u4DFF|\u4E00-\u9FFF|\uA000-\uA48F|\uA490-\uA4CF|\uAC00-\uD7AF|\uD800-\uDB7F|\uDB80-\uDBFF|\uDC00-\uDFFF|\uE000-\uF8FF|\uF900-\uFAFF|\uFB00-\uFB4F|\uFB50-\uFDFF|\uFE00-\uFE0F|\uFE20-\uFE2F|\uFE30-\uFE4F|\uFE50-\uFE6F|\uFE70-\uFEFF|\uFF00-\uFFEF|\uFFF0-\uFFFF]/,

    /**
     * Handles key press events for accessibility purposes. Provides alphanumeric search.
     * @param event The keypress event.
     * @private
     */
    _handleKeyPress: function(event) {
      // enables keyboard support
      var entries = this.$element.find(this._SELECTABLE_SELECTOR),
        currentFocusEntry = entries.filter('.is-highlighted'),
        currentFocusIndex = entries.index(currentFocusEntry),
        $newFocusEntry,
        newString = '',
        start, i, entry, regex, comparison;

      if (!entries.length) {
        return;
      }
      switch (event.which) {
        case 13: // enter
        case 32: // space
        case 27: // esc
        case 33: // page up
        case 37: // left arrow
        case 38: // up arrow
        case 34: // page down
        case 39: // right arrow
        case 40: // down arrow
        case 36: // home
        case 35: // end
        case 9: // tab
          break;
        default:  // alphanumeric
          clearTimeout(this._keypressTimeoutID);

          newString = String.fromCharCode(event.which);


          if (!this._unicodeRangesRegExp.test(newString)) {
              newString = '';
          }

          if (newString === '') {
            return;
          }

          this._keypressSearchString += newString !== this._keypressSearchString ? newString : '';

          this._keypressTimeoutID = setTimeout(function () {
            this._keypressSearchString = '';
          }.bind(this), this._keypressTimeoutDuration);

          if (currentFocusIndex === -1) {
            start = 0;
          }
          else if (this._keypressSearchString.length === 1) {
            start = currentFocusIndex + 1;
          }
          else {
            start = currentFocusIndex;
          }

          regex = new RegExp('^' + this._keypressSearchString.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&'), 'i');

          for (i = start; i < entries.length; i++) {
            entry = entries.eq(i);
            comparison = $.trim((entry.data('display') || entry.text()));
            if (regex.test(comparison)) {
              $newFocusEntry = entry;
              break;
            }
          }

          if ($newFocusEntry === undefined) {
            for (i = 0; i < start; i++) {
              entry = entries.eq(i);
              comparison = $.trim((entry.data('display') || entry.text()));
              if (regex.test(comparison)) {
                $newFocusEntry = entry;
                break;
              }
            }
          }

          if ($newFocusEntry !== undefined) {
            this.setCaretToItem($newFocusEntry, true);
          }
      }
    },

    /**
     * makes the list options accessible
     * @private
     * @param  {jQuery} elem
     */
    _makeAccessibleListOption: function (elem) {
      elem.each(function (i, e) {
        var entry = $(e), $optGroupTitle;

        // group header
        if (entry.hasClass('coral-SelectList-item--optgroup')) {
          $optGroupTitle = entry.children('.coral-SelectList-groupHeader');
          $optGroupTitle.attr({
            'id': $optGroupTitle.attr('id') || CUI.util.getNextId(),
            'role': 'heading'
          });
          entry.attr({
            'role': 'presentation'
          }).children('ul').each(function(i, ul){
            var $ul = $(ul);
            $ul.attr({
              'role': 'group',
              'aria-labelledby': $optGroupTitle.attr('id')
            });
          }).children('li').each(function(i, li){
            var $li = $(li);
            $li.attr({
              'role': 'option',
              'id': $li.attr('id') || CUI.util.getNextId()
            });
          });
        } else {
          entry.attr({
            'role': 'option',
            'id': entry.attr('id') || CUI.util.getNextId()
          });
        }
      });
    },

    /**
     * Visually focuses the provided list item and ensures it is within
     * view.
     * @param {jQuery} $item The list item to focus.
     * @param {boolean} scrollToItem Whether to scroll to ensure the item
     * is fully within view.
     */
    setCaretToItem: function($item, scrollToItem) {
      this.$element.find('.coral-SelectList-item--option')
        .removeClass('is-highlighted')
        .removeAttr('tabindex');

      $item.addClass('is-highlighted').attr('tabindex', 0);
      this._ownerElement.attr('aria-activedescendant', $item.attr('id'));
      this.$element.attr('aria-activedescendant', $item.attr('id'));

      if (this._hasFocus()) {
        $item.trigger('focus');
      } else if (scrollToItem) {
        this.scrollToItem($item);
      }
    },

    /**
     * Removes visual focus from list items and scrolls to the top.
     */
    resetCaret: function() {
      this.$element.find('[role="option"]')
        .removeClass('is-highlighted')
        .removeAttr('tabindex');
      this.$element.scrollTop(0);
      this._ownerElement.removeAttr('aria-activedescendant');
      this.$element.removeAttr('aria-activedescendant');
    },

    /**
     * Scrolls as necessary to ensure the list item is within view.
     * @param {jQuery} $item The list item
     */
    scrollToItem: function($item) {
      if (!$item.length) {
        return;
      }

      var itemTop = $item.position().top,
        itemHeight = $item.outerHeight(false),
        scrollNode = this.$element[0];

      var bottomOverflow = itemTop + itemHeight - scrollNode.clientHeight;

      if (bottomOverflow > 0) {
        scrollNode.scrollTop += bottomOverflow;
      } else if (itemTop < 0) {
        scrollNode.scrollTop += itemTop;
      }
    },

    show: function () {
      if (this.options.visible) {
        return this;
      } else {
        hideLists(); // Must come before the parent show method.
        return this.inherited(arguments);
      }
    },

    /**
     * @private
     */
    _show: function () {
      var self = this,
          currentFocusEntry = this.$element.find(this._SELECTABLE_SELECTOR+'[aria-selected="true"], ' + this._SELECTABLE_SELECTOR+'[tabindex="0"], '+ this._SELECTABLE_SELECTOR+'.is-highlighted').first();

      this.$element
        .addClass('is-visible')
        .attr('aria-hidden', false);

      this._ownerElement.attr('aria-expanded', true);

      this._position();

      if (this.options.autofocus) {
        if (currentFocusEntry.length === 0) {
            currentFocusEntry = this.$element.find(this._SELECTABLE_SELECTOR).first();
        }
        this.setCaretToItem(
          currentFocusEntry,
          true);
      }

      // if dynamic start loading
      if (this.options.type === 'dynamic') {
        var dataRequest = this._outstandingRequest || this._handleLoadData();
        dataRequest.done(function () {
          if (self.options.autofocus) {
            self.setCaretToItem(
              self.$element.find(self._SELECTABLE_SELECTOR).first(),
              true);
          }
        });
      }

      $(document).on('keydown.cui-selectlist', this._handleKeyDown.bind(this))
        .on('keypress.cui-selectlist', this._handleKeyPress.bind(this));
    },

    /**
     * Positions the list below a related component (or above when it does not fit below).
     * @private
     */
    _position: function () {
      if (this.options.visible) {
        this.$element.position({
          my: 'top',
          at: this.options.position,
          of: this.options.relatedElement,
          collision: this.options.collisionAdjustment
        });

        var $relatedElement = $(this.options.relatedElement);
        // Verify if select list is positioned above or below the related element
        if(this.$element.offset().top < $relatedElement.offset().top) {
          this.$element
            .removeClass('is-below')
            .addClass('is-above');
          $relatedElement
            .removeClass('is-above')
            .addClass('is-below');
        }
        else {
          this.$element
            .removeClass('is-above')
            .addClass('is-below');
          $relatedElement
            .removeClass('is-below')
            .addClass('is-above');
        }
      }
    },

    /**
     * @private
     */
    _hide: function () {
      var $relatedElement = $(this.options.relatedElement),
          $ownerElement = this._ownerElement,
          removeKeyboardEventHandlers = true,
          hasFocus = this._hasFocus();

      this.$element
        .removeClass('is-visible')
        .attr('aria-hidden', true);

      this._ownerElement.attr('aria-expanded', true);

      this.reset();

      // Determine if there is a visible selectList with autohide=false
      $(selectListSelector).each(function () {
        var selectList = $(this).data('selectList');
        if (selectList && !selectList.get('autohide') && selectList.get('visible')) {
          // If the selectList with autohide=false is visible,
          // we don't want to remove the keyboard event listeners.
          removeKeyboardEventHandlers = false;
        }
      });

      // Only remove keyboard event listeners when no selectList with autohide=false is visible.
      if (removeKeyboardEventHandlers) {
        $(document).off('keydown.cui-selectlist keypress.cui-selectlist');
      }

      $ownerElement.removeAttr('aria-activedescendant');
      if ($ownerElement.length && hasFocus) {
          setTimeout(this._restoreFocusToOwnerElement.bind(this), 50);
      }
    },

    /**
     * triggers an event for the currently selected element
     * @fires SelectList#selected
     * @private
     */
    _triggerSelected: function (event) {
      var cur = $(event.currentTarget),
        val = cur.data('value'),
        display = cur.data('display') || cur.text();

      cur.trigger($.Event('selected', {
        selectedValue: val,
        displayedValue: display
      }));
    },

    /**
     * handles the mousenter event on an option
     * this events sets the the focus to the current event
     * @param  {jQuery.Event} event
     *
     * @private
     */
    _handleMouseEnter: function (event) {
      this.setCaretToItem($(event.currentTarget), false);
    },

    /**
     * deletes the item from the dom
     */
    clearItems: function () {
      this.$element.empty();
    },

    /**
     * current position for the pagination
     * @private
     * @type {Number}
     */
    _pagestart: 0,

    /**
     * indicates if all data was fetched
     * @private
     * @type {Boolean}
     */
    _loadingComplete: false,

    /**
     * indicates if currently data is fetched
     * @private
     * @type {Boolean}
     */
    _loadingIsActive: false,

    /**
     * The outstanding request. When data is actively being loaded this will be an implementation of the jQuery
     * Promise interface, typically a jqXHR object.
     * @type {Object}
     */
    _outstandingRequest: null,

    /**
     * handle asynchronous loading of data (type == dynamic)
     * @private
     */
    _handleLoadData: function () {
      var promise,
        self = this,
        end = this._pagestart + this.options.datapagesize;

      if (this._outstandingRequest && typeof this._outstandingRequest.abort === 'function') {
        this._outstandingRequest.abort();
      } else {
        // add wait
        $('<div/>', {
          'class': 'coral-SelectList-item--wait',
          'role': 'presentation'
        }).append($('<span/>', {
          'class': 'coral-Wait',
          'role': 'progressbar'
        })).appendTo(self.$element);

        this._position();

        // activate fetching
        this._loadingIsActive = true;
      }

      // load from given URL
      if (this.options.dataurl) {
        promise = $.ajax({
          url: this.options.dataurl,
          context: this,
          dataType: this.options.dataurlformat,
          data: $.extend({
            start: this._pagestart,
            end: end
          }, this.options.dataadditional || {})
        }).done(function (data) {
            var cnt = 0;

            if (self.options.dataurlformat === 'html') {
              var elem = $(data);

              cnt = elem.filter('li').length;

              self._makeAccessibleListOption(elem);
              self.$element.append(elem);
            }

            // if not enough elements came back then the loading is complete
            if (cnt < self.options.datapagesize) {
              this._loadingComplete = true;
            }

          });

      } else { // expect custom function to handle
        promise = this.options.loadData.call(this, this._pagestart, end);
        promise.done(function (loadingComplete) {
          if (loadingComplete !== undefined) {
            self._loadingComplete = loadingComplete;
          }
        });
      }

      promise.done(function() {
         // increase to next page
         self._pagestart = end;
      });

      promise.always(function () {
        self.$element.find('.coral-SelectList-item--wait').remove();
        self._position();
        self._loadingIsActive = false;
        self._outstandingRequest = null;
      });

      this._outstandingRequest = promise;

      return promise;
    },

    /**
     * resets the dynamic loaded data
     */
    reset: function () {
      if (this.options.type === 'dynamic') {
        this.clearItems();
        this._pagestart = 0;
        this._loadingComplete = false;
      }
    },

    /**
     * triggers a loading operation
     * this requires to have the selectlist in a dynamic configuration
     * @param  {Boolean} reset resets pagination
     */
    triggerLoadData: function (reset) {
      if (reset) {
        this.reset();
      }

      this._handleLoadData();
    },

    /**
     * Filters the list of items based on a provided filtering function. This
     * filtering only occurs on the client and therefore is primarily intended
     * to be used with a static list (type=static).
     * @param {CUI.SelectList~filterCallback} [callback] Callback used to test
     * list options. If no function is passed, all items will be shown.
     */
    filter: function(callback) {
      var $items = this.$element.find('.coral-SelectList-item--option'),
          $groups = this.$element.find('.coral-SelectList-item--optgroup');

      if (callback) {
        $items.each(function() {
          var $item = $(this);

          var hideItem =
              !callback.call(this, $item.data('value'), $item.data('display') || $item.text());

          $item.toggleClass('is-hidden', hideItem);

          if (hideItem) {
            $item.removeClass('is-highlighted');
          }
        });

        $groups.each(function() {
          var $group = $(this);

          var hasVisibleItems =
              $group.find('[role="option"]:not(.is-hidden)').length > 0;

          $group.toggleClass('is-hidden', !hasVisibleItems);
        });
      } else {
        // Shortcut for performance. Assumes that all groups have items
        // and therefore should be shown.
        $items.removeClass('is-hidden');
        $groups.removeClass('is-hidden');
      }

      // Important when the bottom of the list needs to stay pegged to the top of an input, for example.
      this._position();
    }
  });

  CUI.Widget.registry.register("selectlist", CUI.SelectList);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.SelectList.init($('[data-init~=selectlist]', event.target));
    });
  }

  var selectListSelector = '.coral-SelectList',
    toggleSelector = '[data-toggle~=selectlist]';

  /**
   * Hides all select lists that have autohide enabled.
   * @ignore
   */
  var hideLists = function () {
    $(selectListSelector).each(function () {
      var selectList = $(this).data('selectList');
      if (selectList && selectList.get('autohide')) {
        selectList.hide();
      }
    });
  };

  /**
   * From a toggle element, toggles the visibility of its target select list.
   * @ignore
   */
  var toggleList = function () {
    var $selectList = CUI.util.getDataTarget($(this)),
        selectListWidget;
    if ($selectList.length) {
      selectListWidget = $selectList.data('selectList');
      if (!selectListWidget.get('relatedElement')) {
        selectListWidget.set('relatedElement', this);
        selectListWidget._makeAccessible();
      }
      selectListWidget.resetCaret();
      selectListWidget.toggleVisibility();
    }
    return false;
  };

  var handleToggleSelectorKeydown = function(event) {
    var $selectList = CUI.util.getDataTarget($(this)),
        selectList = $selectList.data('selectList'),
        isVisible = $selectList.length && $selectList.hasClass('is-visible');
    switch(event.which) {
      case 40:
        if ($selectList.length && !isVisible) {
          toggleList.call(this);
        }
        event.preventDefault();
        break;
      case 9:
        if (isVisible && selectList.get('autohide')) {
          event.preventDefault();
        }
        break;
    }
  };

  $(document)
    // If a click reaches the document, hide all open lists.
    .on('click.cui-selectlist', hideLists)

    // If the click is from a select list, don't let it reach the document
    // to keep the listener above from hiding the list.
    .on('click.cui-selectlist', selectListSelector, function (event) {
      event.stopPropagation();
    })

    // If a click is from a trigger button, toggle its menu.
    .on('click.cui-selectlist', toggleSelector, toggleList)

    .on('keydown.cui-selectlist-toggleSelector', toggleSelector, handleToggleSelectorKeydown);


  /**
   * Triggered when option was selected
   *
   * @name CUI.SelectList#selected
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.selectedValue value which was selected
   * @param {String} event.displayedValue displayed text of the selected element
   */

  /**
   * Triggered after option or group was added
   *
   * @name CUI.SelectList#itemadded
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.kind either "option" or "group"
   * @param {String} event.position index of element within parents child list
   * @param {String} event.display displayed text of added element
   * @param {String} event.value value of added element (not present for groups)
   * @param {String} event.target either .coral-SelectList or .coral-SelectList-item--optgroup
   *                              node to which the element was added. Use this
   *                              to detect hierarchies
   */

  /**
   * Triggered after option or group was removed
   *
   * @name CUI.SelectList#itemremoved
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.kind either "option" or "group"
   * @param {String} event.position index of element within parents child list
   *                                before it was removed
   * @param {String} event.display displayed text of removed element
   * @param {String} event.value value of removed element (not present for groups)
   * @param {String} event.target either .coral-SelectList or .coral-SelectList-item--optgroup
   *                              node from which the element was removed. Use
   *                              this to detect hierarchies
   */

  /**
   * Triggered when option was unselected (not implemented)
   *
   * @name CUI.SelectList#unselected
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.selectedValue value which was unselected
   * @param {String} event.displayedValue displayed text of the unselected element
   */

  /**
   * Callback used to test list options for filtering purposes. Expects a
   * return value of true if the list item should be visible or false if it
   * should be hidden.
   *
   * @callback CUI.SelectList~filterCallback
   * @param {Object} value The value of the list item.
   * @param {String} display The text representation of the list item.
   */

}(jQuery, this));

(function ($, window, undefined) {
  CUI.SelectList.Item = new Class(/** @lends CUI.SelectList.Item# */{
    toString : 'SelectList.Item',
    $element : undefined,

    /**
     * @private
     * The last known position before the element was removed.
     */
    _cachedPosition: null,

    construct : function (args) {
      this.$element = $(args.element);
    },

    /**
     * Get position within the set of sibling items. The return value may be
     * used as index with {get,add}Group() and {get,add}Option().
     */
    getPosition : function () {
      var position = this.$element.index();
      return position > -1 ? position : this._cachedPosition;
    },

    /**
     * @abstract
     */
    getDisplay : function () {
      throw new Error("Subclass responsibility");
    },

    /**
     * Remove item from list.
     */
    remove : function () {
      var parent = this._getParent();

      this._cachedPosition = this.getPosition();
      this.$element.remove();
      parent.trigger($.Event("itemremoved", {item: this}));
    },

    /**
     * @abstract
     * @private
     */
    _getParent : function () {
      throw new Error("Subclass responsibility");
    }
  });
}(jQuery, this));

(function ($, window, undefined) {
  CUI.SelectList.Option = new Class(/** @lends CUI.SelectList.Option# */{
    toString : 'SelectList.Option',

    extend: CUI.SelectList.Item,

    /**
     * Get displayed text, which represents the Option.
     */
    getDisplay : function () {
      return this.$element.text();
    },

    /**
     * Get value, which represents the Option.
     */
    getValue : function () {
      return this.$element.attr("data-value");
    },

    /**
     * @override
     * @private
     */
    _getParent : function () {
      return this.$element.closest(".coral-SelectList, .coral-SelectList-item--optgroup");
    }
  });
}(jQuery, this));

(function ($, window, undefined) {
  CUI.SelectList.Group = new Class(/** @lends CUI.SelectList.Group# */{
    toString : 'SelectList.Group',
    extend: CUI.SelectList.Item,

    /**
     * Get displayed text, which represents the Group.
     */
    getDisplay : function () {
      return this.$element.children("span").text();
    },

    /**
     * Get list of Options, that are part of this Group. Similar to
     * {@linkcode CUI.SelectList.getItems()}, only that this may only return
     * Option instances.
     *
     * @return {Array} List of CUI.SelectList.Option instances.
     */
    getItems : function () {
      return this._getItems().toArray().map(function (element) {
        return new CUI.SelectList.Option({element : element});
      });
    },

    /**
     * Get CUI.SelectList.Option representing the option at the given position.
     *
     * @returns option
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getOption : function (position) {
      if (!$.isNumeric(position)) {
        throw new TypeError("Position should be numeric");
      }

      var items = this._getItems(),
          element = items.eq(position);

      if (position < 0 || element.length === 0) {
        throw new RangeError("Position >" + position + "< is not within expected range [0," + (items.length - 1) + "]");
      }

      return new CUI.SelectList.Option({element: element});
    },

    /**
     * Add Option to Group. If specified, the option will be inserted at
     * `position`, otherwise at the end.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     */
    addOption : CUI.SelectList.prototype.addOption,

    /**
     * @private
     */
    _addItem : CUI.SelectList.prototype._addItem,
    /**
     * @private
     */
    _getList : function () {
      return this.$element.children(".coral-SelectList-sublist").first();
    },
    /**
     * @private
     */
    _getItems : CUI.SelectList.prototype._getItems,
    /**
     * @private
     */
    _makeAccessibleListOption : CUI.SelectList.prototype._makeAccessibleListOption,

    /**
     * @override
     * @private
     */
    _getParent : function () {
      return this.$element.parent();
    }
  });
}(jQuery, this));

(function ($) {
  CUI.Switch = new Class(/** @lends CUI.Switch# */{
    toString: 'Switch',
    extend: CUI.Widget,

    construct: function (options) {
      this._initMarkup();
      this._setListeners();
    },

    /** @ignore */
    _initMarkup: function () {

      //  This correct
      this._correctElementTagName();

      this.$input = this.$element.find('.coral-Switch-input');
      this.$onLabel = this.$element.find('.coral-Switch-onLabel');
      this.$offLabel = this.$element.find('.coral-Switch-offLabel');

      this._makeAccessible();
    },

    /**
      Replaces label element with a span element.

      If the $element is a label, both 'On' and 'Off'
      will be announced by screen readers along with any
      explicit label for the $input element, which is undesireable.
      @ignore
     */
    _correctElementTagName: function () {
      var $newElement, attributes;

      if (!this.$element.is('label')) {
        return;
      }

      $newElement = $('<span/>');

      attributes = this.$element.prop("attributes");

      // loop through $element attributes and apply them on $newElement
      $.each(attributes, function() {
          $newElement.attr(this.name, this.value);
      });

      $newElement.insertBefore(this.$element).append(this.$element.children());
      this.$element.remove();
      this.$element = $newElement;
    },

    /** @ignore */
    _makeAccessible: function() {
      var self = this,
          labelIDs,
          checked = self.$input.is(':checked'),
          isMacLike = /(mac|iphone|ipod|ipad)/i.test(window.navigator.platform),
          isFirefox = /firefox/i.test(window.navigator.userAgent);

      if (!this.$input.attr('id')) {
        this.$input.attr('id', CUI.util.getNextId());
      }

      if (!this.$offLabel.attr('id')) {
        this.$offLabel.attr('id', CUI.util.getNextId());
      }

      if (!this.$onLabel.attr('id')) {
        this.$onLabel.attr('id', CUI.util.getNextId());
      }

      if (!isMacLike) {
        this.$input.attr({
          'role': 'button',
          'aria-pressed': checked
        });
      }

      this.$offLabel.attr({
        'role': 'presentation',
        'aria-hidden': checked
      });

      this.$onLabel.attr({
        'role': 'presentation',
        'aria-hidden': !checked
      });

      if (this.$input.attr('aria-label') || (this.$input.attr('aria-labelledby') && $('#' + this.$input.attr('aria-labelledby').split(' ')[0]).length)) {
        return;
      }

      // check to see if the switch $element is wrapped in a label
      this.$labels = this.$element.closest('label');

      // If it is wrapped in a label, screen readers will announce both
      // 'On' and 'Off' along with any other label content, which can be pretty annoying.
      // This unwraps the switch $element and appends it as a sibling of the label.
      if (this.$labels.length === 1) {
        // Make sure that the label wrapping the switch $element is
        // explicitly associated with the $input using the for attribute.
        if (this.$labels.attr('for') !== this.$input.attr('id')) {
          this.$labels.attr('for', this.$input.attr('id'));
        }
        // If the label text comes before the switch $element,
        // insert the $element after the label,
        // otherwise insert the $element before the label.
        var beforeOrAfter = (this.$labels.contents()
          .filter(function() {
            return (this.nodeType === 3 && $.trim(this.nodeValue).length) || this.nodeType === 1;
          }).index(this.$element) === 0) ? 'Before' : 'After';
        this.$element['insert'+ beforeOrAfter](this.$labels);
      } else {
        this.$labels = $('label[for="' + this.$input.attr('id') + '"]').not(this.$offLabel).not(this.$onLabel);

        if (this.$labels.length === 0) {
          this.$labels = this.$labels.add(this.$offLabel).add(this.$onLabel);
        }

        if (this.$labels.length > 0) {
          labelIDs = [];

          this.$labels.each(function(i, label) {
            var $label = $(label),
                isOnLabel = $label.is(self.$onLabel),
                isOffLabel = $label.is(self.$offLabel);

            if (!$label.attr('id')) {
              $label.attr('id', CUI.util.getNextId());
            }

            if ((!isOnLabel && !isOffLabel) || (isOnLabel && checked) || (isOffLabel && !checked)) {
              labelIDs.push($label.attr('id'));
            }
          });

          if (labelIDs.length > 0) {
            this.$input.attr('aria-labelledby', labelIDs.join(' '));
          }
        }
      }

      // HACK: In Firefox on OSX, VoiceOver favors aria-describedby over label which is undesireable.
      if (isMacLike && isFirefox) {
        return;
      }
      this.$input.attr('aria-describedby', checked ? this.$onLabel.attr('id') : this.$offLabel.attr('id'));
    },

    /** @ignore */
    _setListeners: function () {
      this.$input.on('change', function(event) {
        var checked = this.$input.is(':checked'),
            onLabelId = this.$onLabel.attr('id'),
            offLabelId = this.$offLabel.attr('id'),
            ariaLabelledBy = this.$input.attr('aria-labelledby');

        if (ariaLabelledBy) {
          ariaLabelledBy = ariaLabelledBy.replace((checked ? offLabelId : onLabelId), (checked ? onLabelId : offLabelId));
          this.$input.attr('aria-labelledby', ariaLabelledBy);
        }

        this.$input
          .filter('[aria-describedby]').attr('aria-describedby', checked ? this.$onLabel.attr('id') : this.$offLabel.attr('id'))
          .filter('[aria-pressed]').attr('aria-pressed', checked);

        this.$onLabel.attr('aria-hidden', !checked);

        this.$offLabel.attr('aria-hidden', checked);

      }.bind(this));
      this.$input.trigger('change');
    },
  });

  CUI.Widget.registry.register("Switch", CUI.Switch);

  // Data API
  $(document).on("cui-contentloaded.data-api", function (e) {
    CUI.Switch.init($("[data-init~=switch], .coral-Switch", e.target));
  });

}(window.jQuery));

(function ($, window, undefined) {

  var CLASS_PANE_LIST = 'coral-TabPanel-content',
      CLASS_TAB_LIST = 'coral-TabPanel-navigation',

      SELECTOR_TAB_LIST = '.' + CLASS_TAB_LIST,
      SELECTOR_PANE_LIST = '.' + CLASS_PANE_LIST;

  CUI.Tabs = new Class(/** @lends CUI.Tabs# */{
    toString: 'Tabs',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc A group of tabs.
     *
     * @description Creates a new tab panel
     * @constructs
     *
     * @param  {Object} options Component options
     * @param  {Mixed} options.element jQuery selector or DOM element to use for panel
     * @param  {String} [options.type=""] Style type of the tabs. Can be
     * "stacked", "nav", or left blank (infers the default type).
     * @param  {Number} [options.active=0] index of active tab
     */
    construct: function (options) {

      this.tablist = this._findOrCreateTabList();
      this.panelist = this._findOrCreatePaneList();

      this._applyOptions();

      // set up listeners for change events
      this.$element.on('change:type', this._setType.bind(this));
      this.$element.on('change:active', this._setActive.bind(this));
    },

    defaults: {},

    // Note: the white tabs variant is deprecated, and will be removed in a future release
    // See https://issues.adobe.com/browse/CUI-1156 and https://issues.adobe.com/browse/CUI-1154
    DEFAULT_VARIANT_KEY: 'default',

    VARIANT_TYPES: [
      'default',
      'stacked',
      'nav'
    ],

    VARIANT_CLASS_MAPPING: {
      'default': '',
      'stacked': 'coral-TabPanel--stacked',
      'nav': 'coral-TabPanel--large'
    },

    /**
     * Disables a tab
     * @param  {jQuery} tab
     * @return {jQuery} this, chainable
     */
    setDisabled: function (tab, switcher) {
      var hop = switcher || false;

      tab.toggleClass('is-disabled', hop)
        .prop('aria-disabled', hop);
      return this;
    },

    /**
     * Enables a tab
     * @param  {jQuery} tab
     * @return {jQuery} this, chainable
     */
    setEnabled: function (tab) {
      return this.setDisabled(tab, true);
    },

    /**
     * Adds a tab and associated panel.
     *
     * @param {Object} [options] Tab options.
     * @param {String|HTMLElement|jQuery} [options.tabContent] Content to be
     * used inside the tab. This can be an HTML string, a DOM node,
     * or a jQuery object. This content will be wrapped by an
     * internally-created element that will serve as the tab.
     * @param {String|HTMLElement|jQuery} [options.panelContent] Content to be
     * used inside the panel. This can be an HTML string, a DOM node,
     * or a jQuery object. This content will be wrapped by an internally-created
     * element that will serve as the panel. This is not intended to be
     * used when options.panelURL is defined.
     * @param {String} [options.panelURL] A URL from which to asynchronously
     * load the panel content when the tab is activated. This is not intended
     * to be used when options.panelContent is defined.
     * @param {String} [options.panelID] An ID to be applied to the
     * internally-created panel. If one is not provided, a unique ID will be
     * generated for the panel.
     * @param {Number} [options.index] The index at which the tab should be
     * added. If no index is provided, the tab will be added as the last
     * tab.
     * @param {Boolean} [options.enabled=true] Whether the tab should be
     * enabled (disabled tabs cannot be selected).
     * @param {Boolean} [options.active=true] Whether the tab should be
     * immediately activated/selected. In other words, its panel will be
     * immediately visible and panels for other tabs will be hidden.
     *
     * @return {String} The ID of the panel. If options.panelID was defined,
     * this will be the same value. If options.panelID was not defined,
     * this will be an internally-generated, unique ID.
     */
    addItem: function(options) {
      var tabs = this._getTabs();

      options = $.extend({
        tabContent: '',
        panelContent: '',
        panelID: undefined,
        panelURL: undefined,
        index: tabs.length,
        enabled: true,
        active: true
      }, options);

      var $panel = $('<section class="coral-TabPanel-pane"/>').append(options.panelContent);

      if (options.panelID !== undefined) {
        $panel.attr('id', options.panelID);
      }

      var $tab = $('<a class="coral-TabPanel-tab" data-toggle="tab"/>').append(options.tabContent);

      if (options.panelURL !== undefined) {
        $tab.attr('href', options.panelURL);
      }

      // Confine the index to valid values.
      var index = Math.min(Math.max(options.index, 0), tabs.length);

      if (index === 0) {
        this.tablist.prepend($tab);
        this.panelist.prepend($panel);
      } else {
        tabs.eq(index - 1).after($tab);
        this._getPanels().eq(index - 1).after($panel);
      }

      if (!options.enabled) {
        $tab.addClass('is-disabled');
      }

      this._makeTabsAccessible($tab);

      if (options.active && options.enabled) {
        this._activateTab($tab, true);
      }

      return $panel.attr('id');
    },

    /**
     * Removes a tab and associated panel. If the tab being removed is
     * the active tab, the nearest enabled tab will be activated.
     * @param {Number} index The index of the tab to remove.
     */
    removeItem: function(indexOrID) {
      var $tabs = this._getTabs(),
        $panels = this._getPanels(),
        $tab, $panel;

      if (typeof indexOrID === 'number') {
        $tab = $tabs.eq(indexOrID);
        $panel = $panels.eq(indexOrID);
      } else if (typeof indexOrID === 'string') {
        $tab = $tabs.filter('[aria-controls="' + indexOrID + '"]');
        $panel = $panels.filter('#' + indexOrID);
      }

      if (!$tab || !$panel) {
        return;
      }

      if ($tab.hasClass('is-active')) {
        var ENABLED_TAB_SELECTOR = '.coral-TabPanel-tab[data-toggle="tab"]:not(.is-disabled)';

        var $tabToActivate = $tab.nextAll(ENABLED_TAB_SELECTOR).first();

        if ($tabToActivate.length === 0) {
          $tabToActivate = $tab.prevAll(ENABLED_TAB_SELECTOR).first();
        }

        if ($tabToActivate.length === 1) {
          this._activateTab($tabToActivate, true);
        }
      }

      $panel.remove();
      $tab.remove();
    },

    /** Internals **/

    // finds or creates the container for the tabs
    /** @ignore **/
    _findOrCreateTabList: function() {
      var element = this.$element.find(SELECTOR_TAB_LIST);
      if (element.length === 0) {
        element = $('<nav>')
            .addClass(CLASS_TAB_LIST)
            .prependTo(this.$element);
      }
      return element;
    },

    // finds or creates the container for the panes that are being
    // switched be the tabs
    /** @ignore **/
    _findOrCreatePaneList: function() {
      var element = this.$element.find(SELECTOR_PANE_LIST);
      if (element.length === 0) {
        element = $('<div>')
            .addClass(CLASS_PANE_LIST)
            .appendTo(this.$element);
      }
      return element;
    },

    // sets all options
    /** @ignore */
    _applyOptions: function () {
      var activeTab = this._getTabs().filter('.is-active');

      // ensure the type is set correctly
      if (this.options.type) {
        this._setType(this.options.type);
      }

      // init tab switch
      this._initTabswitch();

      // accessibility
      this._makeAccessible();

      // set an active tab if there is non flagged as active
      if (activeTab.length === 0) {
        this._setActive(this.options.active || 0);
      } else {
        // call the activation logic
        // in case the initial tab has remote content
        this._activateTab(activeTab, true);
      }
    },

    /**
     * @return {jQuery} All tabs.
     * @private
     * @ignore
     */
    _getTabs: function() {
      return this.tablist.find('> .coral-TabPanel-tab[data-toggle="tab"]');
    },

    /**
     * @return {jQuery} All panels.
     * @private
     * @ignore
     */
    _getPanels: function() {
      return this.panelist.children('.coral-TabPanel-pane');
    },

    // Set a certain tab (by index) as active
    // * @param  {Number} index of the tab to make active
    /** @ignore */
    _setActive: function (idx) {
      idx = $.isNumeric(idx) ? idx : this.options.active;
      var activeTab = this._getTabs().eq(idx);
      // Activate the tab, but don't focus
      this._activateTab(activeTab, true);
    },

    // sets the type of the tabs
    // @param  {String} type of the tabs: 'default', 'nav', 'stacked'
    /** @ignore */
    _setType: function (type) {

      var that = this,
          classValue = $.type(type) === 'string' ? type : this.options.type;

      // applies the variant if the class type i
      if (this.VARIANT_TYPES.indexOf(classValue) > -1 && this.VARIANT_CLASS_MAPPING[classValue] !== undefined) {


        // gets all the class mappings
        var vals = Object.keys(this.VARIANT_CLASS_MAPPING).map(function (key) {
            return that.VARIANT_CLASS_MAPPING[key];
        });
        // removes any additional class
        this.$element.removeClass(vals.join(' '));

        // adds the new type variant
        this.$element.addClass(this.VARIANT_CLASS_MAPPING[classValue]);
      }
    },

    // activates the given tab
    /** @ignore */
    _activateTab: function (tab, noFocus) {
      var href = tab.attr('href'),
        activeClass = 'is-active',
        tabs = this._getTabs(),
        panels = this._getPanels(),
        panel;

      // do not allow to enable disabled tabs
      if (tab.hasClass('is-disabled')) {
        tab.blur(); // ensure disabled tabs do not receive focus
        return false;
      }

      // get panel based on aria control attribute
      panel = panels.filter('#' + tab.attr('aria-controls'));

      // supposed to be remote url
      if (href && href.charAt(0) !== '#') {
        panel.loadWithSpinner(href);
      }

      tabs.removeClass(activeClass).attr({
        'aria-selected': false,
        'tabindex': -1 // just the active one is able to tabbed
      });
      panels.removeClass(activeClass).attr({
        'aria-hidden': true
      });

      tab.addClass(activeClass).attr({
        'aria-selected': true,
        'tabindex': 0 // just the active one is able to tabbed
      });
      panel.addClass(activeClass).attr({
        'aria-hidden': false
      });

      if (!noFocus) {
        tab.trigger('focus');
      }
    }, // _activateTab

    // add the switching functionality
    /** @ignore */
    _initTabswitch: function () {
      var self = this,
        sel = '> .coral-TabPanel-navigation > .coral-TabPanel-tab[data-toggle="tab"]';

      this.$element.on('click', sel,function (event) {
        var tab = $(event.currentTarget);

        // prevent the default anchor
        event.preventDefault();

        self._activateTab(tab);
      });
    }, // _initTabswitch

    // adds some accessibility attributes and features
    // http://www.w3.org/WAI/PF/aria-practices/#tabpanel
    /** @ignore */
    _makeAccessible: function () {
      this._makeTabsAccessible();
      this._makeTablistAccessible();
    }, // _makeAccessible

    /**
     * Adds accessibility attributes and features for the tabs.
     * @private
     * @ignore
     */
    _makeTabsAccessible: function($tabs) {
      var $panels = this._getPanels();
      $tabs = $tabs || this._getTabs();

      // set tab props
      $tabs.each(function (i, e) {
        var $tab = $(e),
          $panel = $panels.eq($tab.index()),
          id = $panel.attr('id') || CUI.util.getNextId();

        var tabAttrs = {
          'role': 'tab',
          'tabindex': -1,
          'aria-selected': false,
          'aria-controls': id,
          'aria-disabled': $tab.hasClass('is-disabled')
        };

        if (!$tab.attr('href')) {
          // Mainly so the cursor turns the mouse into a hand
          // on hover.
          tabAttrs.href = '#';
        }

        $tab.attr(tabAttrs);

        $panel.attr({
          'id': id,
          'role': 'tabpanel',
          'aria-hidden': true
        });
      });
    },

    /**
     * Adds accessibility attributes and features for the tab list.
     * @private
     * @ignore
     */
    _makeTablistAccessible: function() {
      // init the key handling for tabs
      var self = this,
          tabSelector = '> [role="tab"]';

      // the nav around the tabs has a tablist role
      this.tablist.attr('role', 'tablist');

      // keyboard handling
      this.tablist.on('keydown', tabSelector, function (event) {
        // enables keyboard support

        var elem = $(event.currentTarget),
          tabs = $(event.delegateTarget)
            .find(tabSelector)
            .not('[aria-disabled="true"]'), // ignore disabled tabs
          focusElem = elem,
          keymatch = true,
          idx = tabs.index(elem);

        switch (event.which) {
          case 33: //page up
          case 37: //left arrow
          case 38: //up arrow
            focusElem = idx - 1 > -1 ? tabs[idx - 1] : tabs[tabs.length - 1];
            break;
          case 34: //page down
          case 39: //right arrow
          case 40: //down arrow
            focusElem = idx + 1 < tabs.length ? tabs[idx + 1] : tabs[0];
            break;
          case 36: //home
            focusElem = tabs[0];
            break;
          case 35: //end
            focusElem = tabs[tabs.length - 1];
            break;
          default:
            keymatch = false;
            break;
        }

        if (keymatch) { // if a key matched then we set the currently focused element
          event.preventDefault();
          self._activateTab($(focusElem));
        }
      });
    }
  });

  CUI.Widget.registry.register("tabs", CUI.Tabs);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.Tabs.init($('[data-init~=tabs]', event.target));
    });
  }

}(jQuery, this));

(function ($, window, undefined) {
  CUI.TagList = new Class(/** @lends CUI.TagList# */{
    toString: 'TagList',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc A tag list for input widgets. This widget is intended to be used by other widgets.
     * @description Creates a new tag list
     * @constructs
     *
     * @param  {Object} options Component options
     * @param  {Mixed} options.element jQuery selector or DOM element to use for taglist container
     * @param  {String} options.fieldname fieldname for the input fields
     * @param  {Array} options.values to set the taglist
     * @param  {Boolean} [options.multiline=false] defines if newly created tags are multiline elements
     * @param  {CUI.TagList~rendererCallback} [options.renderer] a custom
     + renderer to use for rendering tags.
     *
     * @fires TagList#itemadded
     * @fires TagList#itemremoved
     *
     */
    construct: function (options) {
      var self = this;

      this.applyOptions();

      this.$element
        .on('change:values', this._setValues.bind(this));

      // Convert to using js-* class when we can break backward-compatibility
      this.$element.on('click', 'button', function (event) {
        var elem = self.$element
            .children()
            .has(event.currentTarget)
            .find('input');

        self.removeItem(elem.val());
      });

      // accessibility
      this._makeAccessible();
    },

    defaults: {
      fieldname: "",
      values: null,
      tag: 'li',
      renderer: null
    },

    /**
     * existing values in the tag list
     * @private
     * @type {Array}
     */
    _existingValues: null,

    applyOptions: function () {
      var self = this;

      this._existingValues = [];

      this.options.values = this.options.values || [];

      // set values if given
      if (this.options.values.length > 0) {
        this._setValues();
      } else { // read from markup
        this.$element.find('input').each(function (i, e) {
          var elem = $(e);

          // add to options.values
          self._existingValues.push(elem.attr('value'));
        });
      }
    },

    /**
     * @private
     */
    _setValues: function () {
      var items = this.options.values;

      // remove list elements
      this.$element.empty();

      // clear options to readd
      this.options.values = [];
      // add elements again
      this.addItem(items);
    },

    /**
     * adds some accessibility attributes and features
     * http://www.w3.org/WAI/PF/aria/roles#list
     * @private
     */
    _makeAccessible: function () {
      var self = this;
      this.$element.attr({
        'role': 'listbox'
      });

      this.$element.children(this.options.tag)
        .attr({
          'role': 'option',
          'tabindex': 0
        })
        .on('keydown', this._onKeyDown.bind(this))
        .children('.coral-TagList-tag-removeButton')
          .attr({
            'tabindex': -1
          });
    },

    /** @private */
    _onKeyDown: function(event) {
      // backspace key
      if(event.which === 8) {
        event.preventDefault();
        event.stopPropagation();

        // gets the next item before it gets removed
        var itemToFocus = $(event.currentTarget).next();

        if (itemToFocus.length === 0) {
          itemToFocus = $(event.currentTarget).prev();
        }

        this.removeItem($(event.currentTarget).children('input').val());

        itemToFocus.focus();
      }
    },

    /**
     * @private
     */
    _show: function () {
      this.$element
        .show()
        .attr('aria-hidden', false);
    },

    /**
     * @private
     */
    _hide: function () {
      this.$element
        .hide()
        .attr('aria-hidden', true);
    },

    /**
     * remove an item from the DOM
     * @private
     * @param  {String} item
     */
    _removeItem: function (item) {
      var elem = this.$element.children(':has(input[value="' + item + '"])');

      if (elem.length > 0) {
        elem.remove();

        this.$element.trigger($.Event('itemremoved'), {
          value: item
        });
      }
    },

    /**
     * adds a new item to the DOM
     * @private
     * @param  {String|Object} item entry to be displayed
     */
    _appendItem: function (item) {
      var display, val;

      // see if string or object
      if ($.type(item) === "string") {
        display = val = item;
      } else {
        display = item.display;
        val = item.value;
      }

      // always be a string
      val += "";

      if (($.inArray(val, this._existingValues) > -1) || val.length === 0) {
        return;
      }

      // add to internal storage
      this._existingValues.push(val); // store as string

      var renderer = this.options.renderer || this._renderTag;
      var $itemElement = $(renderer.call(this, val, display));
      $itemElement.on('keydown', this._onKeyDown.bind(this));
      this.$element.append($itemElement);

      this.$element.trigger($.Event('itemadded'), {
        value: val,
        display: display
      });
    },

    /**
     * Renders a tag for a given item.
     * @see CUI.TagList~rendererCallback
     * @private
     */
    _renderTag: function(value, display) {
      var elem, btn;

      // add DOM element
      elem = $('<' + this.options.tag + '/>', {
        'role': 'option',
        'tabindex': '0',
        'class': 'coral-TagList-tag' + (this.options.multiline ? ' coral-TagList-tag--multiline' : ''),
        'title': display
      });

      btn = $('<button/>', {
        'class': 'coral-MinimalButton coral-TagList-tag-removeButton',
        'type': 'button',
        'tabindex': '-1',
        'title': 'Remove'
      }).appendTo(elem);

      $('<i/>', {
        'class': 'coral-Icon coral-Icon--sizeXS coral-Icon--close'
      }).appendTo(btn);

      $('<span/>', {
        'class': 'coral-TagList-tag-label',
        'text': display
      }).appendTo(elem);

      $('<input/>', {
        'type': 'hidden',
        'value': value,
        'name': this.options.fieldname
      }).appendTo(elem);

      return elem;
    },

    /**
     * @param {String} item value to be deleted
     */
    removeItem: function (item) {
      var idx = this._existingValues.indexOf("" + item);

      if (idx > -1) {
        this._existingValues.splice(idx, 1);
        this._removeItem(item);
      }
    },

    /**
     * @param  {String|Object|Array} item
     * @param  {String} item.display
     * @param  {String} item.value
     */
    addItem: function (item) {
      var self = this,
        items = $.isArray(item) ? item : [item];

      $.each(items, function (i, item) {
        self._appendItem(item);
      });
    },

    getValues: function () {
      return this._existingValues.slice(0);
    }
  });

  CUI.Widget.registry.register("taglist", CUI.TagList);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.TagList.init($('[data-init~=taglist]', event.target));
    });
  }

  /**
   * Triggered when an item was added
   *
   * @name CUI.TagList#itemadded
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.value value which was added
   * @param {String} event.display displayed text of the element
   */

  /**
   * Triggered when an item was removed
   *
   * @name CUI.TagList#itemremoved
   * @event
   *
   * @param {Object} event Event object
   * @param {String} event.value value which was removed
   */

  /**
   * Callback used to render a tag. If a child of the returned tag is a button,
   * it will be used to remove the tag. The returned tag element should also
   * contain a hidden input with a value that matches the <code>value</code>
   * argument.
   *
   * @callback CUI.TagList~rendererCallback
   * @param {String} value The underlying value for the item.
   * @param {*} display Represents what should be displayed for the item.
   * @return {String|HTMLElement|jQuery} The constructed element to use
   * as a tag.
   */

}(jQuery, this));

(function ($) {
  CUI.Tooltip = new Class(/** @lends CUI.Tooltip# */{
    toString: 'Tooltip',

    extend: CUI.Widget,
    /**
     @extends CUI.Widget
     @classdesc A tooltip that can be attached to any other element and may be displayed immediately, on mouse over or only on API call.

     @desc Creates a new tooltip.
     @constructs

     @param {Object} options                       Component options
     @param {Mixed} [options.element]              jQuery selector or DOM element to use for tooltip.
     @param {Mixed} options.target                 jQuery selector or DOM element the tooltip is attached to
     @param {String} [options.content]             Content of the tooltip (HTML)
     @param {String} [options.type=info]           Type of dialog to display. One of info, error, notice, success, or inspect
     @param {String} [options.arrow=left]          Where to place the arrow? One of left, right, top or bottom.
     @param {Integer} [options.delay=500]          Delay before an interactive tooltip is shown.
     @param {Integer} [options.distance=5]         Additional distance of tooltip from element.
     @param {Boolean} [options.visible=true]       True to display immediately, False to defer display until show() called
     @param {Boolean} [options.interactive=false]  True to display tooltip on mouse over, False to only show/hide it when show()/hide() is called manually
     @param {Boolean} [options.autoDestroy=false]  Automatically destroy tooltip on hide?
     */
    construct: function (options) {
      // Ensure we have an object, not only a selector
      if (this.options.target) this.options.target = $(this.options.target);

      if (this.$element.length === 0 && this.options.target) {
        // Special case: We do not have a element yet, but a target
        // -> let us create our own element
        this.$element = $("<div>");
        this.$element.insertAfter(this.options.target);
      }

      // Add coral-Tooltip class to give styling
      this.$element.addClass('coral-Tooltip');

      if (this.$element.data("interactive")) {
        this.options.interactive = true;
        if (!this.options.target) this.options.target = this.$element.parent();
      }

      if (this.$element.data("target")) {
        this.options.target = $(this.$element.data("target"));
      }

      if (!this.options.arrow) {
        this.options.arrow = "left"; // set some default
        if (this.$element.hasClass("coral-Tooltip--positionRight")) this.options.arrow = "left";
        if (this.$element.hasClass("coral-Tooltip--positionLeft")) this.options.arrow = "right";
        if (this.$element.hasClass("coral-Tooltip--positionBelow")) this.options.arrow = "top";
        if (this.$element.hasClass("coral-Tooltip--positionAbove")) this.options.arrow = "bottom";
      }

      if (!this.options.type) {
        this.options.type = "info"; // set some default
        if (this.$element.hasClass("coral-Tooltip--info")) this.options.type = "info";
        if (this.$element.hasClass("coral-Tooltip--error")) this.options.type = "error";
        if (this.$element.hasClass("coral-Tooltip--success")) this.options.type = "success";
        if (this.$element.hasClass("coral-Tooltip--notice")) this.options.type = "notice";
        if (this.$element.hasClass("coral-Tooltip--inspect")) this.options.type = "inspect";
      }

      // Interactive Tooltips are never visible by default!
      if (this.options.interactive) {
        this.options.visible = false;
      }

      this.$element.toggleClass("is-hidden", !this.options.visible);


      // Listen to changes to configuration
      this.$element.on('change:content', this._setContent.bind(this));
      this.$element.on('change:type', this._setType.bind(this));
      this.$element.on('change:arrow', this._setArrow.bind(this));

      this.applyOptions();
      this.reposition();
      this._makeAccessible();

      if (this.options.target) {
          this.options.target.data("tooltip", this);
      }

      if (this.options.interactive && this.options.target) {
        var hto = null;
        // Special behaviour on mobile: show tooltip on every touchstart
        $(this.options.target).on("touchstart.cui-tooltip", function (event) {
          if (hto) clearTimeout(hto);
          this.show();
          hto = setTimeout(function () {
            this.hide();
          }.bind(this), 3000); // Hide after 3 seconds
        }.bind(this));

        var showTimeout = false;

//a11y--> focusin and focusout events added for accessibility support
//a11y--> Added aria-hidden =true/false based on the tooltip visibility

        $(this.options.target).on("mouseover.cui-tooltip focusin.cui-tooltip", function (event) {
          if (showTimeout) clearTimeout(showTimeout);
          showTimeout = setTimeout(function () {
            this.show();
            this.$element.attr("aria-hidden","false");
          }.bind(this), this.options.delay);
        }.bind(this));

        $(this.options.target).on("focusout.cui-tooltip", function (event) {
          if (showTimeout) clearTimeout(showTimeout);
          this.hide();
          this.$element.attr("aria-hidden","true");
        }.bind(this));

        $(this.options.target).on("mouseout.cui-tooltip", function (event) {
         if (!$(document.activeElement).is(this.options.target)){
          if (showTimeout) clearTimeout(showTimeout);
          this.hide();
          this.$element.attr("aria-hidden","true");
         }
        }.bind(this));
      }
    },

    _makeAccessible: function () {
      //a11y--Adding aria role=tooltip and id for all tooltips
      this.$element.attr({
        'role': "tooltip",
        'id': this.$element.attr('id') || CUI.util.getNextId()
        });
      //a11y--Adding aria-describedby
      if (this.options.target) {
        this.options.target.attr("aria-describedby", this.$element.attr("id"));
      }
      //a11y--Adding aria-label if target html is empty
      if ($(this.options.target).is(':empty')){
        $(this.options.target).attr("aria-label",this.options.content);
      }
    },

    defaults: {
      target: null,
      visible: true,
      type: null,
      interactive: false,
      arrow: null,
      delay: 500,
      distance: 5
    },

    _stylesTypes: {
      'info': 'coral-Tooltip--info',
      'error': 'coral-Tooltip--error',
      'notice': 'coral-Tooltip--notice',
      'success': 'coral-Tooltip--success',
      'inspect': 'coral-Tooltip--inspect'
    },

    _arrows: {
      'left': 'coral-Tooltip--positionRight',
      'right': 'coral-Tooltip--positionLeft',
      'top': 'coral-Tooltip--positionBelow',
      'bottom': 'coral-Tooltip--positionAbove'
    },

    applyOptions: function () {
      this._setContent();
      this._setType();
      this._setArrow();
    },

    /** @ignore */
    _setType: function () {
      if (typeof this.options.type !== 'string' || !this._stylesTypes.hasOwnProperty(this.options.type)) return;

      // Remove old type
      var classesNames = this._stylesTypes['info'] + ' ' +
                        this._stylesTypes['error'] + ' ' +
                        this._stylesTypes['notice'] + ' ' +
                        this._stylesTypes['success'] + ' ' +
                        this._stylesTypes['inspect'];

      this.$element.removeClass(classesNames);

      // Add new type
      this.$element.addClass(this._stylesTypes[this.options.type]);

      // Re-positioning
      this.reposition();
    },

    /** @ignore */
    _setArrow: function () {

      if (typeof this.options.arrow !== 'string' || !this._arrows.hasOwnProperty(this.options.arrow)) return;

      // cleans any arrow classes
      this._removeAllArrows();

      // Add new type
      this.$element.addClass(this._arrows[this.options.arrow]);

      // Re-positioning
      this.reposition();
    },

    /** @ignore */
    _removeAllArrows: function() {
      // Remove old type
      var classesNames = this._arrows['left'] + ' ' +
                        this._arrows['right'] + ' ' +
                        this._arrows['top'] + ' ' +
                        this._arrows['bottom'];

      this.$element.removeClass(classesNames);
    },

    /** @ignore */
    _setContent: function () {
      if (typeof this.options.content !== 'string') return;

      this.$element.html(this.options.content);

      // Re-positioning
      this.reposition();
    },

    /** @ignore */
    _show: function () {
      if (this.$element.hasClass("is-hidden")) {
        this.$element.removeClass('is-hidden');
        this.$element.css("display", "none");
      }

      this.reposition();

      this.$element.fadeIn();

      $(document).on('keydown.cui-tooltip', function(event) {
          if (event.which === 27) {
              this._hide();
              event.preventDefault();
              event.stopPropagation();
          }
      }.bind(this));
    },

    /** @ignore */
    _hide: function () {
      this.$element.fadeOut(0, function () {
        if (this.options.autoDestroy) {
          this.$element.remove();
          $(this.options.target).off(".cui-tooltip");
          $(this.options.target).data("tooltip", null);
        }

        this.$element.addClass("is-hidden");

        $(document).off('keydown.cui-tooltip');
      }.bind(this));
      return this;
    },

    /**
     Place tooltip on page

     @returns {CUI.Tooltip} this, chainable
     */
    reposition: function () {
      // if not visible we don't bother trying to reposition
      if (!this.options.visible) return;

      if (!this.options.target) return;

      this.$element.detach().insertAfter(this.options.target);

      this.$element.css("display", "block");
      this.$element.css("position", "absolute");
      this.$element.css({top:'-9999px', left: '-9999px'});

      this._removeAllArrows();

      // defines the arrow width as a constant
      var ARROW_WIDTH = 7;

      var instructions = this._instructionFactory[this.options.arrow]({
        target: this.options.target,
        offset: this.options.distance + ARROW_WIDTH,
        callback: this._applyFinalPosition.bind(this),
        within: this.options.within || window
      });

      this.$element.position(instructions);

      return this;
    },

    /**
     * Applies the final position to the tooltip
     * @param position
     *    The position to be applied to the bubble.
     * @param feedback
     *    Additional information useful for positioning the tail.
     * @private
     */
    _applyFinalPosition: function(position, positionFeedback) {

      this.$element.css({
        top: position.top,
        left: position.left
      });

      var tailClass;
      switch (this.options.arrow) {
        case 'top': // Consumer wanted tooltip above target
        case 'bottom': // Consumer wanted tooltip below target
          if (positionFeedback.vertical == 'bottom') { // Tooltip ended up above the target
            tailClass = 'coral-Tooltip--positionAbove';
          } else { // Tooltip ended up below the target
            tailClass = 'coral-Tooltip--positionBelow';
          }
          break;
        case 'left': // Consumer wanted tooltip to the left of the target
        case 'right': // Consumer wanted tooltip to the right of the target
          if (positionFeedback.horizontal == 'left') { // Tooltip ended up on the right side of the target
            tailClass = 'coral-Tooltip--positionRight';
          } else { // Tooltip ended up on the left side of the target
            tailClass = 'coral-Tooltip--positionLeft';
          }
          break;
      }

      // removes all possible arrows
      this._removeAllArrows();

      // adds the new arrow class that matches the position
      this.$element.addClass(tailClass);
    },

    _instructionFactory: {
      top: function(options) {
        return {
          my: 'center top+' + options.offset,
          at: 'center bottom',
          of: options.target,
          collision: 'flipfit flipfit',
          using: options.callback,
          within: options.within
        };
      },
      right: function(options) {
        return {
          my: 'right-' + options.offset + ' center',
          at: 'left center',
          of: options.target,
          collision: 'flipfit flipfit',
          using: options.callback,
          within: options.within
        };
      },
      bottom: function(options) {
        return {
          my: 'center bottom-' + options.offset,
          at: 'center top',
          of: options.target,
          collision: 'flipfit flipfit',
          using: options.callback,
          within: options.within
        };
      },
      left: function(options) {
        return {
          my: 'left+' + options.offset + ' center',
          at: 'right center',
          of: options.target,
          collision: 'flipfit flipfit',
          using: options.callback,
          within: options.within
        };
      }
    },
  });

  CUI.Widget.registry.register("tooltip", CUI.Tooltip);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      // Only initialize non-interactive tooltips this way!
      CUI.Tooltip.init($("[data-init~=tooltip]", e.target));
      //ally---Only those empty quicktips without any label or alternate text associations are assigned aria-label
      $('[data-init~=quicktip][data-quicktip-content]:empty')
        .not('[aria-label], [aria-labelledby], img[alt], input, select, textarea, button').each(function(i, elem) {
        var $e = $(elem);
        if ($e.closest('label').length === 1 || ($e.attr('id') && $('label[for="'+ $e.attr('id') +'"]').length > 0)) return;
        $e.attr('aria-label', $e.attr('data-quicktip-content'));
      });
      $('[data-init~=quicktip]').not('input, select, textarea, button').not(':tabbable').attr('tabindex', 0);
    });

    $(document).on("touchstart mouseover focusin", "[data-init~=quicktip]", function (e) {
      var el = $(this),
          tooltip = el.data("tooltip"),
          quicktip,
          hideQuicktip = function(qt) {
            qt.hide();
            //ally--Removing aria-describedby after tooltip is removed
            el.removeAttr("aria-describedby");
            el.off("mouseout.cui-quicktip focusout.cui-quicktip");
            $(window).off("keydown.cui-tooltip mousedown.cui-tooltip");
          };

      if (!tooltip) {
        quicktip = new CUI.Tooltip({
          target: el,
          content: el.data("quicktip-content") || el.html(),
          type: el.data("quicktip-type"),
          arrow: el.data("quicktip-arrow"),
          interactive: false,
          autoDestroy: true,
          visible: false
        }).show();

        // Store a reference to the instance on the trigger element
        // This is required for testing so we can call methods
        el.data('quicktip', quicktip);

        switch(e.type) {
          case 'mouseover':
          case 'focusin':
            if (e.type === 'mouseover') {
              el.on("mouseout.cui-quicktip", function () {
                if (!$(document.activeElement).is(el)) {
                  hideQuicktip(quicktip);
                }
              });
            } else {
              el.on("focusout.cui-quicktip", function () {
                hideQuicktip(quicktip);
              });
            }
            $(window).on("keydown.cui-tooltip", function(event) {
              if (event.which === 27) {
                  hideQuicktip(quicktip);
                  event.preventDefault();
              }
            }).on("mousedown.cui-tooltip", function(event) {
              if (!el.is(event.target) && !quicktip.$element.is(event.target)) {
                  hideQuicktip(quicktip);
              }
            });
            break;
          default:
            setTimeout(function() {
              hideQuicktip(quicktip);
            }, 3000);
        }
      }
    });
  }
}(window.jQuery));

/*
 ADOBE CONFIDENTIAL

 Copyright 2013 Adobe Systems Incorporated
 All Rights Reserved.

 NOTICE:  All information contained herein is, and remains
 the property of Adobe Systems Incorporated and its suppliers,
 if any.  The intellectual and technical concepts contained
 herein are proprietary to Adobe Systems Incorporated and its
 suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from Adobe Systems Incorporated.
 */
(function ($) {
  function cloneLeft(buttons) {
    return buttons.filter("[data-action=prev], [data-action=cancel]").first().addClass("u-coral-hidden")
      .clone(true).addClass("coral-Wizard-backButton").each(processButton);
  }

  function cloneRight(buttons) {
    return buttons.filter("[data-action=next]").first().addClass("u-coral-hidden")
      .clone(true).addClass("coral-Button--primary coral-Wizard-nextButton").each(processButton);
  }

  function cloneCancel(buttons) {
    return buttons.filter("[data-action=cancel]").first()
      .clone(true).addClass("coral-Button--quiet coral-Wizard-nextButton").each(processButton);
  }

  function processButton(i, el) {
    $(el).removeClass("u-coral-hidden").addClass("coral-Button");
  }

  function buildNav(wizard, sections) {
    var nav = wizard.children(".js-coral-Wizard-nav");

    if (nav.length === 0) {
      wizard.prepend(function () {
        nav = $(
          "<nav class=\"js-coral-Wizard-nav coral-Wizard-nav coral--dark coral-Background coral-Text\">" +
            "<ol class=\"coral-Wizard-steplist\"></ol>" +
          "</nav>");
        var ol = nav.children("ol");

        sections.map(function () {
          return $("<li class=\"js-coral-Wizard-steplist-item coral-Wizard-steplist-item\"></li>").
                      text($(this).data("stepTitle") || this.title).get(0);
        }).appendTo(ol);

        return nav;
      });
    }

    if (!nav.hasClass('coral--light')) {
      nav.addClass("coral--dark");
    }

    nav.find(".js-coral-Wizard-steplist-item:first").addClass("is-active");

    var buttons = sections.first().find(".js-coral-Wizard-step-control");

    nav.prepend(function () {
      return cloneLeft(buttons);
    }).append(function () {
      return cloneRight(buttons).add(cloneCancel(buttons).toggleClass("u-coral-hidden", true));
    });
  }

  function insertAfter(wizard, step, refStep) {
    var index = wizard.children(".js-coral-Wizard-step").index(refStep),
        refNavStep = wizard.children(".js-coral-Wizard-nav").find(".js-coral-Wizard-steplist-item").eq(index),
        navStep = refNavStep.clone().text(step.data("stepTitle") || step.attr("title")).removeClass("is-active is-stepped");

    hideStep(step);

    refNavStep.after(navStep);
    refStep.after(step);
  }

  function showNav(to) {
    if (to.length === 0) return;

    to.addClass("is-active").removeClass("is-stepped");

    to.prevAll(".js-coral-Wizard-steplist-item").addClass("is-stepped").removeClass("is-active");
    to.nextAll(".js-coral-Wizard-steplist-item").removeClass("is-active is-stepped");
  }

  function hideStep(step) {
    if (step && step.length) {
      step.addClass("u-coral-hidden");
    }
  }

  function showStep(step) {
    if (step && step.length) {
      step.removeClass("u-coral-hidden");
    }
  }

  function changeStep(wizard, to, from) {
    if (to.length === 0) return;

    hideStep(from);
    showStep(to);

    wizard.trigger("flexwizard-stepchange", [to, from]);
  }

  function controlWizard(wizard, action) {
    var nav = wizard.children(".js-coral-Wizard-nav");
    var from = wizard.children(".js-coral-Wizard-step:not(.u-coral-hidden)");
    var fromNav = nav.find(".js-coral-Wizard-steplist-item.is-active");

    var to, toNav;
    switch (action) {
      case "prev":
        to = from.prev(".js-coral-Wizard-step");
        toNav = fromNav.prev(".js-coral-Wizard-steplist-item");
        break;
      case "next":
        to = from.next(".js-coral-Wizard-step");
        toNav = fromNav.next(".js-coral-Wizard-steplist-item");
        break;
      case "cancel":
        return;
    }

    if (to.length === 0) return;

    var buttons = to.find(".js-coral-Wizard-step-control");

    cloneLeft(buttons).replaceAll(nav.children(".coral-Wizard-backButton"));
    cloneRight(buttons).replaceAll(nav.children(".coral-Wizard-nextButton:not([data-action=cancel])"));

    nav.children(".coral-Wizard-nextButton[data-action=cancel]").toggleClass("u-coral-hidden", to.prev(".js-coral-Wizard-step").length === 0);

    showNav(toNav);
    changeStep(wizard, to, from);
  }

  CUI.FlexWizard = new Class(/** @lends CUI.FlexWizard# */{
    toString: "FlexWizard",

    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc Wizard component
     @desc Creates a new wizard
     @constructs
     */
    construct: function (options) {
      var wizard = this.$element,
          steps = wizard.find(".js-coral-Wizard-step");

      buildNav(wizard, steps);

      wizard.on("click", ".js-coral-Wizard-step-control", function (e) {
        controlWizard(wizard, $(this).data("action"));
      });

      hideStep(steps);
      changeStep(wizard, steps.first());
    },

    /**
     Goes to the previous step. If there is no previous step, this method does nothing.
     */
    prevStep: function() {
      controlWizard(this.$element, "prev");
    },

    /**
     Goes to the next step. If there is no next step, this method does nothing.
     */
    nextStep: function() {
      controlWizard(this.$element, "next");
    },

    /**
     Adds the given step to the wizard.

     @param {HTMLElement|jQuery|String} step The step to be added
     @param {Number} [index] The index the step is added. If not passed, the step is added as the last one
     */
    add: function (step, index) {
      var wizard = this.$element;

      if (index === undefined) {
        this.addAfter(step, wizard.children(".js-coral-Wizard-step").last());
        return;
      }

      if (!step.jquery) {
        step = $(step);
      }

      step.addClass("js-coral-Wizard-step");
      insertAfter(wizard, step, wizard.children(".js-coral-Wizard-step").eq(index));
    },

    /**
     Adds the given step after the given reference step.

     @param {HTMLElement|jQuery|String} step The step to be added
     @param {HTMLElement|jQuery} refStep The reference step
     */
    addAfter: function (step, refStep) {
      var wizard = this.$element;

      if (!step.jquery) {
        step = $(step);
      }

      if (!refStep.jquery) {
        refStep = $(refStep);
      }

      step.addClass("js-coral-Wizard-step");
      insertAfter(wizard, step, refStep);
    },

    /**
     Removes the given step from the wizard. The step is detached from the
     DOM and returned. If the current step is removed, the resulting
     behaviour is undefined.

     @param {HTMLElement|jQuery} step The step to be removed
     @returns {jQuery} The removed step (as it was passed to the function)
     */
    remove: function(step) {
      var wizard = this.$element;
      var $step = step.jquery ? step : $(step);

      var index = wizard.children(".js-coral-Wizard-step").index($step);
      wizard.find(".js-coral-Wizard-steplist-item").eq(index).remove();
      $step.detach();

      return step;
    }
  });

  CUI.Widget.registry.register("flexwizard", CUI.FlexWizard);

  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      CUI.FlexWizard.init($("[data-init~=flexwizard]", e.target));
    });
  }
}(window.jQuery));

(function ($, window, undefined) {

  CUI.Modal = new Class(/** @lends CUI.Modal# */{
    toString: 'Modal',

    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc A dialog that prevents interaction with page elements while displayed.

     @desc Creates a new modal dialog.
     @constructs
     @param {Object} options Component options
     @param {Mixed} options.element jQuery selector or DOM element to use for dialog
     @param {String} options.header Title of the modal dialog (HTML)
     @param {String} options.content Title of the modal dialog (HTML)
     @param {String} [options.type=default] Type of dialog to display. One of default, error, notice, success, help, or info
     @param {Array} [options.buttons] Array of button descriptors
     @param {String} [options.buttons.label] Button label (HTML)
     @param {String} [options.buttons.className] CSS class name to apply to the button
     @param {Mixed} [options.buttons.click] Click handler function or string 'hide' to hide the dialog
     @param {String} [options.remote] URL to asynchronously load content from the first time the modal is shown
     @param {Mixed} [options.backdrop=static] False to not display transparent underlay, True to display and close when clicked, 'static' to display and not close when clicked
     @param {Mixed} [options.visible=true] True to display immediately, False to defer display until show() called

     */
    construct: function (options) {

      // modal parts
      this.header = this.$element.find('.coral-Modal-header');
      this.body = this.$element.find('.coral-Modal-body');
      this.footer = this.$element.find('.coral-Modal-footer');

      // previous focus element
      this._previousFocus = $();

      // creates a backdrop object
      // but it does not attach it to the document
      this.backdrop = $('<div/>', {
        'class': 'coral-Modal-backdrop',
        'style': 'display: none;'
      }).on('click', function (event) {
          if (this.options.backdrop !== 'static') {
            this.hide();
          }
        }.bind(this));

      // Fetch content asynchronously, if remote is defined
      this.body.loadWithSpinner(this.options.remote);

      this.applyOptions();

      this.$element.on('change:heading', this._setHeading.bind(this)) // @deprecated
        .on('change:header', this._setHeader.bind(this))
        .on('change:content', this._setContent.bind(this))
        .on('change:buttons', this._setFooter.bind(this))
        .on('change:type', this._setType.bind(this))
        .on('change:fullscreen', this._setFullscreen.bind(this))

        // close when a click was fired on a close trigger (e.g. button)
        .on('click', '[data-dismiss="modal"]', this.hide.bind(this));

      this._makeAccessible();
    },

    defaults: {
      backdrop: 'static',
      visible: true,
      type: 'default',
      fullscreen: false,
      attachToBody: true
    },

    _types: {
      "default": { "class": '', "iconClass": ""},
      "error": { "class": 'coral-Modal--error', "iconClass": "coral-Icon--alert"},
      "notice": { "class": 'coral-Modal--notice', "iconClass": "coral-Icon--alert"},
      "success": { "class": 'coral-Modal--success', "iconClass": "coral-Icon--checkCircle"},
      "help": { "class": 'coral-Modal--help', "iconClass": "coral-Icon--helpCircle"},
      "info": { "class": 'coral-Modal--info', "iconClass": "coral-Icon--infoCircle"}
    },

    applyOptions: function () {
      this._setHeader();
      this._setHeading();  // @deprecated
      this._setContent();
      this._setFooter();
      this._setType();
      this._setFullscreen();

      if (this.options.visible) {
        // Show immediately
        this.options.visible = false;
        this.show();
      }
    },

    /**
     adds some accessibility attributes and features
     http://www.w3.org/WAI/PF/aria-practices/#dialog_modal
     @private
     */
    _makeAccessible: function () {
      var self = this,
        idPrefix = 'modal-header' + new Date().getTime() + '-';

      // the element has the role dialog
      this.$element.attr({
        'role': 'dialog',
        'aria-hidden': !this.options.visible,
        'aria-labelledby': idPrefix + 'label',
        'aria-describedby': idPrefix + 'message',
        'tabindex': -1
      });

      this.header.find('h2').attr({
        'id': idPrefix + 'label',
        'tabindex': 0
      });

      // Message areas have role document and tabindex="0"
      this.body.attr({
        'id': idPrefix + 'message',
        'role': 'document',
        'tabindex': 0
      });

      // keyboard handling
      this.$element.on('keydown', ':focusable', function (event) {
        // enables keyboard support

        var elem = $(event.currentTarget),
          tabbables = self.$element.find(':tabbable'),
          focusElem;

        switch (event.which) {
          case 9: //tab
            if (event.shiftKey && event.currentTarget === tabbables[0]) {
              // in case it is the first one, we switch to the last one
              focusElem = tabbables.last();
            } else if (!event.shiftKey && event.currentTarget === tabbables[tabbables.length - 1]) {
              // in case it is the last one, we switch to the first one
              focusElem = tabbables.first();
            }
            break;
        }

        if (focusElem) { // if a key matched then we set the currently focused element
          event.preventDefault();
          focusElem.trigger('focus');
        }
      });
    },

    /**
     sets the type of the modal
     @private
     */
    _setType: function () {
      if (this.options.type) {

        var icon = this.$element.find('.coral-Modal-header > .coral-Icon');
        // Remove old type
        for (var typeKey in this._types) {
          this.$element.removeClass(this._types[typeKey]["class"]);
          icon.removeClass(this._types[typeKey]["iconClass"]);
        }
        // Add new type
        if (this.options.type !== 'default') {
          this.$element.addClass(this._types[this.options.type]["class"]);
          icon.addClass(this._types[this.options.type]["iconClass"]);
        }
      }
    },

    /**
     sets the header of the modal
     @private
     */
    _setHeader: function () {
      if (!this.options.header) {
        return;
      }

      this.header.find('h2').html(this.options.header);
    },

    /**
     @deprecated rather use #_setHeader
     @private
     */
    _setHeading: function () {
      if (!this.options.heading) {
        return;
      }

      this.options.header = this.options.heading;
      this._setHeader.apply(this, arguments);
    },

    /**
     sets the content of the modal body
     @private
     */
    _setContent: function () {
      if (!this.options.content) {
        return;
      }

      this.body.html(this.options.content);
    },

    /**
     sets the buttons into the footer from the config
     @private
     */
    _setFooter: function () {
      if (!$.isArray(this.options.buttons)) {
        return;
      }

      var self = this;

      // remove existing buttons
      this.footer.empty();

      $.each(this.options.buttons, function (idx, button) {
        // Create an anchor if href is provided
        var btn = button.href ? $('<a/>', {
          'class': 'button'
        }) : $('<button/>', {
          'class': 'coral-Button',
          'type': 'button'
        });

        // Add label
        btn.html(button.label);

        // attach event handler
        if (button.click === 'hide') {
          btn.attr('data-dismiss', 'modal');
        } else if ($.isFunction(button.click)) {
          btn.on('click', button.click.bind(self, {
            dialog: self
          }));
        }

        if (button.href) {
          btn.attr('href', button.href);
        }

        if (button.className) {
          btn.addClass(button.className);
        }

        self.footer.append(btn);
      });
    },

    /**
     sets the fullscreen css class
     @private
     */
    _setFullscreen: function () {
      if (this.options.fullscreen) {
        this.$element.addClass('fullscreen');
      } else {
        this.$element.removeClass('fullscreen');
      }

      // Remove margin
      this.$element.css({
        'margin-left': 0,
        'margin-top': 0
      });
    },

    /**
     @private
     @event beforeshow
     */
    _show: function () {
      var documentBody = $('body'),
        tabcapture,
        self = this;

      // ARIA: http://www.w3.org/WAI/PF/aria-practices/#dialog_modal
      // When the dialog is closed or cancelled focus should
      // return to the element in the application which had focus
      // before the dialog is invoked
      this._previousFocus = $(':focus'); //save previously focused element
      this._previousFocus.trigger('blur');

      documentBody.addClass('coral-Modal.is-open');

      // fire event before showing the modal
      this.$element.trigger('beforeshow');

      this._toggleBackdrop(true);

      // Move to the bottom of body so we're outside of any relative/absolute context
      // This allows us to know we'll always float above the backdrop

      // TODO: This doesn't actually work.  The z-index in the css saves the bacon...
      // Even though _toggleBackdrop is called before this append, the
      // backdrop gets appended to body before modal first time through
      // but is appended to body *after* the modal every time after

      if (this.options.attachToBody) {
        if (this.$element.parent('body').length === 0) {
          this.$element.appendTo(documentBody);
        }
        // ARIA
        // Hide sibling elements from assistive technologies,
        // but first store the state of any siblings already have the aria-hidden attribute
        this.$element.siblings('[aria-hidden]').each(function (index, element) {
          $(element).data('aria-hidden', $(element).attr('aria-hidden'));
        });
        this.$element.siblings().not('script, link, style').attr('aria-hidden', this.options.visible);
      }

      this.$element.attr('aria-hidden', !this.options.visible);

      // center before showing
      this.center();

      // fadeIn
      this.$element.fadeIn();

      // When a modal dialog opens focus goes to the first focusable item in the dialog
      this.$element.find(':tabbable:not(.coral-Modal-header .coral-Modal-closeButton):first').focus();

      // add tab-focusable divs to capture and forward focus to the modal dialog when page regains focus
      tabcapture = $('<div class="coral-Modal-tabcapture" tabindex="0"/>');
      tabcapture.on('focus.modal-tabcapture', function (event) {
        var tabbables = self.$element.find(':tabbable'),
          tabcaptures = $('body > .coral-Modal-tabcapture'),
          lasttabcapture = tabcaptures.last(),
          focusElem;

        if (event.currentTarget === lasttabcapture[0]) {
          focusElem = tabbables.filter(':not(.coral-Modal-header .coral-Modal-closeButton):last');
        } else {
          focusElem = tabbables.filter(':not(.coral-Modal-header .coral-Modal-closeButton):first');
        }

        if (focusElem.length === 0) {
          focusElem = self.$element;
        }

        focusElem.trigger('focus');
      })
      // this method chaining is super janky...
        .prependTo(documentBody)
        .clone(true)
        .appendTo(documentBody);

      // add escape handler
      $(document).on('keydown.modal-escape', this._escapeKeyHandler.bind(this));

      return this;
    },

    /**
     @private
     @event beforehide
     */
    _hide: function () {
      $('body').removeClass('coral-Modal.is-open')
        .find('.coral-Modal-tabcapture').off('focus.modal-tabcapture').remove();

      // remove escape handler
      $(document).off('keydown.modal-escape');

      // fire event before showing the modal
      this.$element.trigger('beforehide');

      this._toggleBackdrop(false);

      this.$element.attr('aria-hidden', !this.options.visible);

      this.$element.siblings()
        .removeAttr('aria-hidden')
        .filter(':data("aria-hidden")')
        .each(function (index, element) {
          $(element).attr('aria-hidden', $(element).data('aria-hidden'))
            .removeData('aria-hidden');
        });

      // fadeOut
      this.$element.fadeOut().trigger('blur');

      // ARIA: http://www.w3.org/WAI/PF/aria-practices/#dialog_modal
      // When the dialog is closed or cancelled focus should
      // return to the element in the application which had focus
      // before the dialog is invoked
      this._previousFocus.trigger('focus');

      return this;
    },

    /**
     centers the modal in the middle of the screen
     @returns {CUI.Modal} this, chainable
     */
    center: function () {
      var width = this.$element.outerWidth(),
        height = this.$element.outerHeight();

      if (!this.options.fullscreen) {
        this.$element.css({
          'margin-left': -(width / 2),
          'margin-top': -(height / 2)
        });
      }
    },

    /**
     toggles back drop
     @private
     @param  {Boolean} [show] true/false to force state
     */
    _toggleBackdrop: function (show) {
      if (!this.options.backdrop) {
        return;
      }

      var documentBody = $('body');

      if ((show || this.backdrop.is(':hidden')) && show !== false) {
        this.backdrop.appendTo(documentBody).fadeIn();
      }
      else {
        this.backdrop.fadeOut(function () {
          $(this).detach();
        });
      }
    },

    /**
     handler to close the dialog on escape key
     @private
     */
    _escapeKeyHandler: function (event) {
      if (event.which === 27) {
        this.hide();
      }

    }
  });

  CUI.Widget.registry.register("modal", CUI.Modal);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (event) {
      CUI.Modal.init($('[data-init~=modal]', event.target));
    });

    // @deprecated
    // this differs from other components
    // rather in future we use data-init~="modal-trigger" to intialize a trigger
    // and require data-init~="modal" on the modal to indicate it is a modal
    $(document).on('click.modal.data-api', '[data-toggle="modal"]',function (e) {
      // Stop links from navigating
      // Always do preventDefault first, otherwise when exception occurs in the handler, it is not called
      e.preventDefault();

      var $trigger = $(this);

      // Get the target from data attributes
      var $target = CUI.util.getDataTarget($trigger);

      // Pass configuration based on data attributes in the triggering link
      var href = $trigger.attr('href');
      var options = $.extend({ remote: !/#/.test(href) && href }, $target.data(), $trigger.data());

      // If the trigger does not have focus,
      if (!$trigger.is(document.activeElement)) {
        // make sure that the trigger can accept focus,
        if (!$trigger.is(':focusable')) {
          $trigger.attr('tabindex', 0);
        }
        // then set focus to the trigger.
        // This will ensure that the modal can restore focus to the trigger when it is closed.
        $trigger.focus();
      }

      // Parse buttons
      if (typeof options.buttons === 'string') {
        options.buttons = JSON.parse(options.buttons);
      }

      // If a modal already exists, show it
      var instance = $target.data('modal');

      // Apply the options from the data attributes of the trigger
      // When the dialog is closed, focus on the button that triggered its display
      $target.modal(options);

      // Perform visibility toggle if we're not creating a new instance
      if (instance) {
        $target.data('modal').set({ visible: !instance.get('visible') });
      }
    });
  }

}(jQuery, this));

(function ($, window, undefined) {
  CUI.Slider = new Class(/** @lends CUI.Slider# */{
    toString: 'Slider',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @desc Creates a slider.
     * @constructs
     *
     * @param {Object} options Component options
     * @param {number} [options.step=1]  The steps to snap in
     * @param {number} [options.min=1]   Minimum value
     * @param {number} [options.max=100] Maximum value
     * @param {number} [options.value=1] Starting value
     * @param {number} [options.tooltips=false] Show tooltips?
     * @param {String} [options.orientation=horizontal]  Either 'horizontal' or 'vertical'
     * @param {boolean} [options.slide=false]    True for smooth sliding animations. Can make the slider unresponsive on some systems.
     * @param {boolean} [options.disabled=false] True for a disabled element
     * @param {boolean} [options.bound=false] For multi-input sliders, indicates that the min value is bounded by the max value and the max value is bounded by the min
     *
     */
    construct: function () {
      var self = this,
        elementId = this.$element.attr('id'),

        values = [];

      // reads the options from markup
      this._readOptions();

      // if the element doesn't have an id, build a unique id using CUI.util.getNextId()
      if (!elementId) {
        elementId = CUI.util.getNextId();
        this.$element.attr('id', elementId);
      }

      this._renderMissingElements();

      // get all input value fields
      this.$inputs = this.$element.find('input');

      this.$inputs.each(function (index, input) {
        var $input = $(input);

        // setting default step
        if (!$input.is('[step]')) $input.attr('step', self.options.step);

        // setting default min
        if (!$input.is('[min]')) $input.attr('min', self.options.min);

        // setting default max
        if (!$input.is('[max]')) $input.attr('max', self.options.max);

        // setting default value
        if (!$input.is('[value]')) {
          $input.attr({'value': self.options.value});
          values.push(self.options.value);
        } else {
          values.push($input.attr('value'));
        }

        if (index === 0) {
          if ($input.is(':disabled')) {
            self.options.disabled = true;
            self.$element.addClass('is-disabled');
          } else if (self.options.disabled) {
            $input.attr('disabled', 'disabled');
            self.$element.addClass('is-disabled');
          }
        }
      });

      self.values = values;
      if (this.options.orientation === 'vertical') this.isVertical = true;

      // Set up event handling
      this.$element
        .on('touchstart.slider pointerdown.slider mspointerdown.slider mousedown.slider', this._mouseDown.bind(this))
        .on('focusin.slider', 'input[type=range], [role=slider].coral-Slider-handle', this._focus.bind(this))
        .on('focusout.slider', 'input[type=range], [role=slider].coral-Slider-handle', this._blur.bind(this))
        .on('input.slider change.slider', 'input', this._handleInputChange.bind(this));

      // Listen to changes to configuration
      this.$element
        .on('change:value', this._processValueChanged.bind(this))
        .on('change:disabled', this._processDisabledChanged.bind(this))
        .on('change:min', this._processMinMaxStepChanged.bind(this))
        .on('change:max', this._processMinMaxStepChanged.bind(this))
        .on('change:step', this._processMinMaxStepChanged.bind(this));

      // Adjust dom to our needs
      this._render();

      // Initialize accessibility
      this._makeAccessible();
    }, // construct

    defaults: {
      step: '1',
      min: '1',
      max: '100',
      value: '1',
      orientation: 'horizontal',
      slide: false,
      disabled: false,
      tooltips: false,
      tooltipFormatter: function (value) {
        return value.toString();
      },
      valuetextFormatter: function (value) {
        return value.toString();
      },
      ticks: false,
      filled: false,
      bound: false
      // @todo [~mijordan] provide a mechanism for adding a legend and labels with JS Class Initialization
    },

    values: [],
    $inputs: null,
    $ticks: null,
    $fill: null,
    $handles: null,
    $tooltips: null,
    isVertical: false,
    draggingPosition: -1,
    _inputsOrHandles: null,

    /**
     * reads the options from the markup (classes)
     * TODO optimize
     * @private
     */
    _readOptions: function () {
      // setting default dom attributes if needed
      if (this.$element.hasClass('coral-Slider--vertical')) {
        this.options.orientation = 'vertical';
        this.isVertical = true;
      }

      if (this.$element.hasClass('coral-Slider--tooltips')) {
        this.options.tooltips = true;
      }

      if (this.$element.hasClass('coral-Slider--ticked')) {
        this.options.ticks = true;
      }

      if (this.$element.hasClass('coral-Slider--filled')) {
        this.options.filled = true;
      }

      if (this.$element.hasClass('coral-Slider--bound')) {
        this.options.bound = true;
      }

      if (this.$element.data('slide') || this.$element.hasClass('coral-Slider--slide')) {
        this.options.slide = true;
      }
    },

    /**
     * Set the current value of the slider
     * @param {int}   value   The new value for the slider
     * @param {int}   handleNumber   If the slider has 2 handles, you can specify which one to change, either 0 or 1
     */
    setValue: function (value, handleNumber) {
      handleNumber = handleNumber || 0;

      this._updateValue(handleNumber, value, true); // Do not trigger change event on programmatic value update!
      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
    },

    _renderMissingElements: function () {
      if (!this.$element.find('input').length) {
        var self = this,
          el,
          values = ($.isArray(this.options.value)) ? this.options.value : [this.options.value];
        $.each(values, function (index, value) {
          el = $('<input>');
          el.attr({
            'type': 'range',
            'min': self.options.min,
            'max': self.options.max,
            'step': self.options.step,
            'value': value
          });
          self.$element.append(el);
        });
      }

      if (!this.$element.find('div.coral-Slider-clickarea').length) {
        var el2 = $('<div class="coral-Slider-clickarea">');
        this.$element.prepend(el2); // Prepend: Must be first element to not hide handles!
      }

      // @todo This is not a missing element, so it's odd to have this method called as such
      this.$element.toggleClass('coral-Slider', true);
      this.$element.toggleClass('coral-Slider--vertical', this.options.orientation === 'vertical');
      this.$element.toggleClass('coral-Slider--tooltips', this.options.tooltips); // Not used in CSS
      this.$element.toggleClass('coral-Slider--ticked', this.options.ticks); // Not used in CSS
      this.$element.toggleClass('coral-Slider--filled', this.options.filled); // Not used in CSS
    },

    _processValueChanged: function () {
      var self = this,
        values = ($.isArray(this.options.value)) ? this.options.value : [this.options.value];
      $.each(values, function (index, value) {
        self._updateValue(index, value, true); // Do not trigger change event on programmatic value update!
      });
      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
    },

    _processMinMaxStepChanged: function () {
      var self = this,
          $inputs = this.$inputs;
      $inputs.attr({
        'min': this.options.min,
        'max': this.options.max,
        'step': this.options.step,
        'value': '' // removing the value attribute ensures that _updateValue call that follows actually does something
      });
      if (!this._supportsRangeInput) {
        this.$handles.attr({
          'aria-valuemin': this.options.min,
          'aria-valuemax': this.options.max,
          'aria-valuestep': this.options.step
        });
      }
      $.each(this.values, function (index, value) {
        self._updateValue(index, value, true); // Ensure current values are between min and max
      });

      if (this.options.ticks) {
        this.$element.find('.coral-Slider-ticks').remove();
        this._buildTicks();
      }

      if (this.options.filled) {
        this.$element.find('.coral-Slider-fill').remove();
        this._buildFill();
      }

      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
    },

    _processDisabledChanged: function () {
      if (this.options.disabled) {
        this.$inputs.attr('disabled', 'disabled');
        this.$handles.each(function () {
          // @todo always chain class or cache selectors
          $(this).removeClass('is-focused');
          $(this).parent().removeClass('is-focused');

          if (!this._supportsRangeInput) {
            $(this).attr('aria-disabled', true);
          }
        });
      } else {
        this.$inputs.removeAttr('disabled');
        if (!this._supportsRangeInput) {
          this.$handles.removeAttr('aria-disabled');
        }
      }
      this.$element.toggleClass('is-disabled', this.options.disabled);
    },

    _render: function () {
      var self = this,
          // get maximum max value
          maximums = self.$inputs.map(function () {
            return $(this).attr('max');
          }),
          // get minimum min value
          minimums = self.$inputs.map(function () {
            return $(this).attr('min');
          }),
          // get step step value
          steps = self.$inputs.map(function () {
            return $(this).attr('step');
          });

      self.options.max = Math.max.apply(null, maximums.toArray());
      self.options.min = Math.min.apply(null, minimums.toArray());
      self.options.step = Math.min.apply(null, steps.toArray());

      // Correct the labelling of inputs for accessibility
      this._adjustLabelling();

      // Todo: do not add already existing elements or remove them before adding new elements
      // build ticks if needed
      if (self.options.ticks) {
        self._buildTicks();
      }

      // build fill if needed
      if (self.options.filled) {
        self._buildFill();
      }

      // add css class so that slide animation is done through css transition rather than jQuery.animate
      self.$element.toggleClass('coral-Slider--slide', self.options.slide);

      self._buildHandles();
    },

    _buildTicks: function () {
      // The ticks holder
      var $ticks = $('<div/>').addClass('coral-Slider-ticks'),
          numberOfTicks = Math.round((this.options.max - this.options.min) / this.options.step) - 1,
          trackDimensions = this.isVertical ? this.$element.height() : this.$element.width();

      this.$element.prepend($ticks);
      for (var i = 0; i < numberOfTicks; i++) {
        var position = trackDimensions * (i + 1) / (numberOfTicks + 1),
            percent = (position / trackDimensions) * 100,
            tick = $('<div/>').addClass('coral-Slider-tick').css((this.isVertical ? 'bottom' : 'left'), percent + '%');
        $ticks.append(tick);
      }
      this.$ticks = $ticks.find('.coral-Slider-tick');
      if (this.options.filled) {
        // this._coverTicks();
      }
    },

    _buildFill: function () {
      var self = this;

      this.$fill = $('<div/>').addClass('coral-Slider-fill');

      if (self.values.length !== 0) {
        var percent, fillPercent,
          heightOrWidth = self.isVertical ? 'height' : 'width',
          bottomOrLeft = self.isVertical ? 'bottom' : 'left';
        if (self.values.length < 2) {
          percent = (self.values[0] - self.options.min) / (self.options.max - self.options.min) * 100;
          this.$fill.css(heightOrWidth, percent + '%');
        } else {
          percent = (this._getLowestValue() - self.options.min) / (self.options.max - self.options.min) * 100;
          fillPercent = (this._getHighestValue() - this._getLowestValue()) / (self.options.max - self.options.min) * 100;
          this.$fill.css(heightOrWidth, fillPercent + '%')
            .css(bottomOrLeft, percent + '%');
        }
      }
      this.$element.prepend(this.$fill);
      self.options.filled = true;
    },

    _buildHandles: function () {
      var self = this,
          elementId = self.$element.attr('id');

      // Wrap each input field and add handles and tooltips (if required)
      self.$inputs.each(function (index) {

        var $input = $(this),
            $wrap = $input.wrap('<div/>').parent().addClass('coral-Slider-value'),

            // Add handle for input field
            percent = (self.values[index] - self.options.min) / (self.options.max - self.options.min) * 100,
            percentString =  percent + '%',
            bottomOrLeft = self.isVertical ? 'bottom' : 'left',
            $handle = $('<div/>')
              .addClass('coral-Slider-handle u-coral-openHand')
              .css(bottomOrLeft, percentString)
              .attr({
                'id': elementId + '-handle' + index
              }),
            $tooltip;

        // position the input relative to the slider container element
        $input.css(bottomOrLeft, percentString);
        $wrap.append($handle);

        // Add tooltip to handle if required
        if (self.options.tooltips) {
          // @todo replace with correct classnames for coral-Tooltip-arrow**
          $tooltip = $('<output>' + $input.attr('value') + '</output>')
            .addClass('coral-Tooltip coral-Tooltip--inspect ' + (self.isVertical ? 'coral-Tooltip--positionRight' : 'coral-Tooltip--positionAbove'))
            .attr({
              'role': 'tooltip',
              'aria-hidden': true,
              'id': $input.attr('id') + '-tooltip',
              'for': $input.attr('id')
              });
          $handle.append($tooltip);
        }

        if (self.$inputs.length > 1 && $input.attr('aria-labelledby')) {
          var inputlabelids = $input.attr('aria-labelledby').split(' '), $label;
          for (var i = 0; i < inputlabelids.length; i++) {
            if (i > 0) {
              $label = $('#' + inputlabelids[i]);
              $handle.prepend($label);
            }
          }
        }
      });

      self.$handles = self.$element.find('.coral-Slider-handle');
      self.$tooltips = self.$element.find('.coral-Tooltip');

      self._moveHandles();
    },

    _handleClick: function (event) {
      if (this.options.disabled) return false;
      var self = this,

          // Mouse page position
          mouseX = event.pageX,
          mouseY = event.pageY,

          pointerdown = /^(ms)?pointerdown$/i.test(event.type);

      if (event.type === 'touchstart') {
        var touches = (event.originalEvent.touches.length > 0) ? event.originalEvent.touches : event.originalEvent.changedTouches;
        mouseX = touches[0].pageX;
        mouseY = touches[0].pageY;
      } else if (pointerdown) {
        mouseX = event.originalEvent.clientX + window.pageXOffset;
        mouseY = event.originalEvent.clientY + window.pageYOffset;
      }

      if (mouseX === undefined || mouseY === undefined) return; // Do not use undefined values!

      // Find the nearest handle
      var pos = self._findNearestHandle(mouseX, mouseY);

      var val = self._getValueFromCoord(mouseX, mouseY, true);

      if (!isNaN(val)) {
        self._updateValue(pos, val);
        self._moveHandles();
        if (self.options.filled) {
          self._updateFill();
        }
      }

      if (event.type === 'mousedown' || pointerdown) {
        self.$handles.eq(pos).data('mousedown', true);
      }
      self._inputsOrHandles.eq(pos).focus();
    },

    /**
     * Locates the nearest handle to given mouse coordinates.
     * @return The index position of the handle within the this.$handles collection.
     * @private
     */
    _findNearestHandle: function (mouseX, mouseY) {
      var self = this;

      var closestDistance = Infinity; // Incredible large start value

      // Find the nearest handle
      var pos = 0;
      self.$handles.each(function (index) {

        // Handle position
        var handleX = $(this).offset().left;
        var handleY = $(this).offset().top;

        // Handle Dimensions
        var handleWidth = $(this).width();
        var handleHeight = $(this).height();

        // Distance to handle
        var distance = Math.abs(mouseX - (handleX + (handleWidth / 2)));
        if (self.options.orientation === 'vertical') {
          distance = Math.abs(mouseY - (handleY + (handleHeight / 2)));
        }

        if (distance < closestDistance) {
          closestDistance = distance;
          pos = index;
        }
      });

      return pos;
    },

    /**
     * Handles "oninput" and "onchange" events from the input.
     * @private
     */
    _handleInputChange: function (event) {
      if (this.options.disabled) return false;

      var $input = $(event.target),
          index = this.$inputs.index($input);

      if ($input.val() === this.values[index]) return;

      this.setValue($input.val(), index);

      if ($input.is(document.activeElement)) {
        this.$handles.eq(index).removeData('mousedown');
        this._focus(event);
      }
    },

    /**
     * Handles "focusin" event from  either an input or its handle.
     * @private
     */
    _focus: function (event) {
      if (this.options.disabled) return false;
      var self = this,
        $this = $(event.target),
        $value = $this.closest('.coral-Slider-value'),
        $handle = $value.find('.coral-Slider-handle');

      if (!$handle.data('mousedown')) {
        this.$element.addClass('is-focused');
        $value.addClass('is-focused');
        $handle.addClass('is-focused');
      }

      $(window).on('touchstart.slider pointerdown.slider mspointerdown.slider mousedown.slide', function(event) {
        if ($(event.target).closest(self.$element).length === 1) {
          return;
        }
        $this.trigger('focusout.slider');
      });

    },

    /**
     * Handles "focusout" event from  either an input or its handle.
     * @private
     */
    _blur: function (event) {
      if (this.options.disabled) return false;

      var $this = $(event.target),
        $value = $this.closest('.coral-Slider-value'),
        $handle = $value.find('.coral-Slider-handle');

      this.$element.removeClass('is-focused');
      $value.removeClass('is-focused');
      $handle.removeClass('is-focused').removeData('mousedown');

      $(window).off('touchstart.slider pointerdown.slider mspointerdown.slider mousedown.slider');
    },

    /**
     * Handles "keydown" event from a handle.
     * Should only be needed when this._supportsRangeInput === false, otherwise keyboard events will be handled by the native input[type=range] element.
     * @private
     */
    _keyDown: function (event) {
      if (this.options.disabled) return false;

      var self = this,
        $this = $(event.target),
        which = event.which || event.keyCode,
        $value = $this.closest('.coral-Slider-value'),
        $input = $value.find('input'),
        index = self.$inputs.index($input),
        $handle = self.$handles.eq(index),
        val = Number($input.val()),
        step = Number(self.options.step),
        minimum = Number(self.options.min),
        maximum = Number(self.options.max),
        page = Math.max(step, Math.round((maximum - minimum) / 10)),
        capture = false;

      $handle.removeData('mousedown');
      self._focus(event);

      switch (which) {
        case 40:
        case 37:
          // down/left
          val -= step;
          capture = true;
          break;
        case 38:
        case 39:
          // up/right
          val += step;
          capture = true;
          break;
        case 33:
          // page up
          val += (page - (val % page));
          capture = true;
          break;
        case 34:
          // page down
          val -= (page - (val % page === 0 ? 0 : page - val % page));
          capture = true;
          break;
        case 35:
          // end
          val = maximum;
          capture = true;
          break;
        case 36:
          // home
          val = minimum;
          capture = true;
          break;
      }

      if (capture) {
        event.preventDefault();
      }

      if (val !== Number($input.val())) {
        self.setValue(val, index);
        $input.trigger('change.slider'); // Keep input element value updated too and fire change event for any listeners
      }
    },

    _mouseDown: function (event) {
      if (this.options.disabled) return false;

      event.preventDefault();

      var self = this, $handle;

      this.draggingPosition = -1;
      this.$handles.each(function (index, handle) {
        if (handle === event.target) self.draggingPosition = index;
      });

      this.$tooltips.each(function (index, tooltip) {
        if (tooltip === event.target) self.draggingPosition = index;
      });

      // Did not touch any handle? Emulate click instead!
      if (this.draggingPosition < 0) {
        this._handleClick(event);
        return;
      }

      $handle = this.$handles.eq(this.draggingPosition);

      $handle.addClass('is-dragged');
      $('body').addClass('u-coral-closedHand');

      $(window).on('touchmove.slider pointermove.slider mspointermove.slider mousemove.slider', this._handleDragging.bind(this));
      $(window).on('touchend.slider pointerup.slider mspointerup.slider mouseup.slider', this._mouseUp.bind(this));

      if (event.type === 'mousedown' || /^(ms)?pointerdown$/i.test(event.type)) {
        $handle.data('mousedown', true);
      }

      this._inputsOrHandles.eq(this.draggingPosition).focus();
    },

    _handleDragging: function (event) {
      var mouseX = event.pageX,
          mouseY = event.pageY;

      // Handle touch events
      if (event.originalEvent.targetTouches) {
        var touch = event.originalEvent.targetTouches.item(0);
        mouseX = touch.pageX;
        mouseY = touch.pageY;
      } else if (/^(ms)?pointermove$/i.test(event.type)) {
        mouseX = event.originalEvent.clientX + window.pageXOffset;
        mouseY = event.originalEvent.clientY + window.pageYOffset;
      }

      this._updateValue(this.draggingPosition, this._getValueFromCoord(mouseX, mouseY));
      this._moveHandles();
      if (this.options.filled) {
        this._updateFill();
      }
      event.preventDefault();
    },

    _mouseUp: function () {
      this.$handles.eq(this.draggingPosition).removeClass('is-dragged');
      $('body').removeClass('u-coral-closedHand');

      this.draggingPosition = -1;
      $(window).off('mousemove.slider mspointermove.slider pointermove.slider touchmove.slider');
      $(window).off('mouseup.slider mspointerup.slider pointerup.slider touchend.slider');
    },

    _clickLabel: function (event) {
      if (this.options.disabled) return;
      this._inputsOrHandles.eq(0).focus();
    },

    _updateValue: function (pos, value, doNotTriggerChange) {
      var self = this,
          $input = self.$inputs.eq(pos),
          valueString = value.toString(),
          $relatedInput,
          boundary,
          minmax = ['min','max'],
          updatedAttributes = {},
          ariaAttribute;

      if ($input.val() !== valueString ||
          $input.attr('value') !== valueString ||
          self.values[pos] !== valueString) {

        // snap the new value to the appropriate step
        value = this._snapValueToStep(value, this.options.min,  this.options.max, this.options.step);

        // if this is a bound slider we need to:
        // 1. make sure that the new value is bounded by the value of the related input.
        // 2. adjust the min or max value on the related input so that it is bounded by the new value
        // 3. update the appropriate attributes on the input and handle
        if (self.$inputs.length === 2 && this.options.bound) {
          // pos is 0 || 1, so the related input's index is !pos
          $relatedInput = self.$inputs.eq(!pos);

          // the boundary is the current value of the relatedInput
          boundary = Number($relatedInput.val());

          // depending on the index of the input, limit the value using either Math.min or Math.max
          // (for pos === 0, use Math.min, for pos === 1, use Math.max)
          value = Math[ minmax[pos] ](value, boundary);

          // depending on the index of the input, set the min/max attribute on the related input
          // (for pos === 0, use [min], for pos === 1, use [max])
          $relatedInput.attr(minmax[pos], value);

          // depending on the index of the input, set the min/max attribute on the input
          // (for pos === 0, use [max], for pos === 1, use [min])
          ariaAttribute = minmax[!pos];
          $.extend(updatedAttributes, {
            ariaAttribute: boundary
          });
        }

        self.values[pos] = value.toString();

        $.extend(updatedAttributes, {
          'value': value,
          'aria-valuetext': self._supportsRangeInput ? self.options.valuetextFormatter(value) : null
        });

        $input.val(value).attr(updatedAttributes);

        if (!this._supportsRangeInput) {
          // depending on the index of the input,
          // set the aria-valuemin/aria-valuemax, aria-valuenow and aria-valuetext for the handles
          self.$handles.each(function (i, handle) {
            var isPos = (i === pos),
                boundaryOrValue = isPos ? boundary : value;
            ariaAttribute = 'aria-value' + minmax[!isPos];
            updatedAttributes = {
              ariaAttr: boundaryOrValue
            };
            if (isPos) {
              $.extend(updatedAttributes, {
                'aria-valuenow': value,
                'aria-valuetext': self.options.valuetextFormatter(value)
              });
            }
            $(handle).attr(updatedAttributes);
          });
        }

        if (!doNotTriggerChange) {
          setTimeout(function () {
            $input.change(); // Keep input element value updated too and fire change event for any listeners
          }, 1); // Not immediatly, but after our own work here
        }
      }
    },

    _moveHandles: function () {
      var self = this;

      // Set the handle position as a percentage based on the stored values
      this.$handles.each(function (index,  handle) {
        var $handle = $(handle),
            percent = (self.values[index] - self.options.min) / (self.options.max - self.options.min) * 100,
            $input = self.$inputs.eq(index),
            $tooltip;

        if (self.options.orientation === 'vertical') {
          $handle.css('bottom', percent + '%');
          $input.css('bottom', percent + '%');
        } else { // Horizontal
          $handle.css('left', percent + '%');
          $input.css('left', percent + '%');
        }

        // Update tooltip value (if required)
        if (self.options.tooltips) {
          $tooltip = self.$tooltips.eq(index);
          $tooltip.html(self.options.tooltipFormatter(self.values[index]));

          // adjust position of tooltip to accommodate the updated value.
          if (self.options.orientation === 'vertical') {
             $tooltip.css('top', -(($tooltip.outerHeight() + $handle.outerHeight() / 2) / 2) + 'px');
          } else {
            $tooltip.css('left', -(($tooltip.outerWidth() + $handle.outerWidth() / 2) / 2) + 'px');
          }
        }
      });
    },

    _updateFill: function () {
      var self = this;
      var percent;

      if (self.values.length !== 0) {
        if (self.values.length === 2) { // Double value/handle
          percent = ((self._getLowestValue() - self.options.min) / (self.options.max - self.options.min)) * 100;
          var secondPercent = ((self._getHighestValue() - self.options.min) / (self.options.max - self.options.min)) * 100;
          var percentDiff = secondPercent - percent;
          if (self.options.orientation === 'vertical') {
            self.$fill.css('bottom', percent + '%').css('height', percentDiff + '%');
          } else { // Horizontal
            self.$fill.css('left', percent + '%').css('width', percentDiff + '%');
          }
        } else { // Single value/handle
          percent = ((self.values[0] - self.options.min) / (self.options.max - self.options.min)) * 100;
          if (self.options.orientation === 'vertical') {
            self.$fill.css('height', percent + '%');
          } else {
            self.$fill.css('width', percent + '%');
          }
        }
      }
      if (self.options.ticks) {
        self._coverTicks();
      }
    },

    _coverTicks: function () {
      var self = this;

      // Ticks covered by the fill are given a different class
      self.$ticks.each(function (index) {
        var value = self._getValueFromCoord($(this).offset().left, $(this).offset().top);
        if (self.values.length === 2) { // @todo Figure out what previous comitter said when they wrote "add a parameter to indicate multi values/handles" here
          if ((value >= self._getLowestValue()) && (value <= self._getHighestValue())) {
            $(this).addClass('coral-Slider-tick--covered');
          }
          else {
            $(this).removeClass('coral-Slider-tick--covered');
          }
        }
        else {
          if (value <= self._getHighestValue()) {
            $(this).addClass('coral-Slider-tick--covered');
          }
          else {
            $(this).removeClass('coral-Slider-tick--covered');
          }
        }
      });
    },

    _getValueFromCoord: function (posX, posY, restrictBounds) {
      var self = this,
          percent,
          elementOffset = self.$element.offset();

      if (self.options.orientation === 'vertical') {
        var elementHeight = self.$element.height();
        percent = ((elementOffset.top + elementHeight) - posY) / elementHeight;
      } else {
        var elementWidth = self.$element.width();
        percent = ((posX - elementOffset.left) / elementWidth);
      }

      // if the bounds are retricted, as with _handleClick, we souldn't change the value.
      if (restrictBounds && (percent < 0 || percent > 1)) return NaN;

      var rawValue = self.options.min * 1 + ((self.options.max - self.options.min) * percent);

      // Snap value to nearest step
      return this._snapValueToStep(rawValue, self.options.min, self.options.max, self.options.step);
    },

    _getHighestValue: function () {
      return Math.max.apply(null, this.values);
    },

    _getLowestValue: function () {
      return Math.min.apply(null, this.values);
    },

    /**
     * Initializes inputs and handles for accessibility.
     * If the user agent supports input[type=range], the inputs should receive keyboard focus and keyboard events should be handled natively.
     * When the user agent does not support input[type=range], the handles should implement the WAI-ARIA Slider widget design pattern.
     * @private
     */
    _makeAccessible: function () {
      var self = this,
          $input, $handle;

      this.$inputs.each(function(i, inputElement) {
        $input = $(inputElement);
        $handle =  self.$handles.eq(i);

        if (self._supportsRangeInput) {
          $input.attr({
            'aria-valuetext': self.options.valuetextFormatter($input.attr('value')),
            'aria-hidden': null,
            'tabindex': null
          });
          $handle.attr({
            'role': null,
            'aria-valuemin': null,
            'aria-valuemax': null,
            'aria-valuestep': null,
            'aria-valuenow': null,
            'aria-valuetext': null,
            'tabindex': null,
            'aria-labelledby': null
          });
          $('label[for="#' + $handle.attr('id') + '"]').attr('for', $input.attr('id'));
        } else {
          $input.attr({
            'aria-valuetext': null,
            'aria-hidden': true,
            'tabindex': -1
          });
          $handle.attr({
            'role': 'slider',
            'aria-valuemin': $input.attr('min'),
            'aria-valuemax': $input.attr('max'),
            'aria-valuestep': $input.attr('step'),
            'aria-valuenow': $input.attr('value'),
            'aria-valuetext': self.options.valuetextFormatter($input.attr('value')),
            'tabindex': !$input.is(':disabled') ? 0 : null,
            'aria-labelledby': $input.attr('aria-labelledby') || null
          });
          $('label[for="' + $input.attr('id') + '"]').attr('for', $handle.attr('id'));
        }
      });

      if (!self._supportsRangeInput) {
        this._inputsOrHandles = this.$handles;
        this.$element.on('keydown.slider', '[role=slider].coral-Slider-handle' , this._keyDown.bind(this));
      } else {
        this._inputsOrHandles = this.$inputs;
        this.$element.off('keydown.slider');
      }

      // update values to make sure that all aria attributes and values are in sync
      $.each(this.values, function (i, value){
        self._updateValue(i, value, true);
      });
    },

    /**
     * Ensure that legend and label elements correctly label the inputs of the slider,
     * and adjusts the DOM so that labels don't break the layout of the CUI.Slider.
     * @private
     */
    _adjustLabelling: function () {
      var self = this,
        elementId = this.$element.attr('id'),
        $legend = this._adjustFieldsetAndLegend();

      this._adjustInputLabels($legend);
    },

    /**
     * Sliders with two inputs should be contained within a fieldset
     * with a legend element as its first child, which provides a label for the grouping.
     *
     * This method corrects the DOM of the fieldest and legend elements
     * so that they don't break the layout of the CUI.Slider.
     *
     * @return {jQuery} the new legend element
     * @private
     */
    _adjustFieldsetAndLegend: function () {
      var self = this,
        elementId = this.$element.attr('id'),
        // sliders with two inputs should be contained within a fieldset to provide a label for the grouping
        $fieldset = this.$element.children('fieldset'),
        $legend = $fieldset.children('legend'),
        $group, $grouplegend;

      // [~dantipa]
      // this block has to be optimized
      // taking the content of fieldset and appending it somewhere else causes flashing
      // future markup should be like the expected markup (breaking change)
      if ($fieldset.length) {
        // move all fieldset children other than the legend to be children of the element.
        this.$element.append($fieldset.contents(':not(legend)'));

        // create a new wrapper div with role="group" and class="coral-Slider-fieldset", which will behave as a fieldset but render as an inline block
        $group = $('<div/>', {
          'role': 'group',
          'class': 'coral-Slider-fieldset'
        }).insertBefore(this.$element);

        // wrap the element with the new "coral-Slider-fieldset " div.
        // [~mijordan] we wrap the div so that the label or legend for the slider
        // can be displayed without interfering with the generated markup elements for the slider
        // which are absolutely positioned relative to the coral-Slider element.
        $group.append(this.$element);

        if ($legend.length) {
          // create new label element and append the contents of the legend
          $grouplegend = $('<div/>');
          $grouplegend.append($legend.contents());

          // give the new label element all the same attributes as the legend
          $.each($legend.prop('attributes'), function () {
            $grouplegend.attr(this.name, this.value);
          });

          // if the new grouplegend has no id, which would have been inherited from the original legend, assign one.
          if (!$grouplegend.attr('id')) {
            $grouplegend.attr('id', elementId + '-legend');
          }

          // replace the original fieldset, which now only contains the original legend, with the new legend label element
          $fieldset.replaceWith($grouplegend);

          // insert the new grouplegend before the element
          $legend = $grouplegend.insertBefore(this.$element);

          // the group should be labelled by the legend
          $group.attr('aria-labelledby', $legend.attr('id'));
        }
      }

      return $legend;
    },

    /**
     * Explicitly associates the legend and labels to the inputs they label.
     * Adjusts the DOM so that the label doesn't break the layout of the CUI.Slider.
     * @private
     */
    _adjustInputLabels: function (legend) {
      var self = this,
          elementId = this.$element.attr('id'),
          $legend = $(legend);

      this.$inputs.each(function (index, input) {
        var $input = $(input),
            inputId = $input.attr('id'),
            $label,
            ariaLabelledby = $input.attr('aria-labelledby');

        // if the input doesn't have an id, make one
        if (!inputId) {
          $input.attr('id', elementId + '-input' + index);
          inputId = $input.attr('id');
        }

        if (!ariaLabelledby) {
          ariaLabelledby = '';
          $input.attr('aria-labelledby', ariaLabelledby);
        }

        // existing labels that use the "for" attribute to identify the input
        $label = self.$element.find('label[for="' + inputId + '"]');

        // If we have a legend, the input should first be labelled by the legend.
        // On Windows, screen readers do a good job of announcing the containing group when identifying the control,
        // so we exclude Windows to prevent double voicing of the legend.
        if ($legend.length && window.navigator.platform.indexOf('Win') === -1) {
          if (ariaLabelledby.indexOf($legend.attr('id')) === -1) {
            ariaLabelledby = $legend.attr('id') + (ariaLabelledby.length ? ' ' : '') + ariaLabelledby;
            $input.attr('aria-labelledby', ariaLabelledby);
          }
        }

        // for existing labels that use the "for" attribute to identify the input,
        if ($label.length) {
          // if the label is not the input's parent, move it before the slider element tag
          $label.not($input.parent()).insertBefore(self.$element);
          $label.each(function (index) {
            // if the label doesn't have an id, create one
            if (!$(this).attr('id')) {
              $(this).attr('id', inputId + '-label' + index);
            }

            // explicity identify the input's label
            if (ariaLabelledby.indexOf(inputId + '-label' + index) === -1) {
              ariaLabelledby = ariaLabelledby + (ariaLabelledby.length ? ' ' : '') + inputId + '-label' + index;
              $input.attr('aria-labelledby', ariaLabelledby);
            }

            $(this).on('mousedown.slider', function (event) {
              self._inputsOrHandles.eq(index).focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            });
          });
        }

        // if the input is contained by a label
        if ($input.parent().is('label')) {
          $label = $input.parent();

          // make sure it has an id
          if (!$label.attr('id')) {
            $label.attr('id', inputId + '-label');
          }

          // make sure it explicitly identifies the input it labels
          if (!$label.attr('for')) {
            $label.attr('for', inputId);
          }

          // move the input after the label
          $input.insertAfter($label);

          // if there is a legend, this is a two thumb slider; internal labels identify the minimum and maximum, and they should have the class="u-coral-screenReaderOnly"
          // aria-hidden=true hides the label from screen readers, but keeps it in the DOM as a label for the input;
          // the label should never be read independent of the input.
          if ($legend.length) {
            $label.addClass('u-coral-screenReaderOnly')
              .attr({
                'aria-hidden': true
              });
          }

          // move the label outside the slider element tag
          $label.insertBefore(self.$element);
        }

        // if the input has a label that is not included in the aria-labelledby attribute, add the label id to the "aria-labelledby" attribute
        if ($label.length && ariaLabelledby.indexOf($label.attr('id')) === -1) {
          ariaLabelledby = ariaLabelledby + (ariaLabelledby.length ? ' ' : '') + $label.attr('id');
          $input.attr('aria-labelledby', ariaLabelledby);
        }

        if ($label.length === 0 && ariaLabelledby.length > 0) {
          $label = $('#' + ariaLabelledby.split(' ')[0]);
        }

        if (ariaLabelledby.length === 0) {
          $input.removeAttr('aria-labelledby');
        }

        // clicking on a label or legend should focus the first input or handle in the group
        if (index === 0) {
          if ($label.length) {
            $label.on('click.slider', self._clickLabel.bind(self));
          }

          if ($legend.length) {
            $legend.on('click.slider', self._clickLabel.bind(self));
          }
        }
      });
    },

    /**
     * Boolean to flag support for HTML5 input[type=range]
     * @private
     */
    _supportsRangeInput: (function () {
      var i = document.createElement('input');
      i.setAttribute('type', 'range');
      return (i.type === 'range');
    })(),

    _snapValueToStep:function(rawValue, min, max, step) {
      step = parseFloat(step);
      var remainder = ((rawValue - min) % step), snappedValue,
          floatString = step.toString().replace(/^(?:\d+)(?:\.(\d+))?$/g, '$1'),
          precision = floatString.length;

      if (Math.abs(remainder) * 2 >= step) {
        snappedValue = (rawValue - Math.abs(remainder)) + step;
      } else {
        snappedValue = rawValue - remainder;
      }

      if (snappedValue < min) {
        snappedValue = min;
      } else if (snappedValue > max) {
        snappedValue = min + Math.floor((max - min) / step) * step;
      }

      // correct floating point behavior by rounding to step precision
      if (precision > 0) {
        snappedValue = parseFloat(snappedValue.toFixed(precision));
      }

      return snappedValue;
    }

    /*
    update: function() {
     // @todo Figure out what last committer meant when they wrote "Single update method" here
    }
    */
  });

  CUI.Widget.registry.register('slider', CUI.Slider);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (e) {
      CUI.Slider.init($('.coral-Slider[data-init~="slider"]', e.target));
    });
  }
}(jQuery, this));


(function ($) {
  CUI.LabeledSlider = new Class(/** @lends CUI.LabeledSlider# */{
    toString: 'LabeledSlider',
    extend: CUI.Slider,

    /**
     @extends CUI.Slider
     @classdesc <p><span id="slider-label">A slider widget with labeled ticks</span></p>


     <p>
     The labeled slider uses the same options/markup as the slider label, but with one addition: You can provide a list of labels for the
     slider's ticks. (And of course use data-init="labeled-slider"!)
     </p>
     <p><em>Please note</em> that you have to list the labels for the ticks exactly in the order and count that you configured
     your slider's ticks. If your slider has 5 ticks, provide 5 labels for it. The number of ticks depends on the step / min / max values and
     can be calculated by ceil((max - min) / step) - 1.</p>

     @desc Creates a labeled slider from a div
     @constructs

     @param {Object}   options                               Component options
     @param {number} [options.step=1]  The steps to snap in
     @param {number} [options.min=1]   Minimum value
     @param {number} [options.max=100] Maximum value
     @param {number} [options.value=1] Starting value
     @param {number} [options.tooltips=false] Show tooltips?
     @param {String} [options.orientation=horizontal]  Either 'horizontal' or 'vertical'
     @param {boolean} [options.slide=false]    True for smooth sliding animations. Can make the slider unresponsive on some systems.
     @param {boolean} [options.disabled=false] True for a disabled element
     @param {boolean} [options.bound=false] For multi-input sliders, indicates that the min value is bounded by the max value and the max value is bounded by the min
     @param {boolean} [options.alternating=false] Staggers the layout of tick labels.
     **/
    construct: function () {
      this.$element.addClass("coral-Slider--labeled");

      if (this.options.alternating) {
        this.$element.addClass("coral-Slider--alternatingLabels");
      }
    },

    defaults: $.extend(CUI.Slider.prototype.defaults, {
      'alternating': false
    }),

    /**
     * reads the options from the markup (classes)
     * @private
     */
    _readOptions: function () {
      this.inherited(arguments);

      if (this.$element.hasClass("coral-Slider--alternatingLabels")) {
        this.options.alternating = true;
      }
    },

    _getTickLabel: function (index) {
      var el = this.$element.find("ul.coral-Slider-tickLabels li").eq(index);
      return el.html();
    },

    _buildTicks: function () {
      var self = this,

          // The ticks holder
          $ticks = $("<div></div>").addClass('coral-Slider-ticks'),
          numberOfTicks = Math.ceil((self.options.max - self.options.min) / self.options.step) + 1,
          trackDimensions = self.isVertical ? self.$element.height() : self.$element.width(),
          maxSize = 100 * (trackDimensions / (numberOfTicks)) / trackDimensions;

      this.$element.append($ticks);

      if (this.options.alternating) {
        maxSize *= 2;
      }

      for (var i = 0; i < numberOfTicks; i++) {
        var position = trackDimensions * (i) / (numberOfTicks - 1),
            percent = (position / trackDimensions) * 100,
            tick = $('<div/>').addClass('coral-Slider-tick').css((self.isVertical ? 'bottom' : 'left'), percent + "%"),
            tickLabelId = 'coral-Slider-tickLabel-' + self.$element.attr('id') + '-'+ i,
            ticklabel = $('<div/>').addClass('coral-Slider-tickLabel').attr('id', tickLabelId);
        $ticks.append(tick);
        if (!self.isVertical) percent -= maxSize / 2;
        ticklabel.css((self.isVertical ? 'bottom' : 'left'), percent + "%");
        if (!self.isVertical) ticklabel.css('width', maxSize + "%");
        ticklabel.append(self._getTickLabel(i));
        $ticks.append(ticklabel);
      }
      self.$ticks = $ticks.find('.coral-Slider-tick');
      if (self.options.filled) {
        self._coverTicks();
      }
    },

    /**
     * Finds the nearest tick and assigns its corresponding label to the slider's aria-describedby property.
     * @private
     */
    _moveHandles: function () {
      var self = this;
      this.inherited(arguments);

      if (!this.$ticks || this.$ticks.length === 0) return;

      this.$inputs.each(function (index) {
        var $input = self.$inputs.eq(index),
          $handle = self.$handles.eq(index),
          inputOffset = $input.offset(),
          inputX = inputOffset.left + $input.width() / 2,
          inputY = inputOffset.top + $input.height() / 2,
          tickPos = self._findNearestTick(inputX, inputY),
          $tickLabel = self.$ticks.eq(tickPos).next('.coral-Slider-tickLabel');

        (self._supportsRangeInput ? $input : $handle).attr({
          'aria-describedby': $tickLabel.attr('id')
        });
      });
    },

    /**
     * Finds the nearest tick relative to a given offset coordinates.
     * @private
     */
    _findNearestTick: function (posX, posY) {
      if (!this.$ticks || this.$ticks.length === 0) return;
      var self = this,
          closestDistance = Infinity, // Incredible large start value
          // Find the nearest handle
          pos = 0;

      self.$ticks.each(function (index) {

        // Handle position
        var tickX = $(this).offset().left,
          tickY = $(this).offset().top,

        // Handle Dimensions
          tickWidth = $(this).width(),
          tickHeight = $(this).height(),

        // Distance to tick
          distance = Math.abs(posX - (tickX + (tickWidth / 2)));
        if (self.options.orientation === 'vertical') {
          distance = Math.abs(posY - (tickY + (tickHeight / 2)));
        }

        if (distance < closestDistance) {
          closestDistance = distance;
          pos = index;
        }
      });

      return pos;
    }
  });

  CUI.Widget.registry.register("labeled-slider", CUI.LabeledSlider);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      CUI.LabeledSlider.init($(".coral-Slider[data-init~='labeled-slider']", e.target));
    });
  }
}(window.jQuery));




/* jshint devel:true */

(function ($, window, undefined) {
  CUI.Autocomplete = new Class(/** @lends CUI.Autocomplete# */{
    toString: 'Autocomplete',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc Autocomplete is an input component which allows users
     * to search a list of items by typing into the input or, optionally,
     * clicking a toggle button. The list of items can be provided directly
     * or loaded dynamically from a remote endpoint. Depending on enabled
     * options, users can also create tags based on the text they have
     * entered or an item they have selected.
     *
     * @description Creates a new select
     * @constructs
     *
     * @param {Object} options Component options
     * @param {Mixed} options.element jQuery selector or DOM element to use
     * for the autocomplete element.
     * @param {String} [options.mode=starts] Search mode for
     * filtering on the client. Possible values are "starts" or "contains".
     * This has no effect if filtering is occurring remotely.
     * @param {Boolean} [options.ignorecase=true] Whether filtering on the
     * client should be case insensitive. This has no effect if filtering
     * is occurring remotely.
     * @param {Number} [options.delay=500] Amount of time, in milliseconds,
     * to wait after typing a character before a filter operation is
     * triggered.
     * @param {Boolean} [options.multiple=false] Allows multiple items
     * to be selected. Each item selection generates a tag.
     * @param {Boolean} [options.forceselection=false] <code>true</code> to
     * restrict the selected value to one of the given options of select list.
     * Otherwise the user is allow to enter arbitrary text.
     * @param {Object} [options.selectlistConfig] A configuration object
     * that is passed through to the select list. See {@link CUI.SelectList}
     * for more information.
     * @param {Object} [options.tagConfig] A configuration object
     * that is passed through to the tag list. See {@link CUI.TagList}
     * for more information.
     */
    construct: function () {
      // find elements
      this._input = this.options.predefine.input || this.$element.find('.js-coral-Autocomplete-textfield');
      this._selectlist = this.options.predefine.selectlist || this.$element.find('.js-coral-Autocomplete-selectList');
      this._tags = this.options.predefine.tags || this.$element.find('.js-coral-Autocomplete-tagList');
      this._suggestionsBtn = this.options.predefine.suggestionsBtn || this.$element.find('.js-coral-Autocomplete-toggleButton');
      this._selectListAnchor = this.$element.find('.js-coral-Autocomplete-field');

      // For backward-compatibility.
      if (!this._selectListAnchor.length) {
        this._selectListAnchor = this.$element.find('.js-coral-Autocomplete-inputGroup');
      }

      // apply
      this.applyOptions();

      // accessibility
      this._makeAccessible();

      this._initTypeahead();
      this._setOptionListeners();
    },

    defaults: {
      mode: 'starts', // filter mode ['starts', 'contains']
      ignorecase: true,
      delay: 200,
      multiple: false,
      forceselection: false,

      selectlistConfig: null,
      tagConfig: null,

      // @warning do not use this
      //
      // future feature
      // allows to bypass element search and pass elements
      // will allow to evalute this solution
      predefine: {}
    },

    applyOptions: function () {
      this._setInput();
      this._setTags();
      this._setSelectlist();
      this._setSuggestions();
      this._setForceSelection();
    },

    /**
     * Sets up listeners for option changes.
     * @private
     */
    _setOptionListeners: function () {

      this.on('change:multiple', function () {
        this._setInput();
        this._setTags();
        this._setForceSelection();
      }.bind(this));

      this.on('change:forceselection', function () {
        this._setForceSelection();
      }.bind(this));

      this._selectlist
        .on("itemremoved", function (removedEvent) {
          var values;

          if (removedEvent.item instanceof CUI.SelectList.Group) {
            values = removedEvent.item.getItems().map(function(option) { return option.getValue(); });
          } else {
            values = [removedEvent.item.getValue()];
          }
          this._deselect(values);
        }.bind(this));
    },

    /**
     * Clears values from the taglist
     * @private
     */
    _deselect: function (values) {
      values.forEach(function _deselectValue(value) {
        if (this.options.multiple) {
          this._tagListWidget.removeItem(value);
        } else if (
          (this._input && value === this._input.val()) ||
          (this._valueInput && value === this._valueInput.val())) {
          this.clear();
        }
      }, this);
    },

    /**
     * Initializes the forceselection logic
     * @private
     */
    _setForceSelection: function () {
      var self = this;

      if (this.options.forceselection && !this.options.multiple) {

        // if the hidden field has not been initialized we set it up
        if (!this._valueInput) {

              // queries for the hidden value
          var hiddenInput = this.$element.find('.js-coral-Autocomplete-hidden'),
              // gets name used by the input
              inputName = this._input.prop('name'),
              // gets the current value
              inputValue = this._input.val();

          // if the hidden value exists
          if(hiddenInput.length > 0) {

            // uses the current hidden value
            this._valueInput = hiddenInput;

            // if the hidden input does not have a name and
            // and the input field has one, we assign it to
            // the hidden input
            if(!this._valueInput.prop('name') && inputName) {
              this._valueInput.prop('name', inputName);
            }

            // clears the name of original input
            this._input.prop('name', '');

            // preserves the current value of the hidden field as the last selected
            self._lastSelected = this._valueInput.val();
            // saves the current displayed value
            self._lastSelectedDisplay = inputValue;

          } else {

            // creates a new hidden input
            if (inputName) {
              // creates a hidden field and copies the current
              // name and value
              this._valueInput = $('<input type="hidden" class="js-coral-Autocomplete-hidden">')
                .prop('name', inputName)
                .val(inputValue)
                .insertAfter(this._input);

              // clears the name of original input
              this._input.prop('name', '');
            }

            // sets the initial value as lastSelect and lastDisplaySelected
            self._lastSelected = inputValue;
            self._lastSelectedDisplay = inputValue;
          }
        }

        // Reset to last value on blur.
        this._input.on('blur.autocomplete-forceselection', function () {

          var handler = function () {
              // if the display value has changed
              if (self._lastSelectedDisplay !== self._input.val()) {

                // if the user reset the value, we clear everything
                if (self._input.val() === '') {
                  // resets the stored variables
                  self._lastSelectedDisplay = '';
                  self._lastSelected = '';

                  self._triggerValueChange();
                }

                // sets the latest known values
                self._input.val(self._lastSelectedDisplay);
                self._valueInput.val(self._lastSelected);
              }
          };

          var timeout = setTimeout(handler, 0);

          self._suggestionsBtn.on('focus', function () {
            clearTimeout(timeout);
            self._suggestionsBtn.on('blur', handler);
          });
        });
      } else {
        this._input.off('blur.autocomplete-forceselection');

        if (this._valueInput) {
          // copies back the name and value to the original input
          this._input.prop('name', this._valueInput.prop('name'));
          this._input.val(this._valueInput.val());
          // removes the hidden input
          this._valueInput.remove();
          this._valueInput = undefined;
        }
      }
    },

    /**
     * Initializes the text input
     * @private
     */
    _setInput: function () {
      if (this.options.multiple) {
        this._input.on('keypress.autocomplete-preventsubmit', function (event) {
          if (event.which === 13) { // enter
            // Prevent it from submitting a parent form.
            event.preventDefault();
            return false;
          }
        });
      } else {
        this._input.off('keypress.autocomplete-preventsubmit');
      }

      // Prevents native autocompletion from being enabled when inside
      // a form.
      this._input.attr('autocomplete', 'off');

      // uses the initial value as default
      this._lastSelected = this._input.val();
      this._lastSelectedDisplay = this._input.val();
    },

    /**
     * initializes the select list widget
     * @private
     */
    _setSelectlist: function () {
      // if the element is not there, create it
      if (this._selectlist.length === 0) {
        this._selectlist = $('<ul/>', {
          'id': CUI.util.getNextId(),
          'class': 'coral-SelectList js-coral-Autocomplete-selectList'
        }).appendTo(this.$element);
      } else if (!this._selectlist.attr('id')) {
        this._selectlist.attr('id', CUI.util.getNextId());
      }

      this._selectlist.selectList($.extend({
        relatedElement: this._selectListAnchor,
        autofocus: false,
        autohide: true
      }, this.options.selectlistConfig || {}));

      this._selectListWidget = this._selectlist.data('selectList');

      this._selectlist
        // receive the value from the list
        .on('selected.autocomplete', this._handleSelected.bind(this));
    },

    /**
     * initializes the tags for multiple options
     * @private
     */
    _setTags: function () {
      if (this.options.multiple && !this._tagListWidget) {
        // if the element is not there, create it
        if (this._tags.length === 0) {
          this._tags = $('<ul/>', {
            'class': 'coral-TagList js-coral-Autocomplete-tagList'
          }).appendTo(this.$element);
        }

        this._tags.tagList(this.options.tagConfig || {});
        this._tagListWidget = this._tags.data('tagList');
        this._input.on('keyup.autocomplete-addtag', this._addTag.bind(this));
        var boundTriggerValueChange = this._triggerValueChange.bind(this);
        this._tags.on('itemremoved', boundTriggerValueChange);
        this._tags.on('itemadded', boundTriggerValueChange);

      } else if (!this.options.multiple && this._tagListWidget) {
        this._tags.off('itemadded');
        this._tags.off('itemremoved');
        this._tags.remove();
        this._tags = null;
        this._tagListWidget = null;
        this._input.off('keyup.autocomplete-addtag');
      }
    },

    /**
     * initializes the typeahead functionality
     * @private
     */
    _initTypeahead: function () {
      var self = this,
        timeout;

      var debounceComplete = function () {

        self.showSuggestions(
          self._input.val(),
          false,
          self._selectListWidget);
      };

      var debounce = function (event) {
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(debounceComplete, self.options.delay);
      };

      this._input.on('input.autocomplete', debounce);

      // IE9 doesn't fire input events for backspace, delete, or cut so
      // we're making up the difference.
      this._input.on('cut.autocomplete', debounce);
      this._input.on('keyup.autocomplete', function (event) {
        switch (event.which) {
          case 8: // backspace
          case 46: // delete
            debounce();
        }
      });
      this._input.on('keypress.autocomplete', function (event) {
        event.stopPropagation();
      });
    },

    /**
     * sets the suggestion button
     * @private
     */
    _setSuggestions: function () {
      var self = this;

      // if the button to trigger the suggestion box is not there,
      // then we add it
      if (this._suggestionsBtn.length) {
        // handler to open suggestion box
        this._suggestionsBtn.attr({
          'tabindex': -1,
          'aria-hidden': true
        });
        this._suggestionsBtn.on('click.autocomplete', function (event) {
          if (!self._selectListWidget.get('visible')) {
            self.showSuggestions(
              '',
              true,
              self._selectListWidget);

            self._input.trigger('focus');

            event.preventDefault();
            // If the event were to bubble to the document the
            // select list would be hidden.
            event.stopPropagation();
          } else {
            self._input.trigger('focus');
          }
        });

        // add class to input to to increase padding right for the button
        this._input.addClass('autocomplete-has-suggestion-btn');
      }
    },

    /**
     * adds some accessibility attributes and features
     * http://www.w3.org/WAI/PF/aria/roles#combobox
     * http://www.w3.org/WAI/PF/aria/states_and_properties#aria-autocomplete
     * @private
     */
    _makeAccessible: function () {
      var self = this, $inputLabel;
      this._input.attr({
        'id': this._input.attr('id') || CUI.util.getNextId(),
        'role': 'combobox',
        'aria-multiselectable': this.options.multiple || null,
        'aria-autocomplete': this.options.typeahead ? 'list' : null,
        'aria-owns': this._selectlist.attr('id') || null
      });

      // Make sure that the input has a label.
      // If no label is present, this tries to correct the poor practice
      // of using placeholder text instead of a true label.
      $inputLabel = $('label[for="' + this._input.attr('id') +'"]');
      if ($inputLabel.length === 0) {
        $inputLabel = this._input.closest('label');
      }
      if (($inputLabel.length === 0 || $.trim($inputLabel.text()).length === 0) && this._input.attr('placeholder')) {
        this._input.attr({
          'aria-label': this._input.attr('placeholder')
        });
      }

      this._selectListWidget._makeAccessible();

      this._input.add(this._suggestionsBtn).on('keydown.cui-autocomplete', function (event) {
        switch (event.which) {
          case 40: // down arrow
            if (!self._selectListWidget.get('visible')) {
              self._selectListWidget.show().resetCaret();
            } else {
              self._selectListWidget.$element.trigger('focus');
            }
            event.preventDefault();
            // If the event continued propagation then the
            // SelectList would set its cursor to the next
            // item in the list.
            event.stopPropagation();
            break;
        }
      }.bind(this));
    },

    /**
     * adds a new tag with the current input value
     * @private
     */
    _addTag: function (event) {
      if (event.which !== 13 || this.options.forceselection) {
        return;
      }

      this._tagListWidget.addItem(this._input.val());
      this.clear();
      this._selectListWidget.hide();
    },

    /**
     * @private
     * @param  {jQuery.Event} event
     */
    _handleSelected: function (event) {
      this._selectListWidget.hide();

      var selectedValue = event.selectedValue,
        displayedValue = event.displayedValue;

      if (this.options.multiple) {
        this._tagListWidget.addItem({
          display: displayedValue,
          value: selectedValue
        });
        this.clear();
      } else {
        this._lastSelected = selectedValue || displayedValue;
        this._lastSelectedDisplay = displayedValue;

        if (this.options.forceselection) {
          this._input.val(displayedValue);
          this._valueInput.val(this._lastSelected);
        } else {
          // Use _lastSelected to follow <datalist> behaviour
          this._input.val(this._lastSelected);
        }

        this._triggerValueChange();
      }

      this._input.trigger('focus');
    },

    /**
     * this function is triggered when a typeahead request needs to be done
     * override this function to achieve a custom handling on the client
     *
     * @fires Autocomplete#query
     * @param {String} val null if all values need to be shown
     * @param {Boolean} fromToggle Whether the request was triggered
     * by the user clicking the suggestion toggle button.
     * @param {CUI.SelectList} selectlist instance to control the popup
     */
    showSuggestions: function (val, fromToggle, selectlist) { // selectlist argument is passed for custom implementations
      // fire event to allow notifications
      this.$element.trigger($.Event('query', {
        value: val
      }));

      var selectListWidgetType = this._selectListWidget.get('type'),
          showList = true;

      if (val.length || fromToggle) {
        // actually handle the filter
        if (selectListWidgetType === 'static') {
          this._handleStaticFilter(val);
          showList = this._selectlist.find('[role="option"]:not(.is-hidden)').length > 0;
        } else if (selectListWidgetType === 'dynamic') {
          this._handleDynamicFilter(val);
        }
        if (!showList) {
          this._selectListWidget.hide();
        } else {
          this._selectListWidget.show().resetCaret();
        }
      } else if (val.length === 0 && this._selectListWidget._hasFocus()) {
        if (selectListWidgetType === 'static') {
          this._handleStaticFilter(val);
          showList = this._selectlist.find('[role="option"]:not(.is-hidden)').length > 0;
        }
        if (!showList) {
          this._selectListWidget.hide();
        }
      } else { // No input text and the user didn't click the toggle.
        // TODO when val.length === 0, it should show all options. Otherwise bad UX.
        this._selectListWidget.hide();
      }
    },

    /**
     * handles a static list filter (type == static) based on the defined mode
     * @private
     * @param  {String} query The term used to filter list items.
     */
    _handleStaticFilter: function (query) {
      var self = this;
      if (query) {
        this._selectListWidget.filter(function (value, display) {
          if (self.options.ignorecase) {
            display = display.toLowerCase();
            query = query.toLowerCase();
          }
          // performance "starts": http://jsperf.com/js-startswith/6
          // performance "contains": http://jsperf.com/string-compare-perf-test
          return self.options.mode === 'starts' ? display.lastIndexOf(query, 0) === 0 :
            self.options.mode === 'contains' ? display.search(query) !== -1 :
              false;
        });
      } else {
        this._selectListWidget.filter();
      }
    },

    /**
     * handles a dynamic list filter (type == dynamic) based on the defined mode
     * @private
     * @param {String} query The term used to filter list items.
     */
    _handleDynamicFilter: function (query) {
      var data = $.extend({}, this._selectListWidget.get('dataadditional'), {
        query: query
      });

      this._selectListWidget.set('dataadditional', data);
      this._selectListWidget.triggerLoadData(true);
    },

    _triggerValueChange: function () {
      this.$element.trigger(
        $.Event('change:value'),
        {
          value: this.getValue()
        }
      );
    },

    /**
     * clears the autocomplete input field
     */
    clear: function () {
      this._input.val('');
      this._lastSelected = '';
      this._lastSelectedDisplay = '';
      this._selectListWidget.filter();

      if (this._valueInput) {
        this._valueInput.val('');
      }

      // clean up dataadditional object in selectlist, see autocomplete.handleDynamicFilter()
      var dataAdditional = this._selectListWidget.get('dataadditional');
      if (dataAdditional) {
        delete dataAdditional.query;
      }
    },

    /**
     * disables the autocomplete
     */
    disable: function () {
      this.$element.addClass('is-disabled');
      this.$element.attr('aria-disabled', true);
      this._input.prop('disabled', true);
      this._suggestionsBtn.prop('disabled', true);
    },

    /**
     * enables the autocomplete
     */
    enable: function () {
      this.$element.removeClass('is-disabled');
      this.$element.attr('aria-disabled', false);
      this._input.prop('disabled', false);
      this._suggestionsBtn.prop('disabled', false);
    },

    /**
     * Get the selection option at the given position.
     *
     * @param {Number} position
     *
     * @returns option
     * @throws {TypeError} if position is not numeric or if position points to
     *         group element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getOption: function (position) {
      return this._selectListWidget.getOption(position);
    },

    /**
     * Remove the selection option at the given position.
     *
     * @param {Number} position
     *
     * @throws {TypeError} if position is not numeric or if position points to
     *         group element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    removeOption: function (position) {
      this.getOption(position).remove();
    },

    /**
     * Get the option group at the given position.
     *
     * @param {Number} position
     *
     * @returns group
     *
     * @throws {TypeError} if position is not numeric or if position points to
     *         option element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getGroup: function (position) {
      return this._selectListWidget.getGroup(position);
    },

    /**
     * Removes the option group at the given position.
     *
     * @param {Number} position
     *
     * @returns group
     *
     * @throws {TypeError} if position is not numeric or if position points to
     *         option element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    removeGroup: function (position) {
      return this.getGroup(position).remove();
    },

    /**
     * Adds a selection option at the given position. If position
     * is undefined, the option is added at the end of the list.
     *
     * <b>Please note</b>: Using this API in combination with type="dynamic" is
     * discouraged.
     *
     * @param {Object|CUI.SelectList.Option|Element|jQuery|Array} option
     *        Option that should be added. If type is Object, the keys `value`
     *        and `display` are used to create the option. If type is
     *        CUI.SelectList.Option, the underlying element is added to the
     *        list. If type is Element, the node is added to the list. If type
     *        is jQuery <b>all</b> elements within the collection are added to
     *        the list. If type is Array, then the array is expected to contain
     *        one of the other types.
     * @param {Number} position
     *        Position at which the element should be inserted. If undefined,
     *        the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addOption : function (option, position) {
      this._selectListWidget.addOption(option, position);
    },

    /**
     * Adds an option group at the given position. If position is undefined, the
     * group is added to the end of the list.
     *
     * <b>Please note</b>: Using this API in combination with type="dynamic" is
     * discouraged. Since closing/opening the select will reload the list
     * content, the elements that were added via this method call will be lost.
     *
     * @param {String|CUI.SelectList.Group|Element|jQuery|Array} group
     *        Group that should be added. If type is String, it is used as
     *        display value.  If type is CUI.SelectList.Group, the underlying
     *        element is added to the list. If type is Element, the node is
     *        added to the list.  If type is jQuery <b>all</b> element within
     *        the collection are added to the list. If type is Array, then the
     *        array is expected to contain one of the other types.
     * @param {Number} position
     *        Position at which the element should be inserted. If undefined,
     *        the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addGroup : function (group, position) {
      this._selectListWidget.addGroup(group, position);
    },

      /**
     *
     * @return {Array|String} current value
     */
    getValue: function () {
      if (this.options.multiple) { // multiple returns array
        return this._tagListWidget.getValues();
      } else if (this.options.forceselection) {
        return this._lastSelected;
      } else {
        return this._input.val();
      }
    },

    /**
     * Retrieve list of suggestion items (groups or options). Note: The list
     * represents a snapshot of the current state. If items are added or
     * removed, the list will become invalid.
     *
     * @return {Array} List of CUI.SelectList.Option and CUI.SelectList.Group
     *   instances
     */
    getItems : function () {
      return this._selectListWidget.getItems();
    },

  });

  CUI.Widget.registry.register("autocomplete", CUI.Autocomplete);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (e) {
      CUI.Autocomplete.init($('[data-init~=autocomplete]', e.target));
    });
  }

}(jQuery, this));

(function ($, window, undefined) {
  CUI.Select = new Class(/** @lends CUI.Select# */{
    toString: 'Select',

    extend: CUI.Widget,

    /**
     * @extends CUI.Widget
     * @classdesc a widget which is similar to the native &lt;select&gt;
     *
     * @description Creates a new select
     * @constructs
     *
     * @param {Object} [options=null] Component options
     * @param {Mixed} [options.element=null] jQuery selector or DOM element to use for panel
     * @param {String} [options.type=static] static or dynamic list
     * @param {Boolean} [options.nativewidget=false] shows a native select; instead of a SelectList widget
     * @param {Boolean} [options.nativewidgetonmobile=true] forces a native select on a mobile device if possible
     * @param {Boolean} [options.multiple=false] multiple selection, will automatically be detected form a given &lt;select&gt; source
     */
    construct: function () {
      var self = this;

      // find elements
      this._button = this.$element.children('.coral-Select-button');
      this._buttonText = this._button.children('.coral-Select-button-text');
      this._nativeSelect = this.$element.children('.coral-Select-select');
      this._selectList = this.$element.children('.coral-SelectList');
      this._tagList = this.$element.children('.coral-TagList');
      this._valueInput = this.$element.children('input[type=hidden]');

      // apply
      this.applyOptions();
    },

    defaults: {
      type: 'static',
      nativewidget: false,
      nativewidgetonmobile: true,
      multiple: false,
      tagConfig: null,
      selectlistConfig: null
    },

    applyOptions: function () {
      // there is a select given so read the "native" config options
      if (this._nativeSelect.length > 0) {
        // if multiple set multiple
        if (this._nativeSelect.prop('multiple')) {
          this.options.multiple = true;
        }
      }

      // Create SelectList in any case, since it is used to implement
      // add{Option,Group} and getItems APIs.
      this._createSelectList();

      this._nativeSelect.removeClass("coral-Select-select--native");
      this._nativeSelect.off(".selectlist");
      this._button.off(".selectlist");

      switch (this._getModeOfOperation()) {
        case "disabled":
          this._disabledEventHandling();
          break;

        case "nativeselect":
          this._prepareSelectForInteraction();
          this._disableKeyboardInteractionWithSelectList();
          break;

        case "selectlist":
          this._prepareSelectListForInteraction();
          this._disableKeyboardInteractionWithNativeSelect();
          break;

        case "hybrid":
          this._prepareSelectForInteraction();
          this._prepareSelectListForInteraction();

          this._hybridEventHandling();
          this._disableKeyboardInteractionWithNativeSelect();
          break;
      }

      if (this.options.multiple) {
        this._setTagList();
      } else if (this.options.type === 'static') {
        this._handleNativeSelect();
      }

      this._makeAccessible();
    },

    _makeAccessible: function() {
      var labelElementSelector, $labelElement, labelElementId,
          isMacLike = window.navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i) ? true : false;

      this._button.attr({
        'id': this._button.attr('id') || CUI.util.getNextId()
      });

      if (this._button.hasClass('is-invalid')) {
        this._button.attr({
          'aria-invalid': true
        });
        this._nativeSelect.attr({
          'aria-invalid': true
        });
        this._selectList.attr({
          'aria-invalid': true
        });
      }

      if (this._button.hasClass('is-disabled')) {
        this._button.attr({
          'aria-disabled': true,
          'disabled': 'disabled'
        });
        this._nativeSelect.attr({
          'aria-disabled': true,
          'disabled': 'disabled'
        });
        this._selectList.attr({
          'aria-disabled': true
        });
      }

      labelElementSelector = (this._nativeSelect.length && this._nativeSelect.attr('id')) ? 'label[for="'+ this._nativeSelect.attr('id') +'"]' : 'label[for="'+ this._button.attr('id') +'"]';

      $labelElement = $(labelElementSelector);

      $labelElement.attr({
        'id':  $labelElement.attr('id') || CUI.util.getNextId()
      });

      labelElementId = $labelElement.attr('id');

      this._buttonText.attr({
        'id': this._buttonText.attr('id') || CUI.util.getNextId()
      });

      this._button.attr({
        'role': isMacLike ? 'button' : 'combobox',
        'aria-expanded': false,
        'aria-haspopup': true,
        'aria-labelledby': labelElementId ?  this._buttonText.attr('id') + ' ' + labelElementId : null,
        'aria-owns': this._selectList.attr('id'),
        'aria-multiselectable': this.options.multiple || null
      });

      if (this._selectListWidget) {
        this._selectListWidget._makeAccessible();
      }

      this._selectList.attr({
        'aria-controls': this._button.attr('id'),
        'aria-multiselectable': this.options.multiple || null
      });

      if ($labelElement.length && !this._button.is('[aria-hidden=true]')) {
        $labelElement.on('click.selectLabel', function (event) {
          this._button.focus();
          event.preventDefault();
        }.bind(this));
      }
    },

    /**
     * @return {Array|String} current value
     */
    getValue: function () {
      if (this.options.multiple) { // multiple returns array
        return this._tagListWidget.getValues();
      } else if (this.options.type === 'static') { // static
        return this._nativeSelect[0][this._nativeSelect[0].selectedIndex].value;
      } else if (this.options.type === 'dynamic') {
        return this._valueInput.val();
      }

      return null;
    },

    /**
     * Mark the options that match the specified value(s) as selected. Any options
     * not matching one of the specified values will get deselected. Values must
     * be strings for option values can only be strings (because they are
     * stored as DOM attributes).
     *
     * @param {string|Array.<string>} value The string value(s) matching the values
     * of the options that should be marked as selected.
     */
    setValue : function (values) {
      var self = this;

      // Make sure we don't break when `values` is undefined:
      if (values === undefined) {
        values = [];
      }
      // Make sure we convert `values` into a proper array:
      else if (!$.isArray(values)) {
        values = [values];
      }

      var deselectedValues = [];

      var handleOption = function(option) {
        var value = option.getValue(),
          index = values.indexOf(value);

        if (index === -1) {
          deselectedValues.push(value);
        } else {
          self._select(value, option.getDisplay());
        }
      };

      this.getItems().forEach(function(item){
        if (item instanceof CUI.SelectList.Option) {
          handleOption(item);
        } else if (item instanceof CUI.SelectList.Group) {
          item.getItems().forEach(handleOption);
        }
      });

      // Make sure that no previously selected options linger:
      this._deselect(deselectedValues);
    },

    /**
     * Retrieve list of first level list items (groups or options). NB: The list
     * represents a snapshot of the current state. If items are added or
     * removed, the list will become invalid.
     *
     * @return {Array} List of CUI.SelectList.Option and CUI.SelectList.Group
     *                 instances
     */
    getItems : function () {
      return this._selectListWidget.getItems();
    },

    /**
     * Get CUI.SelectList.Option representing the option at the given position.
     *
     * @param {Number} position
     *
     * @returns option
     * @throws {TypeError} if position is not numeric or if position points to
     *         group element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getOption: function (position) {
      return this._selectListWidget.getOption(position);
    },

    /**
     * Get CUI.SelectList.Group representing the group at the given position.
     *
     * @param {Number} position
     *
     * @returns group
     *
     * @throws {TypeError} if position is not numeric or if position points to
     *         option element
     * @throws {RangeError} if position is outside of [0, listLength - 1]
     */
    getGroup: function (position) {
      return this._selectListWidget.getGroup(position);
    },

    /**
     * Adds option at the given position. If position is undefined, the option
     * is added at the end of the list.
     *
     * <b>Please note</b>: Using this API in combination with type="dynamic" is
     * discouraged. Since closing/opening the select will reload the list
     * content, the elements that were added via this method call will be lost.
     *
     * @param {Object|CUI.SelectList.Option|Element|jQuery|Array} option
     *        Option that should be added. If type is Object, the keys `value`
     *        and `display` are used to create the option. If type is
     *        CUI.SelectList.Option, the underlying element is added to the
     *        list. If type is Element, the node is added to the list. If type
     *        is jQuery <b>all</b> elements within the collection are added to
     *        the list. If type is Array, then the array is expected to contain
     *        one of the other types.
     * @param {Number} position
     *        Position at which the element should be inserted. If undefined,
     *        the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addOption : function (option, position) {
      this._selectListWidget.addOption(option, position);
    },

    /**
     * Adds option group at the given position. If position is undefined, the
     * group is added to the end of the list.
     *
     * <b>Please note</b>: Using this API in combination with type="dynamic" is
     * discouraged. Since closing/opening the select will reload the list
     * content, the elements that were added via this method call will be lost.
     *
     * @param {String|CUI.SelectList.Group|Element|jQuery|Array} group
     *        Group that should be added. If type is String, it is used as
     *        display value.  If type is CUI.SelectList.Group, the underlying
     *        element is added to the list. If type is Element, the node is
     *        added to the list.  If type is jQuery <b>all</b> element within
     *        the collection are added to the list. If type is Array, then the
     *        array is expected to contain one of the other types.
     * @param {Number} position
     *        Position at which the element should be inserted. If undefined,
     *        the element is added at the end of the list.
     *
     * @throws {TypeError} if position is not numeric
     * @throws {RangeError} if position is outside of [0, listLength]
     *
     */
    addGroup : function (group, position) {
      this._selectListWidget.addGroup(group, position);
    },

    /**
     * @private
     */
    _getModeOfOperation : function () {
      if (this._button.is(".is-disabled")) {
        return "disabled";
      }
      if (this.options.type === 'dynamic') {
        // Functionality only supported in combination with SelectList component
        return "selectlist";
      }
      if (this.options.nativewidget) {
        // If native widget is set explicitly, we should follow the wish
        return "nativeselect";
      }
      if (this.options.nativewidgetonmobile) {
        // Unless specified otherwise, we want to have native controls on touch
        return "hybrid";
      }

      return "selectlist";
    },


    /**
     * @private
     */
    _disabledEventHandling : function () {
      this._button.on("click.selectlist", function (e) {
        return false;
      });
    },

    /**
     * Sets up event handling for hybrid mode. When a user clicks on the select,
     * which is positioned right above the button, then the opening of the
     * native options list should be aborted. Instead a button click should be
     * emulated. If the user taps on the select, no special handling should take
     * place. Instead the native default behaviour should cause the select to be
     * opened.
     *
     * @private
     */
    _hybridEventHandling : function () {
      var isTouch = false,
          stopClick = false,
          self = this;

      this._nativeSelect
        .on("touchstart.selectlist", function () {
          isTouch = true;
        })
        .on("pointerdown.selectlist", function (e) { // IE 11+
          if (e.originalEvent && e.originalEvent.pointerType === "touch") {
            isTouch = true;
          }
        })
        .on("MSPointerDown.selectlist", function (e) { // IE 10
          if (e.originalEvent && e.originalEvent.pointerType === 2) {
            isTouch = true;
          }
        })
        .on("mousedown.selectlist", function (e) {
          // Ignore touch interaction. We're prefering the defaults in this case
          if (isTouch) {
            isTouch = false;
            return;
          }

          // Ignore everything but left clicks
          if (e.which !== 1) {
            return;
          }

          /**
           * Trying to trick the browser into using the custom SelectList
           * instead of the native select.
           */

          // Avoid display of native options list
          self._nativeSelect.attr("disabled", "disabled");
          setTimeout(function () {
            self._nativeSelect.removeAttr("disabled");
            self._button.focus();
          }, 0);

          stopClick = true;
          self._button.click();
        })
        .on("click.selectlist", function (e) {
          if (stopClick) {
            e.stopPropagation();
            stopClick = false;
          }
        })
        .on("mouseenter.selectlist mouseleave.selectlist", function (e) {
          self._button.toggleClass("is-hovered", e.type === "mouseenter");
        })
        .on("focus.selectlist", function (e) {
          self._button.toggleClass("is-focused", e.type === "focus");
        })
        .on("blur.selectlist", function (e) {
          self._button.removeClass("is-focused");
        });
    },

    /**
     * @private
     */
    _disableKeyboardInteractionWithNativeSelect :  function () {
      // Keyboard focus should not jump to native select
      this._nativeSelect.attr({
        "tabindex": "-1",
        "aria-hidden": true
      });

      this._nativeSelect.off('focusin.nativeselect focusout.nativeselect keydown.nativeselect pointerdown.nativeselect MSPointerDown.nativeselect mousedown.nativeselect');
    },

    /**
     * @private
     */
    _disableKeyboardInteractionWithSelectList : function () {
      // Keyboard focus should not jump to button
      this._button.attr({
        "tabindex": "-1",
        "aria-hidden": true
      });
    },

    /**
     * Applies necessary changes to native select element, so that a user might
     * interact with it.
     *
     * @private
     */
    _prepareSelectForInteraction : function () {
      var self = this;

      self._nativeSelect.addClass("coral-Select-select--native");

      self._nativeSelect.css({
        height: self._button.outerHeight()
      });

      self._nativeSelect.on('change.select', self._handleNativeSelect.bind(self));

      self._nativeSelect.on('focusin.nativeselect', function () {
        self._button.addClass('is-focused');
      });

      self._nativeSelect.on('focusout.nativeselect', function (e) {
        self._button.removeClass('is-focused');
      });
    },

    /**
     * Creates SelectList and initially syncs with native &lt;select&gt;
     *
     * @private
     */
    _createSelectList : function () {
      var self = this,
          type = 'static';

      // if the element is not there, create it
      if (this._selectList.length === 0) {
        this._selectList = $('<ul/>', {
          'id': CUI.util.getNextId(),
          'class': 'coral-SelectList'
        }).appendTo(this.$element);
      } else if (!this._selectList.attr('id')) {
        this._selectList.attr('id', CUI.util.getNextId());
      }

      // read values from markup
      if (this._nativeSelect.length > 0) {
        this._parseMarkup();
      } else { // if no <select> wa found then a dynamic list is expected
        type = 'dynamic';
      }

      this._selectList.selectList($.extend({
        relatedElement: this._button,
        type: type
      }, this.options.selectlistConfig || {}));

      this._selectListWidget = this._selectList.data('selectList');

      this._selectList
        .on("itemadded", this._addItemToSelect.bind(this))
        .on("itemremoved", function (e) {
          var values;

          if (e.item instanceof CUI.SelectList.Group) {
            values = e.item.getItems().map(function(option) { return option.getValue(); });
          } else {
            values = [e.item.getValue()];
          }

          self._deselect(values);
          self._removeItemFromSelect(e);
        });
    },

    /**
     * Event handler, which acts on element insertions to SelectList and updates
     * &lt;select&gt; accordingly.
     *
     * @private
     */
    _addItemToSelect : function (e) {
      var node;
      if (e.item instanceof CUI.SelectList.Option) {
        node = $("<option>");
        node.attr("value", e.item.getValue());
      }
      else if (e.item instanceof CUI.SelectList.Group) {
        node = $("<optgroup>");
      }
      else {
        // something went wrong.
        return;
      }

      node.text(e.item.getDisplay());


      var parentNode = this._nativeSelect;

      if (e.target != this._selectList.get(0)) {
        // Event occured on nested option, find matching optgroup!
        parentNode = parentNode.children().eq($(e.target).closest(".coral-SelectList-item--optgroup").index());
      }

      var position = e.item.getPosition();

      if (position >= parentNode.children().length) {
        parentNode.append(node);
      }
      else if (position === 0) {
        parentNode.prepend(node);
      }
      else {
        parentNode.children().eq(position).before(node);
      }
    },

    /**
     * Event handler, which acts on element removal from SelectList and updates
     * &lt;select&gt; accordingly.
     *
     * @private
     */
    _removeItemFromSelect : function (e) {
      var parentNode = this._nativeSelect;

      if (e.target != this._selectList.get(0)) {
        // Event occured on nested option, find matching optgroup!
        parentNode = parentNode.children().eq($(e.target).closest(".coral-SelectList-item--optgroup").index());
      }

      parentNode.children().eq(e.item.getPosition()).remove();
    },

    /**
     * Creates SelectList if necessary and populates it with the given data. It
     * also binds the button to the SelectList, such that a click on the button
     * toggles the SelectList visibility.
     *
     * @private
     */
    _prepareSelectListForInteraction : function () {
      var self = this;

      this._button.attr({
        'data-toggle': 'selectlist',
        'data-target': '#' + this._selectList.attr('id')
      });

      this._selectList
        // receive the value from the list
        .on('selected.select', this._handleSelectedFromSelectList.bind(this))
        // handle open/hide for the button
        .on('show.select hide.select', function (event) {
          if(event.type !== 'show') {
            self._button.removeClass('is-above is-below');
          }
          self._button.toggleClass('is-active', event.type === 'show');
        });
    },

    /**
     * Handles a native change event on the select
     * @fires Select#selected
     * @private
     */
    _handleNativeSelect: function (event) {
      var self = this,
        selected, selectedElem;

      if (self.options.multiple) {
        // loop over all options
        $.each(self._nativeSelect[0].options, function (i, opt) {
          if (opt.selected) {
            self._tagListWidget.addItem({
              value: opt.value,
              display: opt.text
            });
          } else {
            self._tagListWidget.removeItem(opt.value);
          }
        });

        selected = self._tagListWidget.getValues();
      } else if (self._nativeSelect[0]) {

        selectedElem = self._nativeSelect[0][self._nativeSelect[0].selectedIndex];

        self._buttonText.text(selectedElem ? selectedElem.text : '');

        selected = selectedElem ? selectedElem.value : null;
      }

      if (event) {
        this.$element.trigger($.Event('selected', {
          selected: selected
        }));
      }
    },

    /**
     * Selects options within the native select element using the provided values and deselects any options
     * not matching the provided values.
     * @param selectedValues The values for which options should be selected.
     * @private
     */
    _syncSelectionToNativeSelect: function (selectedValues) {
      if (this._nativeSelect.length) {
        $.each(this._nativeSelect[0].options, function (i, option) {
          option.selected = selectedValues.indexOf(option.value) > -1;
        });
      }
    },

    /**
     * Selects options within the SelectList using the provided values and deselects any options
     * not matching the provided values.
     * @param selectedValues The values for which options should be selected.
     * @private
     */
    _syncSelectionToSelectList: function (selectedValues) {
      if (this._selectList.length) {
        $.each(this._selectList.find(this._selectListWidget._SELECTABLE_SELECTOR), function (i, option) {
          var $option = $(option);
          $option.attr('aria-selected', selectedValues.indexOf($option.attr('data-value')) > -1);
        });
      }
    },

    /**
     * this function parses the values from the native select
     * and prints the right markup for the SelectList widget
     * This function may only be called in SelectList widget mode.
     * @private
     */
    _parseMarkup: function () {
      var self = this,
        optgroup = this._nativeSelect.children('optgroup');

      function parseGroup(parent, dest) {
        parent.children('option').each(function (i, e) {
          var opt = $(e);

          $('<li/>', {
            'class': 'coral-SelectList-item coral-SelectList-item--option',
            'data-value': opt.val(),
            'text': opt.text()
          }).appendTo(dest);
        });
      }

      // optgroups are part of the select -> different markup
      if (optgroup.length > 0) {
        optgroup.each(function (i, e) {
          var group = $(e),
            entry = $('<li/>', {
              'class': 'coral-SelectList-item coral-SelectList-item--optgroup'
            }).append($('<span/>', {
              'class': 'coral-SelectList-groupHeader',
              'text': group.attr('label')
            }));

          parseGroup(group, $('<ul/>', {
            'class': 'coral-SelectList-sublist'
          }).appendTo(entry));

          self._selectList.append(entry);
        });
      } else { // flat select list
        parseGroup(this._nativeSelect, this._selectList);
      }
    },

    /**
     * sets a tag list for the multiple selection
     * @private
     */
    _setTagList: function () {
      var self = this;

      // if the element is not there, create it
      if (this._tagList.length === 0) {
        this._tagList = $('<ol/>', {
          'class': 'coral-TagList'
        }).appendTo(this.$element);
      }

      this._tagList.tagList(this.options.tagConfig || {});

      this._tagListWidget = this._tagList.data('tagList');

      this._tagList.on('itemremoved', function (ev, data) {
        var selectedValues = self._tagListWidget.getValues();
        self._syncSelectionToNativeSelect(selectedValues);
        self._syncSelectionToSelectList(selectedValues);
      });

      // Load selected values from markup
      this._handleNativeSelect();
    },

    _handleSelectedFromSelectList: function(e) {
      // we stop the propagation because the component itself provides a selected event too
      if (e) {
        e.stopPropagation();
      }

      this._selectListWidget.hide();

      this._select(e.selectedValue, e.displayedValue);

      this._button.trigger('focus');

      this.$element.trigger($.Event('selected', {
        selected: this.getValue()
      }));
    },

    /**
     * Select an item.
     * @param value The value of the item to be selected.
     * @param display The display text for the item to be selected.
     * @private
     */
    _select: function (value, display) {
      var newSelectedValues;

      if (this.options.multiple) {
        this._tagListWidget.addItem({
          value: value,
          display: display
        });
        newSelectedValues = this._tagListWidget.getValues();
      } else {
        // set the button label
        this._buttonText.text(display);
        // in case it is dynamic a value input should be existing
        this._valueInput.val(value);
        newSelectedValues = ['' + value];
      }

      this._syncSelectionToNativeSelect(newSelectedValues);
      this._syncSelectionToSelectList(newSelectedValues);
    },

    /**
     * Deselects an item.
     * @param value The value of the item to be deselected.
     * @private
     */
    _deselect: function (values) {
      var self = this,
        newSelectedValues;

      if (this.options.multiple) {
        values.forEach(function(value) {
            self._tagListWidget.removeItem(value);
        });
        newSelectedValues = this._tagListWidget.getValues();
      } else {
        // If the selected value is being deselected, select the first option that's not being deselected if one exists.
        if (values.indexOf(this.getValue()) > -1) {
          var newSelectedOption = this._getFirstOptionWithoutValues(this._getAllOptions(), values),
            newValue,
            newDisplay;

          if (newSelectedOption) {
            newValue = newSelectedOption.getValue();
            newDisplay = newSelectedOption.getDisplay();
            newSelectedValues = [newValue];
          } else {
            newValue = '';
            newDisplay = '';
            newSelectedValues = [];
          }

          this._buttonText.text(newDisplay);
          this._valueInput.val(newValue);
        }
      }

      if (newSelectedValues) {
        this._syncSelectionToNativeSelect(newSelectedValues);
        this._syncSelectionToSelectList(newSelectedValues);
      }
    },

    /**
     * Gets the first option that does not have a value equal to those within an array of provided values.
     * @param {Array} options The options to search through.
     * @param {Array} values A blacklist of values.
     * @returns {CUI.SelectList.Option}
     * @private
     */
    _getFirstOptionWithoutValues: function (options, values) {
      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        if (values.indexOf(option.getValue()) === -1) {
          return option;
        }
      }
    },

    /**
     * Retrieves all options as an array of CUI.SelectList.Option objects.
     * Possibly move this up to CUI.SelectList when/if others need it?
     * @returns {Array}
     * @private
     */
    _getAllOptions: function () {
      var items = this.getItems();
      var options = [];

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (item instanceof CUI.SelectList.Group) {
          options = options.concat(item.getItems());
        } else {
          options.push(item);
        }
      }

      return options;
    }
  });

  CUI.Widget.registry.register("select", CUI.Select);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function (e) {
      CUI.Select.init($('[data-init~=select]', e.target));
    });
  }

  /**
   * Triggered when option was selected
   *
   * @name CUI.Select#selected
   * @event
   *
   * @param {Object} event Event object
   * @param {String|Array} event.selected value which was selected
   *
   */

}(jQuery, this));

(function ($) {

  // Instance id counter:
  var datepicker_guid = 0;

  CUI.Datepicker = new Class(/** @lends CUI.Datepicker# */{
    toString: 'Datepicker',
    extend: CUI.Widget,

    /**
     @extends CUI.Widget
     @classdesc A datepicker widget

     <pre>
     Currently there are the following data options:
     data-init="datepicker"         Inits the datepicker widget after page load
     data-disabled                  Sets field to "disabled" if given (with any non-empty value)
     data-required                  Sets field to "required" if given (with any non-empty value)
     data-stored-format             Sets the format of the date for transferring it to the server
     data-displayed-format          Sets the format of the date for displaying it to the user
     data-force-html-mode           Force to HTML mode and never use a native Date widget, if given (with any non-empty value)
     data-day-names                 JSON-array-data with the short names of all week days, starting with Sunday
     data-month-names               JSON-array-data with the names of all months, starting with January
     data-head-format               Defines headline format, default is "MMMM YYYY".
     data-start-day                 Defines the start day of the week, 0 = Sunday, 1 = Monday, etc.

     Additionally the type (date, time, datetime) and value are read from the &lt;input&gt; field.
     </pre>

     @desc Creates a datepicker from a div element
     @constructs

     @param {Object}  options                                                     Component options
     @param {Array}   [options.monthNames=english names]                          Array of strings with the name for each month with January at index 0 and December at index 11
     @param {Array}   [options.dayNames=english names]                            Array of strings with the name for each weekday with Sun at index 0 and Sat at index 6
     @param {String}  [options.type="date"]                                       Type of picker, supports date, datetime, datetime-local and time
     @param {integer} [options.startDay=0]                                        Defines the start day for the week, 0 = Sunday, 1 = Monday etc.
     @param {boolean} [options.disabled=false]                                    Is this widget disabled?
     @param {String}  [options.displayedFormat="YYYY-MM-DD[T]HH:mm[Z]"]           Displayed date (userfriendly), default is 2012-10-20 20:35
     @param {String}  [options.storedFormat="YYYY-MM-DD[T]HH:mmZ"]                Storage Date format, is never shown to the user, but transferred to the server
     @param {String}  [options.required=false]                                    Is a value required?
     @param {String}  [options.hasError=false]                                    True to display widget as erroneous, regardless if the value is required or not.
     @param {String}  [options.minDate]                                           Defines the start date of selection range. Dates earlier than minDate are not selectable.
     It must be expressed in officialDateFormat (YYYY-MM-DD) or as "today".
     @param {String}  [options.maxDate]                                           Defines the end date of selection range. Dates later than maxDate are not selectable.
     It must be expressed in officialDateFormat (YYYY-MM-DD) or as "today".
     @param {String}  [options.headFormat="MMMM YYYY"]                            Defines calendar headline format, default is "MMMM YYYY"
     @param {boolean} [options.forceHTMLMode=false]                               Force to HTML mode and never use a native Date widget, if given (with any non-empty value)
     @param {String}  [options.selectedDateTime]                                  Defines what date/time will be selected when the calendar is rendered. If nothing is specified it will be
     considerend today or current time.
     */

    defaults: {
      monthNames: null,
      dayNames: null,
      format: null,
      type: "date",
      selectedDateTime: null,
      startDay: 0,
      disabled: false,
      displayedFormat: null,
      storedFormat: null,
      headFormat: "MMMM YYYY",
      forceHTMLMode: false,
      required: false,
      hasError: false,
      minDate: null,
      maxDate: null
    },

    displayDateTime: null,
    pickerShown: false,

    construct: function () {
      this.guid = (datepicker_guid += 1);
      this._readOptionsFromMarkup();
      this._parseOptions();
      this._setupMomentJS();
      this._adjustMarkup();
      this._findElements();
      this._constructPopover();
      this._initialize();
    },

    _readOptionsFromMarkup: function () {
      var options = this.options;
      var element = this.$element;
      var $input = $(element.find("input").filter("[type^=date],[type=time]"));
      if ($input.length !== 0) {
        options.type = $input.attr("type");
      }

      [
        [ "disabled", "disabled", asBoolean ],
        [ "required", "required", asBoolean ],
        [ "displayed-format", "displayedFormat", ifDefined],
        [ "stored-format", "storedFormat", ifDefined],
        [ "force-html-mode", "forceHTMLMode", ifDefined],
        [ "day-names", "dayNames", ifTruthy],
        [ "month-names", "monthNames", ifTruthy ],
        [ "head-format", "headFormat", ifTruthy],
        [ "start-day", "startDay", asNumber],
        [ "min-date", "minDate", ifDefined],
        [ "max-date", "maxDate", ifDefined]
      ].map(function (attr) {
          var name = attr[0], field = attr[1], processor = attr[2];
          processor(element.data(name), field, options);
        });
    },

    _parseOptions: function () {
      var options = this.options;
      options.monthNames = options.monthNames || CUI.Datepicker.monthNames;
      options.dayNames = options.dayNames || CUI.Datepicker.dayNames;

      options.isDateEnabled =
        (options.type === "date") ||
          (options.type === "datetime") ||
          (options.type === "datetime-local");

      options.isTimeEnabled =
        (options.type === "time") ||
          (options.type === "datetime") ||
          (options.type === "datetime-local");

      var i = document.createElement("input");
      i.setAttribute("type", options.type);
      options.supportsInputType = i.type !== "text";

      if (options.minDate !== null) {
        if (options.minDate === "today") {
          options.minDate = moment().startOf("day");
        } else {
          if (moment(options.minDate, OFFICIAL_DATE_FORMAT).isValid()) {
            options.minDate = moment(options.minDate, OFFICIAL_DATE_FORMAT);
          } else {
            options.minDate = null;
          }
        }
      }

      if (options.maxDate !== null) {
        if (options.maxDate === "today") {
          options.maxDate = moment().startOf("day");
        } else {
          if (moment(options.maxDate, OFFICIAL_DATE_FORMAT).isValid()) {
            options.maxDate = moment(options.maxDate, OFFICIAL_DATE_FORMAT);
          } else {
            options.maxDate = null;
          }
        }
      }

      options.storedFormat = options.storedFormat || (options.type === "time" ? OFFICIAL_TIME_FORMAT : OFFICIAL_DATETIME_FORMAT);
      options.displayedFormat = options.displayedFormat || (options.type === "time" ? OFFICIAL_TIME_FORMAT : DISPLAY_FORMAT);
      options.useNativeControls = options.forceHTMLMode;

      if ((!options.forceHTMLMode) &&
        IS_MOBILE_DEVICE &&
        options.supportsInputType) {
        options.useNativeControls = true;
      }

      // If HTML5 input is used, then force to use the official format.
      if (options.useNativeControls) {
        if (options.type === 'date') {
          options.displayedFormat = OFFICIAL_DATE_FORMAT;
        } else if (options.type === 'time') {
          options.displayedFormat = OFFICIAL_TIME_FORMAT;
        } else {
          options.displayedFormat = OFFICIAL_DATETIME_FORMAT;
        }
      }
    },

    _setupMomentJS: function () {
      // Generate a language name for this picker to not overwrite any existing
      // moment.js language definition
      this.options.language = LANGUAGE_NAME_PREFIX + new Date().getTime();

      moment.lang(this.options.language, {
        months: this.options.monthNames,
        weekdaysMin: this.options.dayNames
      });
    },

    _adjustMarkup: function () {
      var $element = this.$element;

      if (!this.options.useNativeControls) {
        var id = "popguid" + this.guid;
        var idQuery = "#" + id + ".coral-Popover";
        this.$popover = $('body').find(idQuery);
        if (this.$popover.length === 0) {
          $('body').append(HTML_POPOVER.replace("%ID%", id));
          this.$popover = $('body').find(idQuery);
          if (this.options.isDateEnabled) {
            this.$popover.find(".coral-Popover-content").append(HTML_CALENDAR);
          }
        }
      } else {
        // Show native control
        this.$popover = [];
      }

      var $hiddenInput = $element.find("input[type=hidden]");

      // Always include hidden field
      if ($hiddenInput.length === 0) {
        // We prepend otherwise the InputGroup will not give round corners to the button last button
        $element.prepend("<input type=\"hidden\">");
      } else {
        // Moves it to the beginning
        $element.prepend($hiddenInput);
      }

      if (!$element.find("input[type=hidden]").attr("name")) {
        var name = $element.find("input").not("[type=hidden]").attr("name");
        $element.find("input[type=hidden]").attr("name", name);
        $element.find("input").not("[type=hidden]").removeAttr("name");
      }
    },

    _findElements: function () {
      this.$input = this.$element.find('input').not("[type=hidden]");
      this.$hiddenInput = this.$element.find('input[type=hidden]');
      this.$openButton = this.$element.find('button');
    },

    _constructPopover: function () {
      if (this.$popover.length) {
        this.popover = new Popover({
          $element: this.$popover,
          $trigger: this.$openButton,
          options: this.options,
          setDateTimeCallback: this._popoverSetDateTimeCallback.bind(this),
          hideCallback: this._popoverHideCallback.bind(this)
        });
      }
    },

    _initialize: function () {

      // we need to listen for disabled changes during
      this.on('change:disabled', this._toggleDisabled.bind(this));

      if (this.options.useNativeControls) {
        this.displayDateTime = this.options.selectedDateTime = moment(this.$input.val(), this.options.displayedFormat);
        this.$openButton.hide();
      } else {
        this._switchInputTypeToText(this.$input);
      }

      this.$openButton.on('click', this._clickHandler.bind(this));
      this.$input.on("change" + (IS_MOBILE_DEVICE ? " blur" : ""), this._inputChangedHandler.bind(this));

      // Reading input value for the first time. There may be a storage format:
      if (!this.options.selectedDateTime) {
        this._readInputVal([this.options.storedFormat, this.options.displayedFormat]);
      }

      // Set the selected date and time:
      this._setDateTime(this.options.selectedDateTime, true);
    },

    _readInputVal: function (format) {
      var value = this.$input.eq(0).val();
      if (value !== '') {
        var date = moment(value, format || this.options.displayedFormat);
        if (!date || !date.isValid()) {
          // Fallback: Try automatic guess if none of our formats match
          date = moment(value);
        }
        this.displayDateTime = this.options.selectedDateTime = date;
        if (date !== null && date.isValid()) {
          this.displayDateTime = this.options.selectedDateTime = date;
        }
      } else {
        this.displayDateTime = null;
      }
    },

    _updateState: function () {

      this._toggleDisabled();

      if (this.options.hasError ||
        (!this.options.selectedDateTime && this.options.required) ||
        (this.options.selectedDateTime && !this.options.selectedDateTime.isValid())
        ) {
        this.$element.addClass("is-invalid");
        this.$element.find("input").addClass("is-invalid");
      } else {
        this.$element.removeClass("is-invalid");
        this.$element.find("input").removeClass("is-invalid");
      }
    },

    _toggleDisabled: function() {
      if (this.options.disabled) {
        this.$element.find("input,button").attr("disabled", "disabled");
        this._hidePicker();
      } else {
        this.$element.find("input,button").removeAttr("disabled");
      }
    },

    _popoverSetDateTimeCallback: function () {
      this._setDateTime.apply(this, arguments);
      if (this.options.isTimeEnabled === false) {
        this._hidePicker();
      }
    },

    _popoverHideCallback: function () {
      this.pickerShown = false;
      this.$element.find("input").removeClass("is-highlighted");
    },

    _switchInputTypeToText: function ($input) {
      var $parent = $input.parent();
      $input.detach().attr('type', 'text').prependTo($parent);
    },

    _openNativeInput: function () {
      this.$input.trigger("click");
    },

    _clickHandler: function (event) {
      // ignores the click if the component is disabled
      if (this.options.disabled) {
        return;
      }

      if (this.pickerShown) {
        this._hidePicker();
      } else {
        // The time-out is a work-around for CUI.Popover issue #1307. Must
        // be taken out once that is fixed:
        var self = this;
        setTimeout(function () {
          self._openPicker();
        }, 100);
      }
    },

    _inputChangedHandler: function () {
      if (this.options.disabled) {
        return;
      }

      var newDate;
      if (this.$input.val() !== '') {
        newDate = moment(this.$input.val(), this.options.displayedFormat);
        this.options.hasError = newDate !== null && !isDateInRange(newDate, this.options.minDate, this.options.maxDate);
      } else {
        this.options.hasError = false;
      }
      this._setDateTime(newDate, true); // Set the date, but don't trigger a change event
    },

    _keyPress: function () {
      if (this.pickerShown) {
        // TODO: Keyboard actions
      }
    },

    _openPicker: function () {
      if (this.options.useNativeControls) {
        this._openNativeInput();
      } else {
        this._readInputVal();
        this._showPicker();
      }
    },

    _showPicker: function () {
      if (!this.pickerShown) {
        this.$element.find("input").addClass("is-highlighted");
        this.popover.show(this.displayDateTime);
        this.pickerShown = true;
      }
    },

    _hidePicker: function () {
      if (this.pickerShown) {
        this.$element.find("input").removeClass("is-highlighted");
        this.popover.hide();
        this.pickerShown = false;
      }
    },

    /**
     * Sets a new datetime object for this picker
     * @private
     */
    _setDateTime: function (date, silent) {
      this.options.selectedDateTime = this.displayDateTime = date;

      if (!date) {
        this.$input.val(""); // Clear for null values
      } else if (date.isValid()) {
        this.$input.val(date.lang(this.options.language).format(this.options.displayedFormat)); // Set only valid dates
      }

      var storage = (date && date.isValid()) ? date.lang('en').format(this.options.storedFormat) : ""; // Force to english for storage format!
      this.$hiddenInput.val(storage);

      this._updateState();

      // Trigger a change even on the input
      if (!silent) {
        this.$input.trigger('change');
      }

      // Always trigger a change event on the hidden input, since we're not listening to it internally
      this.$hiddenInput.trigger('change');
    }
  });

  CUI.Datepicker.monthNames = [
    "January", "February", "March",
    "April", "May", "June",
    "July", "August", "September",
    "October", "November", "December"
  ];

  CUI.Datepicker.dayNames = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];

  CUI.Widget.registry.register("datepicker", CUI.Datepicker);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      CUI.Datepicker.init($("[data-init~=datepicker]", e.target));
    });
  }

  /**
   * Governs the generation and the interaction of the calendar and
   * time selects.
   *
   * @private
   */
  var Popover = new Class({
    toString: 'Popover',
    extend: Object,

    construct: function (options) {
      this.$element = options.$element;
      this.options = options.options;
      this.setDateTimeCallback = options.setDateTimeCallback;
      this.hideCallback = options.hideCallback;

      this.$element.popover();
      this.popover = this.$element.data("popover");
      this.popover.set({
        pointAt: options.$trigger,
        pointFrom: "bottom"
      });

      this._setupListeners();
    },

    /**
     * Public to CUI.Datepicker.
     * Allows the main component to request the calendar pop-up to be shown.
     */
    show: function (displayDateTime) {
      this.displayDateTime = displayDateTime;
      this._renderCalendar();
      if (this.options.isTimeEnabled) {
        this._renderTime();
      }
      this.popover.show();
    },

    /**
     * Public to CUI.Datepicker.
     * Allows the main component to request the calendar pop-up to be hidden.
     */
    hide: function () {
      this.popover.hide();
    },

    /**
     * Register event handlers.
     *
     * @private
     */
    _setupListeners: function () {

      // Pop show-hide:
      this.popover.on("hide", this._popupHideHandler.bind(this));

      // Calendar navigation
      this.$element.find(".coral-DatePicker-calendar").on("swipe", this._swipeHandler.bind(this));
      this.$element.on("mousedown", ".coral-DatePicker-nextMonth", this._mouseDownNextHandler.bind(this));
      this.$element.on("mousedown", ".coral-DatePicker-prevMonth", this._mouseDownPrevHandler.bind(this));

      if (this.options.isTimeEnabled) {
        // for Desktop
        this.$element.on("selected", ".coral-DatePicker-hour, .coral-DatePicker-minute", this._dropdownChangedHandler.bind(this));
        // for Mobile
        this.$element.on("change", ".coral-DatePicker-hour, .coral-DatePicker-minute", this._dropdownChangedHandler.bind(this));
      }
    },

    _popupHideHandler: function (event) {
      this.hideCallback();
    },

    _swipeHandler: function (event) {
      var d = event.direction,
        year = this.displayDateTime.year(),
        month = this.displayDateTime.month();

      if (d === "left") {
        this.displayDateTime = normalizeDate(moment([year, month + 1, 1]));
        this._renderCalendar("left");
      } else if (d === "right") {
        this.displayDateTime = normalizeDate(moment([year, month - 1, 1]));
        this._renderCalendar("right");
      }
    },

    _mouseDownNextHandler: function (event) {
      event.preventDefault();
      if (this.displayDateTime) {
        this.displayDateTime = normalizeDate(moment([this.displayDateTime.year(), this.displayDateTime.month() + 1, 1]));
        this._renderCalendar("left");
      }
    },

    _mouseDownPrevHandler: function (event) {
      event.preventDefault();
      if (this.displayDateTime) {
        this.displayDateTime = normalizeDate(moment([this.displayDateTime.year(), this.displayDateTime.month() - 1, 1]));
        this._renderCalendar("right");
      }
    },

    _dropdownChangedHandler: function () {
      var hours = this._getHoursFromDropdown();
      var minutes = this._getMinutesFromDropdown();
      if (!this.options.selectedDateTime) {
        this.options.selectedDateTime = moment();
      }
      var date = this.options.selectedDateTime.hours(hours).minutes(minutes);
      this.setDateTimeCallback(date);
    },

    _tableMouseDownHandler: function (event) {
      event.preventDefault();
      var date = moment($(event.target).data("date"), OFFICIAL_DATETIME_FORMAT);
      if (this.options.isTimeEnabled) {
        var h = this._getHoursFromDropdown();
        var m = this._getMinutesFromDropdown();
        date.hours(h).minutes(m);
      }
      this.setDateTimeCallback(date);
      this._renderCalendar();
    },

    _renderCalendar: function (slide) {
      var displayDateTime = this.displayDateTime;
      if (!displayDateTime || !displayDateTime.isValid()) {
        this.displayDateTime = displayDateTime = moment();
      }

      var displayYear = displayDateTime.year();
      var displayMonth = displayDateTime.month() + 1;

      var table = this._renderOneCalendar(displayMonth, displayYear);

      var $calendar = this.$element.find(".coral-DatePicker-calendar");

      table.on("mousedown", "a", this._tableMouseDownHandler.bind(this));

      if ($calendar.find("table").length > 0 && slide) {
        this._slideCalendar(table, (slide === "left"));
      } else {
        $calendar.find("table").remove();
        $calendar.find(".coral-DatePicker-calendarSlidingContainer").remove();
        $calendar.find(".coral-DatePicker-calendarBody").append(table);
      }
    },

    _renderOneCalendar: function (month, year) {
      var heading = moment([year, month - 1, 1]).lang(this.options.language).format(this.options.headFormat);
      var title = $('<div class="coral-DatePicker-calendarHeader"><h2 class="coral-Heading coral-Heading--2">' + heading + '</h2></div>').
        append($("<button class=\"coral-MinimalButton coral-DatePicker-nextMonth\">&#x203A;</button>")).
        append($("<button class=\"coral-MinimalButton coral-DatePicker-prevMonth\">&#x2039;</button>"));
      var $calendar = this.$element.find(".coral-DatePicker-calendar");
      var header = $calendar.find(".coral-DatePicker-calendarHeader");
      if (header.length > 0) {
        header.replaceWith(title);
      } else {
        $calendar.prepend(title);
      }

      var table = $("<table>");
      table.data("date", year + "/" + month);

      var html = "<tr>";
      var day = null;
      for (var i = 0; i < 7; i++) {
        day = (i + this.options.startDay) % 7;
        var dayName = this.options.dayNames[day];
        html += "<th><span>" + dayName + "</span></th>";
      }
      html += "</tr>";
      table.append("<thead>" + html + "</thead>");

      var firstDate = moment([year, month - 1, 1]);
      var monthStartsAt = (firstDate.day() - this.options.startDay) % 7;
      if (monthStartsAt < 0) monthStartsAt += 7;

      html = "";
      var today = moment();

      for (var w = 0; w < 6; w++) {
        html += "<tr>";
        for (var d = 0; d < 7; d++) {
          day = (w * 7 + d) - monthStartsAt + 1;
          var displayDateTime = moment([year, month - 1, day]);
          var isCurrentMonth = (displayDateTime.month() + 1) === parseFloat(month);
          var cssClass = "";

          if (isSameDay(displayDateTime, today)) {
            cssClass += " today";
          }

          if (isSameDay(displayDateTime, this.options.selectedDateTime)) {
            cssClass += " selected";
          }

          if (isCurrentMonth && isDateInRange(displayDateTime, this.options.minDate, this.options.maxDate)) {
            html += "<td class=\"" + cssClass + "\"><a href=\"#\" data-date=\"" + displayDateTime.lang(this.options.language).format(OFFICIAL_DATETIME_FORMAT) + "\">" + displayDateTime.date() + "</a></td>";
          } else {
            html += "<td class=\"" + cssClass + "\"><span>" + displayDateTime.date() + "</span></td>";
          }
        }
        html += "</tr>";
      }
      table.append("<tbody>" + html + "</tbody>");

      return table;
    },

    _slideCalendar: function (newtable, isLeft) {

      var containerClass = "coral-DatePicker-calendarSlidingContainer";
      this.$element.find(".coral-DatePicker-calendarSlidingContainer table").stop(true, true);
      this.$element.find(".coral-DatePicker-calendarSlidingContainer").remove();

      var oldtable = this.$element.find("table");
      var width = oldtable.width();
      var height = oldtable.height();

      var container = $("<div class=\"coral-DatePicker-calendarSlidingContainer\">");

      container.css({"display": "block",
        "position": "relative",
        "width": width + "px",
        "height": height + "px",
        "overflow": "hidden"});

      this.$element.find(".coral-DatePicker-calendarBody").append(container);
      container.append(oldtable).append(newtable);
      oldtable.css({"position": "absolute", "left": 0, "top": 0});
      oldtable.after(newtable);
      newtable.css({"position": "absolute", "left": (isLeft) ? width : -width, "top": 0});

      oldtable.animate({"left": (isLeft) ? -width : width}, TABLE_ANIMATION_SPEED, function () {
        oldtable.remove();
      });

      newtable.animate({"left": 0}, TABLE_ANIMATION_SPEED, function () {
        if (container.parents().length === 0) {
          // We already were detached!
          return;
        }
        newtable.css({"position": "relative", "left": 0, "top": 0});
        newtable.detach();
        this.$element.find(".coral-DatePicker-calendarBody").append(newtable);
        container.remove();
      }.bind(this));
    },

    _renderTime: function () {

      var selectedTime = this.options.selectedDateTime;
      var html = $(HTML_CLOCK_ICON);

      // Hours
      var hourSelect = $('<select class="coral-Select-select"></select>');
      for (var h = 0; h < 24; h++) {
        var hourOption = $('<option>' + padSingleDigit(h) + '</option>');
        if (selectedTime && h === selectedTime.hours()) {
          hourOption.attr('selected', 'selected');
        }
        hourSelect.append(hourOption);
      }
      var hourDropdown = $(HTML_HOUR_DROPDOWN).append(hourSelect);

      // Minutes
      var minuteSelect = $('<select class="coral-Select-select"></select>');
      for (var m = 0; m < 60; m++) {
        var minuteOption = $('<option>' + padSingleDigit(m) + '</option>');
        if (selectedTime && m === selectedTime.minutes()) {
          minuteOption.attr('selected', 'selected');
        }
        minuteSelect.append(minuteOption);
      }
      var minuteDropdown = $(HTML_MINUTE_DROPDOWN).append(minuteSelect);

      $(hourDropdown).css(STYLE_POSITION_RELATIVE);
      $(hourDropdown).find('coral-Select').css(STYLE_DROPDOWN_SELECT);
      $(minuteDropdown).css(STYLE_POSITION_RELATIVE);
      $(minuteDropdown).find('coral-Select').css(STYLE_DROPDOWN_SELECT);

      html.append(hourDropdown, $("<span>:</span>"), minuteDropdown);

      if (this.$element.find(".coral-DatePicker-timeControls").length === 0) {
        this.$element.find(".coral-Popover-content").append(html);
      } else {
        this.$element.find(".coral-DatePicker-timeControls").empty().append(html.children());
      }

      // Set up dropdowns
      $(hourDropdown).select();
      $(minuteDropdown).select();
    },

    _getHoursFromDropdown: function () {
      return parseInt(this.$element.find('.coral-DatePicker-timeControls .coral-DatePicker-hour .coral-Select-select').val(), 10);
    },

    _getMinutesFromDropdown: function () {
      return parseInt(this.$element.find('.coral-DatePicker-timeControls .coral-DatePicker-minute .coral-Select-select').val(), 10);
    }

  });

  /**
   * Static
   */

  function padSingleDigit(s) {
    if (s < 10) return "0" + s;
    return s;
  }

  function ifDefined(value, field, options) {
    if (value !== undefined) {
      options[field] = value;
    }
  }

  function asBoolean(value, field, options) {
    options[field] = value ? true : false;
  }

  function ifTruthy(value, field, options) {
    options[field] = value || options[field];
  }

  function asNumber(value, field, options) {
    if (value !== undefined) {
      options[field] = value * 1;
    }
  }

  function normalizeDate(date) {
    if (!date) return null;
    return moment([date.year(), date.month(), date.date()]);
  }

  function isDateInRange(date, startDate, endDate) {
    if (startDate === null && endDate === null) {
      return true;
    }
    if (startDate === null) {
      return date <= endDate;
    } else if (endDate === null) {
      return date >= startDate;
    } else {
      return (startDate <= date && date <= endDate);
    }
  }

  function isSameDay(d1, d2) {
    if (d1 && d2) {
      return d1.year() === d2.year() && d1.month() === d2.month() && d1.date() === d2.date();
    }
  }

  var
    IS_MOBILE_DEVICE = navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/iPhone|iPad|iPod/i),
    OFFICIAL_DATE_FORMAT = 'YYYY-MM-DD',
    OFFICIAL_TIME_FORMAT = 'HH:mm',
    OFFICIAL_DATETIME_FORMAT = 'YYYY-MM-DD[T]HH:mmZ',
    DISPLAY_FORMAT = 'YYYY-MM-DD HH:mm',
    LANGUAGE_NAME_PREFIX = 'coralui_',

    HTML_CALENDAR = [
      '<div class="coral-DatePicker-calendar">',
      '<div class="coral-DatePicker-calendarHeader"></div>',
      '<div class="coral-DatePicker-calendarBody"></div>',
      '</div>'
    ].join(''),
    HTML_POPOVER = [
      '<div class="coral-Popover coral-Popover--datepicker" style="display:none" id="%ID%">',
      '<div class="coral-Popover-content"></div>',
      '</div>'
    ].join(''),

    HTML_CLOCK_ICON = '<div class="coral-DatePicker-timeControls"><i class="coral-Icon coral-Icon--clock coral-Icon--small"></i></div>',
    HTML_HOUR_DROPDOWN = '<div class="coral-Select coral-DatePicker-hour"><button class="coral-Select-button coral-MinimalButton"><span class="coral-Select-button-text"></span></button></div>',
    HTML_MINUTE_DROPDOWN = '<div class="coral-Select coral-DatePicker-minute"><button class="coral-Select-button coral-MinimalButton"><span class="coral-Select-button-text"></span></button></div>',

    STYLE_POSITION_RELATIVE = {
      'position': 'relative'
    },
    STYLE_DROPDOWN_SELECT = {
      'position': 'absolute',
      'left': '1.5rem',
      'top': '1rem'
    },

    TABLE_ANIMATION_SPEED = 400;

}(window.jQuery));

(function ($, window, undefined) {
/**
 HTTP Utility functions used by CoralUI colorpicker for color transformation

 @namespace
 */
CUI.util.color = {

    /**
     * Transforms a string color or part of color (r,g,b) into a hexa value
     * @static
     * @param {String} x The string color or part of color
     * @return {String} Hexa representation
     */
    hex : function (x) {
        return ("0" + parseInt(x, 10).toString(16)).slice(-2);
    },

    /**
     * Transforms a hexa color into RGB representation
     * @static
     * @param {String} hex The string color hexa representation
     * @return {Object} {r, g, b}
     */
    HexToRGB : function(hex) {
        hex = parseInt(((hex.indexOf("#") > -1) ? hex.substring(1) : hex), 16);
        return {
            r : hex >> 16,
            g : (hex & 0x00FF00) >> 8,
            b : (hex & 0x0000FF)
        };
    },

    /**
     * Transforms a rgba color into RGB representation
     * @static
     * @param {String} hex The string color rgba representation
     * @return {String} Hexa representation of the color
     */
    RGBAToHex : function(rgbaVal) {
        var rgba = rgbaVal.substring(rgbaVal.indexOf('(') + 1, rgbaVal.lastIndexOf(')')).split(/,\s*/);
        return '#' + this.hex(rgba[0]) + this.hex(rgba[1]) + this.hex(rgba[2]);
    },

    /**
     * Transforms a rgb color into hexa representation
     * @static
     * @param {Object} {r, g, b}
     * @return {String} The string color hexa representation
     */
    RGBToHex : function(rgb) {
        return '#' + this.hex(rgb.r) + this.hex(rgb.g) + this.hex(rgb.b);
    },

    /**
     * Transforms a cmyk color into RGB representation
     * @static
     * @param {Object} {c, m, y, k}
     * @return {Object} {r, g, b}
     */
    CMYKtoRGB : function (cmyk){
        var result = {r:0, g:0, b:0};

        var c = parseInt(cmyk.c, 10) / 100;
        var m = parseInt(cmyk.m, 10) / 100;
        var y = parseInt(cmyk.y, 10) / 100;
        var k = parseInt(cmyk.k, 10) / 100;

        result.r = 1 - Math.min( 1, c * ( 1 - k ) + k );
        result.g = 1 - Math.min( 1, m * ( 1 - k ) + k );
        result.b = 1 - Math.min( 1, y * ( 1 - k ) + k );

        result.r = Math.round( result.r * 255 );
        result.g = Math.round( result.g * 255 );
        result.b = Math.round( result.b * 255 );

        return result;
    },

    /**
     * Transforms a rgb color into cmyk representation
     * @static
     * @param {Object} {r, g, b}
     * @return {Object} {c, m, y, k}
     */
    RGBtoCMYK : function (rgb){
        var result = {c:0, m:0, y:0, k:0};

        if (parseInt(rgb.r, 10) === 0 && parseInt(rgb.g, 10) === 0 && parseInt(rgb.b, 10) === 0) {
            result.k = 100;
            return result;
        }

        var r = parseInt(rgb.r, 10) / 255;
        var g = parseInt(rgb.g, 10) / 255;
        var b = parseInt(rgb.b, 10) / 255;

        result.k = Math.min( 1 - r, 1 - g, 1 - b );
        result.c = ( 1 - r - result.k ) / ( 1 - result.k );
        result.m = ( 1 - g - result.k ) / ( 1 - result.k );
        result.y = ( 1 - b - result.k ) / ( 1 - result.k );

        result.c = Math.round( result.c * 100 );
        result.m = Math.round( result.m * 100 );
        result.y = Math.round( result.y * 100 );
        result.k = Math.round( result.k * 100 );

        return result;
    },

    /**
     * Corrects a hexa value, if it is represented by 3 or 6 characters with or without '#'
     * @static
     * @param {String} hex The string representation of the hexa value
     * @return {String} Hexa corrected string or empty string if tghe hex value is not valid
     */
    fixHex : function(hex) {
        if (hex.length === 3) {
            hex = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) +
                    hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
        }
        if (hex.indexOf("#") === -1) {
            hex = "#" + hex;
        }
        var isOk = /(^#[0-9A-F]{6})|(^#[0-9A-F]{3})$/i.test(hex);
        if (!isOk) {
            this.$element.find("[name=':hex']").val("");
            return "";
        }

        return hex;
    },

    /**
     * Compares string representations of 2 colors
     * @static
     * @param {String} c1 The string representation of the first color
     * @param {String} c2 The string representation of the seccond color
     * @return {Boolean} True if they are equal, false otherwise
     */
    isSameColor : function(c1, c2) {
        return c1 && c2 && (c1 === c2);
    },

    isValid : function(colorFormat, colorAsStr){
        if(colorAsStr.indexOf(colorFormat) != -1){
            return this.fixHex(this.RGBAToHex(colorAsStr)) !== "";
        }
        return false;
    }

};

}(jQuery, this));
(function ($) {

  var COLORPICKER_FOOTER_TEMPLATE = "<div class=\"coral-ButtonGroup navigation-bar\"></div>";
  var CLASSIC_PALETTE_BUTTON = "<button class='coral-ButtonGroup-item coral-Button coral-Button--secondary' id='classicButton'><i class=\"coral-Icon coral-Icon--viewGrid\"></i></button>";
  var EDIT_BUTTON = "<button class='coral-ButtonGroup-item coral-Button coral-Button--secondary' id='editButton'><i class=\"coral-Icon coral-Icon--edit\"></i></button>";
  var COLOR_SLIDER_BUTTON = "<button class='coral-ButtonGroup-item coral-Button coral-Button--secondary'><i class=\"coral-Icon coral-Icon--properties\"></i></button>";
  var EDIT_MODE = "editMode";
  var CLASSIC_MODE = "classicMode";

  CUI.Colorpicker = new Class(
    /** @lends CUI.Colorpicker# */
    {
      toString: 'Colorpicker',

      extend: CUI.Widget,

      defaults: {
        config: {
          colors: {},
          displayModes: {}
        },
        disabled: false,
        name: null,
        title: ""
      },

      palettePageSize: 3,
      colorShadeNo: 6,
      lowerLimit: 0,
      upperLimit: 0,
      colorNames: [],
      currentPage: 0,
      pages: 1,

      /**
       * @extends CUI.Widget
       * @classdesc Colorpicker will create markup after the template.
       *
       * @desc Creates a new colorpicker
       * @constructs
       */
      construct: function (options) {
        this._readDataFromMarkup();
        this._adjustMarkup();

        if (this.options.config === null ||
          this.options.config.colors.length === 0) {
          this.options.disabled = true;
        }
        if (!this.options.disabled &&
          (this.options.config.displayModes.classicPalette && this.options.config.displayModes.freestylePalette)) {
          this.options.disabled = true;
        }
        if (!this.options.disabled &&
          (this.options.config.displayModes.length === 0 || (!this.options.config.displayModes.classicPalette && !this.options.config.displayModes.freestylePalette))) {
          this.options.config.displayModes.classicPalette = true;
        }

        this.$openButton = this.$element
          .find('.coral-ColorPicker-button');
        this.$hiddenInput = this.$element.find("input[name='" +
          this.options.name + "']");

        if (this.$element.attr("value")) {
          var initialVal = this.$element.attr("value");
          if (CUI.util.color.isValid("rgba", initialVal) || CUI.util.color.isValid("rgb", initialVal)) {
            this._setColor(initialVal);
          } else {
            this.$element.removeAttr("value");
          }

        }

        if (this.options.disabled) {
          this.$element.find(">.coral-ColorPicker-button").attr("disabled",
            "disabled");
        } else {
          this.colorNames = [];
          $.each(this.options.config.colors,
            function (key, value) {
              this.colorNames.push(key);
            }.bind(this));
          $(document).off("tap." + this.options.name + " click." + this.options.name)
                     .on("tap." + this.options.name + " click." + this.options.name, function (event) {
                if (!this.keepShown) {
                  if (this.$popover.has(event.target).length === 0) {
                    this._hidePicker();
                  }
                }
              }.bind(this));

          this.$openButton.on("touchstart click", function (event) {
            try {
              if (!this.pickerShown) {
                this._openPicker();
              } else {
                this._hidePicker();
              }
              this.keepShown = true;
              setTimeout(function () {
                this.keepShown = false;
              }.bind(this), 200);
            } catch (e) {
//                                console.log(e.message);
            }

          }.bind(this));
        }

      },

      _readDataFromMarkup: function () {

        if (this.$element.data("disabled")) {
          this.options.disabled = true;
        }

        if (this.$element.data("name")) {
          this.options.name = this.$element.data("name");
        }

        if (this.$element.attr("title")) {
          this.options.title = this.$element.attr("title");
        }

        var el = this.$element;
        if (el.data('config') !== undefined) {
          this.options.config = {};
          this.options.config.colors = {};
          this.options.config.displayModes = {};
          if (el.data('config').colors) {
            this.options.config.colors = el.data('config').colors;
          } else {
            this.options.disabled = true;
          }
          if (el.data('config').pickerModes) {
            this.options.config.displayModes = el.data('config').pickerModes;
          }
        }
      },

      _adjustMarkup: function () {
        this.$popover = this.$element.find(".coral-Popover");

        if (this.$popover.length === 0) {
          this.$popover = $('<div class="coral-Popover"><div class="coral-ColorPicker-popover-inner coral-Popover-content"></div><div class="coral-ColorPicker-popover-arrow coral-Popover-arrow coral-Popover-arrow--up"></div></div>');

          this.$element
            .append(this.$popover);
          this.$element
            .find(".coral-ColorPicker-popover-inner")
            .append(
              '<div class="colorpicker-holder"><div class="palette-header"></div><div class="colorpicker-body"></div><div class="colorpicker-footer"></div></div>');
        }

        /*this.$popoverWidget = new CUI.Popover({
          element: this.$popover
        });*/

        if (this.$element.find("input[type=hidden]").length === 0) {
          this.$element.append("<input type=\"hidden\" name=\"" +
            this.options.name + "\">");
        }

        var $button = this.$element
          .find('.coral-ColorPicker-button');
        if ($button.attr('type') === undefined) {
          $button.attr('type', 'button');
        }

        $button.attr("data-toggle", "popover");
        $button.attr("data-point-from", "bottom");
      },

      _openPicker: function () {

        this._renderPicker(CLASSIC_MODE);
        this._renderPickerFooter();

        this.$popover.show();
        this.pickerShown = true;
      },

      _hidePicker: function () {
        this.lowerLimit = 0;
        this.upperLimit = 0;
        this.currentPage = 0;
        this.$element.removeClass("focus");
        this.$popover.hide();
        this.pickerShown = false;
      },

      //render color picker based on the palette mode
      _renderPicker: function (mode, slide, pageNo) {

        if (mode === CLASSIC_MODE && !this._calculatePaletteBoundaries(slide, pageNo)) {
          return;
        }

        var table = null;
        if (mode === CLASSIC_MODE) {
          table = this._renderPalette();
        } else {
          table = this._renderEditPalette();
        }

        var $picker = this.$element.find(".colorpicker-holder");
        var $palette_nav = $picker.find(".palette-navigator");
        var $picker_body = $picker.find(".colorpicker-body");

        if (slide && $picker.find("table").length > 0) {
          this._slidePicker(table, (slide === "left"));
        } else {
          //display selected color if any and selected page
          $picker.find("table").remove();
          $picker.find(".sliding-container").remove();
          if (mode === EDIT_MODE) {
            $picker_body.append(table);
            $palette_nav.remove();
            if (this.$hiddenInput.val() !== undefined && this.$hiddenInput.val().length > 0) {
              table.find("div.color").css("background", this.$hiddenInput.val());
              var hex = CUI.util.color.RGBAToHex(this.$hiddenInput.val());
              table.find("input[name=':hex']").val(hex);
              var rgb = CUI.util.color.HexToRGB(hex);
              this._fillRGBFields(rgb);
              var cmyk = CUI.util.color.RGBtoCMYK(rgb);
              this._fillCMYKFields(cmyk);
            }
          } else {
            if ($palette_nav.length > 0) {
              $palette_nav.before(table);
            } else {
              $picker_body.append(table);
              this._renderPaletteNavigation();
            }

          }

        }

      },
      //display navigation mode buttons and select the one corresponding to the current display mode
      _renderPickerFooter: function () {
        this.$element.find(".colorpicker-footer").html(
          COLORPICKER_FOOTER_TEMPLATE);
        if (this.options.config.displayModes !== undefined) {
          if (this.options.config.displayModes.classicPalette ||
            this.options.config.displayModes.freestylePalette) {
            var paletteButton = $(CLASSIC_PALETTE_BUTTON);
            paletteButton.addClass("is-selected");
            this.$element.find(".navigation-bar").append(
              paletteButton);
          }
          if (this.options.config.displayModes.edit) {
            this.$element.find(".navigation-bar").append(
              EDIT_BUTTON);
          } else {
            this.$element.find(".colorpicker-footer").remove();
            return;
          }
        }

        this.$element.find(".colorpicker-footer button")
                     .off("click.button").on("click.button", function (event) {
          event.stopPropagation();
          event.preventDefault();
          var $target = $(event.target);
          var $button = null;
          this.$element.find(
              ".navigation-bar > .is-selected")
            .removeClass("is-selected");
          if (event.target.nodeName === "BUTTON") {
            $target.addClass("is-selected");
            $button = $(event.target);
          } else {
            $target.parent().addClass(
              "is-selected");
            $button = $target.parent();
          }
          if ($button.attr("id") === "editButton") {
            this._renderPicker(EDIT_MODE);
          } else {
            this._renderPicker(CLASSIC_MODE, false, this.currentPage);
          }

        }.bind(this));
      },
      //function for palette navigation
      _calculatePaletteBoundaries: function (slide, pageNo) {
        var colorsPerPage = 0;
        if (this.options.config.displayModes.freestylePalette) {
          colorsPerPage = this.palettePageSize *
            this.colorShadeNo;
        } else {
          colorsPerPage = this.palettePageSize;
        }
        if (!slide) {
          if (pageNo !== undefined) {
            this.lowerLimit = colorsPerPage * pageNo;
            this.upperLimit = this.lowerLimit + colorsPerPage -
              1;
            this.currentPage = pageNo;
          } else {
            this.upperLimit += colorsPerPage - 1;
            this.lowerLimit = 0;
            this.currentPage = 0;
          }
        } else if (slide === "left") {
          pageNo = this.currentPage + 1;
          if (pageNo + 1 > this.pages) {
            return false;
          }
          this.lowerLimit = colorsPerPage * pageNo;
          this.upperLimit = this.lowerLimit + colorsPerPage - 1;
          this.currentPage = pageNo;
        } else {
          pageNo = this.currentPage - 1;
          if (pageNo < 0) {
            return false;
          }
          this.lowerLimit = colorsPerPage * pageNo;
          this.upperLimit = this.lowerLimit + colorsPerPage - 1;
          this.currentPage = pageNo;
        }
        return true;
      },
      //display navigation bullets
      _renderPaletteNavigation: function () {
        this.$element.find(".palette-navigator").remove();
        var navigator = $("<div>");
        navigator.addClass("palette-navigator");
        if (this.options.config.displayModes.classicPalette) {
          this.pages = Math.ceil(this.colorNames.length /
            this.palettePageSize);
        } else {
          this.pages = Math.ceil(this.colorNames.length /
            (this.palettePageSize * this.colorShadeNo));
        }
        if (this.pages > 1) {
          for (var i = 0; i < this.pages; i++) {
            navigator.append("<i class='dot coral-Icon coral-Icon--circle' page='" + i +
              "'></i>");
          }
        }
        this.$element.find(".colorpicker-body").append(navigator);
        this.$element.find("i[page='" + this.currentPage + "']")
          .addClass("is-active");

        // Move around
        this.$element.find(".colorpicker-body").on("swipe",
          function (event) {
            this._renderPicker(CLASSIC_MODE, event.direction === "left" ? "left" : "right");
          }.bind(this));
        this.$element.find(".dot").off("click.dot").on("click.dot", function (event) {
          event.stopPropagation();

          if (this.currentPage === parseInt($(event.target).attr("page"), 10)) {
            return;
          }

          this._renderPicker(CLASSIC_MODE, false, parseInt($(event.target).attr("page"), 10));
        }.bind(this));
      },

      _slidePicker: function (newtable, isLeft) {
        this.$element.find(".sliding-container table").stop(true,
          true);
        this.$element.find(".sliding-container").remove();

        var oldtable = this.$element.find("table");
        var width = oldtable.width();
        var height = oldtable.height();

        var container = $("<div class=\"sliding-container\">");

        container.css({
          "display": "block",
          "position": "relative",
          "width": width + "px",
          "height": height + "px",
          "overflow": "hidden"
        });

        this.$element.find(".palette-navigator").before(container);
        container.append(oldtable).append(newtable);
        oldtable.css({
          "position": "absolute",
          "left": 0,
          "top": 0
        });
        oldtable.after(newtable);
        newtable.css({
          "position": "absolute",
          "left": (isLeft) ? width : -width,
          "top": 0
        });

        var speed = 400;

        oldtable.animate({
          "left": (isLeft) ? -width : width
        }, speed, function () {
          oldtable.remove();
        });

        newtable.animate({
          "left": 0
        }, speed, function () {
          if (container.parents().length === 0)
            return; // We already were detached!
          newtable.css({
            "position": "relative",
            "left": 0,
            "top": 0
          });
          newtable.detach();
          this.$element.find(".palette-navigator").before(
            newtable);
          container.remove();
        }.bind(this));
      },
      //render the selected color name and hex code
      _renderPaletteHeader: function () {
        var title = $('<div class="palette-header"><div class="title"></div><div class="selection"></div></div>');
        var $picker = this.$element.find(".colorpicker-holder");
        if ($picker.find(".palette-header").length > 0) {
          $picker.find(".palette-header").replaceWith(title);
        } else {
          $picker.prepend(title);
        }
        $picker.find(".title").html(
          "<span>" + this.options.title + "</span>");
      },

      _renderPalette: function () {
        this._renderPaletteHeader();

        var table = $("<table>");
        var html = "";

        for (var i = 0; i < this.palettePageSize; i++) {
          html += "<tr>";
          var opacity = 0;
          var rgb = "";
          var cssClass = "";
          var shade = "";
          for (var sh = 0; sh < this.colorShadeNo; sh++) {
            if (this.options.config.displayModes.classicPalette) {
              //display colors with shades
              if (this.colorNames.length - 1 < i +
                this.lowerLimit) {
                html += "<td><a></a></td>";
              } else {
                rgb = CUI.util.color.HexToRGB(this.options.config.colors[this.colorNames[i +
                  this.lowerLimit]]);
                shade = "rgba(" + rgb.r + "," + rgb.g +
                  "," + rgb.b + "," +
                  (1 - opacity).toFixed(2) + ")";
                opacity += 0.16;
                if (CUI.util.color.isSameColor(shade,
                  this.$hiddenInput.val())) {
                  cssClass = "is-selected";
                  this._fillSelectedColor(this.colorNames[i + this.lowerLimit], CUI.util.color.RGBAToHex(shade));
                } else {
                  cssClass = "";
                }
                html += "<td class='filled'><a style='background-color:" +
                  shade +
                  "' color='" +
                  shade +
                  "' colorName='" +
                  this.colorNames[i + this.lowerLimit] +
                  "' class='" +
                  cssClass +
                  "'>" +
                  "</a></td>";
              }
            } else {
              //display colors without shades (freestyle)
              if (this.colorNames.length - 1 < i *
                this.colorShadeNo + sh) {
                html += "<td><a></a></td>";
              } else {
                rgb = CUI.util.color.HexToRGB(this.options.config.colors[this.colorNames[i *
                  this.colorShadeNo + sh]]);
                shade = "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + 1 + ")";
                if (CUI.util.color.isSameColor(shade,
                  this.$hiddenInput.val())) {
                  cssClass = "is-selected";
                } else {
                  cssClass = "";
                }
                html += "<td class='filled'><a style='background-color:" +
                  shade +
                  "' color='" +
                  shade +
                  "' colorName='" +
                  this.colorNames[i *
                    this.colorShadeNo + sh] +
                  "' class='" +
                  cssClass +
                  "'>" +
                  "</a></td>";
              }
            }
          }
          html += "</tr>";
        }
        table.append("<tbody>" + html + "</tbody>");
        //click on a color box
        table.find("a").off("click.a").on("click.a", function (event) {
          event.stopPropagation();
          event.preventDefault();

          if (CUI.util.color.isSameColor(this.$hiddenInput
            .val(), $(event.target).attr(
            "color"))) {
            return;
          }


          var previousSelected =  this.$element.find("table").find(".is-selected");
          previousSelected.removeClass("is-selected");
          previousSelected.find("i").remove();

          var selected = $(event.target);
          selected.addClass("is-selected");
          selected.html('<i class="coral-Icon coral-Icon--check"></i>');
          $(event.target).addClass("is-selected");

          var colorName = $(event.target).attr("colorName") !== undefined ? $(event.target).attr("colorName") : "";
          this._fillSelectedColor(colorName, CUI.util.color.RGBAToHex($(event.target).attr("color")));

          this._setColor($(event.target).attr("color"));
        }.bind(this));
        var $navigator = this.$element.find(".palette-navigator");
        $navigator.find(".is-active").removeClass("is-active");
        $navigator.find("i[page='" + this.currentPage + "']").addClass("is-active");

        return table;
      },

      _fillSelectedColor: function (colorName, hexVal) {
        this.$element.find(".colorpicker-holder").find(".selection")
          .html(
            "<div><span>" +
              colorName +
              "</span><span>" +
              hexVal +
              "</span></div>");
      },
      //render edit mode screen
      _renderEditPalette: function () {
        var table = $("<table>");
        var html = "<tr>" +
          //hex color representation
          "<td colspan='2' rowspan='2' class='color-field'>" +
          "<div class='color'></div>" +
          "</td>" +
          "<td class='label'>HEX</td>" +
          "<td colspan='2'>" +
          "<input class='coral-Textfield' type='text' name=':hex'/>" +
          "</td>" +
          "<td colspan='2'>&nbsp;</td>" +
          "</tr>" +
          //RGB color representation in 3 input fields(r, g,b)
          "<tr>" +
          "<td class='label'>RGB</td>" +
          "<td>" +
          "<input class='coral-Textfield' type='text' name=':rgb_r'/>" +
          "</td>" +
          "<td>" +
          "<input class='coral-Textfield' type='text' name=':rgb_g'/>" +
          "</td>" +
          "<td>" +
          "<input class='coral-Textfield' type='text' name=':rgb_b'/>" +
          "</td>" +
          "<td>&nbsp;</td>" +
          "</tr>" +
          //CMYK color representation in 4 input fields(c,m,y,k)
          "<tr>" +
          "<td colspan='2'>&nbsp;</td>" +
          "<td class='label'>CMYK</td>" +
          "<td>" +
          "<input class='coral-Textfield' type='text' name=':cmyk_c'/>" +
          "</td>" +
          "<td>" +
          "<input class='coral-Textfield' type='text' name=':cmyk_m'/>" +
          "</td>" +
          "<td>" +
          "<input class='coral-Textfield' type='text' name=':cmyk_y'/" +
          "</td>" +
          "<td>" +
          "<input class='coral-Textfield' type='text' name=':cmyk_k'/>" +
          "</td>" +
          "</tr>" +
          //save button to store the color on the launcher
          "<tr>" +
          "<td colspan='3'>&nbsp;</td>" +
          "<td colspan='4'>" +
          "<button class='coral-Button coral-Button--primary'>Save Color</button>" +
          "</td>" +
          "</tr>";

        table.append("<tbody>" + html + "</tbody>");

        this.$element.find(".palette-header").remove();
        //input validations for change events
        table.find("input[name^=':rgb_']").each(function (index, element) {
          $(element).attr("maxlength", "3");
          $(element).on("blur", function (event) {
            var rgbRegex = /^([0]|[1-9]\d?|[1]\d{2}|2([0-4]\d|5[0-5]))$/;
            if (!rgbRegex.test($(event.target).val().trim()) || $("input:text[value=''][name^='rgb_']").length > 0) {
              $(event.target).val("");
              this._clearCMYKFields();
              this.$element.find("input[name=':hex']").val("");
              this.$element.find("div.color").removeAttr("style");
              return;
            }
            var rgb = {r: this.$element.find("input[name=':rgb_r']").val(), g: this.$element.find("input[name=':rgb_g']").val(), b: this.$element.find("input[name=':rgb_b']").val()};
            var cmyk = CUI.util.color.RGBtoCMYK(rgb);
            var hex = CUI.util.color.RGBToHex(rgb);
            this._fillCMYKFields(cmyk);
            this.$element.find("input[name=':hex']").val(hex);
            this.$element.find("div.color").css("background", hex);
          }.bind(this));
        }.bind(this));
        table.find("input[name^=':cmyk_']").each(function (index, element) {
          $(element).attr("maxlength", "3");
          $(element).on("blur", function (event) {
            var cmykRegex = /^[1-9]?[0-9]{1}$|^100$/;
            if (!cmykRegex.test($(event.target).val().trim()) || $("input:text[value=''][name^='cmyk_']").length > 0) {
              $(event.target).val("");
              this._clearRGBFields();
              this.$element.find("input[name=':hex']").val("");
              this.$element.find("div.color").removeAttr("style");
              return;
            }
            var cmyk = {c: this.$element.find("input[name=':cmyk_c']").val(), m: this.$element.find("input[name=':cmyk_m']").val(), y: this.$element.find("input[name=':cmyk_y']").val(), k: this.$element.find("input[name=':cmyk_k']").val()};
            var rgb = CUI.util.color.CMYKtoRGB(cmyk);
            var hex = CUI.util.color.RGBToHex(rgb);
            this.$element.find("input[name=':hex']").val(hex);
            this._fillRGBFields(rgb);
            this.$element.find("div.color").css("background", hex);
          }.bind(this));
        }.bind(this));
        table.find("input[name=':hex']").each(function (index, element) {
          $(element).attr("maxlength", "7");
          $(element).on("blur", function (event) {
            var hex = CUI.util.color.fixHex($(event.target).val().trim());
            if (hex.length === 0) {
              this._clearRGBFields();
              this._clearCMYKFields();
              this.$element.find("div.color").removeAttr("style");
              return;
            }
            var rgb = CUI.util.color.HexToRGB(hex);
            var cmyk = CUI.util.color.RGBtoCMYK(rgb);
            this._fillRGBFields(rgb);
            this._fillCMYKFields(cmyk);
            table.find("div.color").css("background", hex);
          }.bind(this));
        }.bind(this));

        table.on("click", "input, div",
          function (event) {
            event.stopPropagation();
            event.preventDefault();

          });
        table.on("click", "button",
          function (event) {
            event.stopPropagation();
            event.preventDefault();
            if (this.$element.find("input[name=':hex']").val() !== undefined && this.$element.find("input[name=':hex']").val().length > 0) {
              this._setColor(this.$element.find("input[name=':hex']").val());
            }
          }.bind(this));

        return table;
      },
      //set selected color on the launcher
      _setColor: function (color) {
        this.$hiddenInput.val(color);
        this.$openButton.css("background-color", this.$hiddenInput
          .val());
      },

      _fillRGBFields: function (rgb) {
        this.$element.find("input[name=':rgb_r']").val(rgb.r);
        this.$element.find("input[name=':rgb_g']").val(rgb.g);
        this.$element.find("input[name=':rgb_b']").val(rgb.b);
      },

      _clearRGBFields: function () {
        this.$element.find("input[name^=':rgb']").val("");
      },

      _fillCMYKFields: function (cmyk) {
        this.$element.find("input[name=':cmyk_c']").val(cmyk.c);
        this.$element.find("input[name=':cmyk_m']").val(cmyk.m);
        this.$element.find("input[name=':cmyk_y']").val(cmyk.y);
        this.$element.find("input[name=':cmyk_k']").val(cmyk.k);
      },

      _clearCMYKFields: function () {
        this.$element.find("input[name^=':cmyk']").val("");
      }

    });

  CUI.Widget.registry.register("colorpicker", CUI.Colorpicker);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      CUI.Colorpicker.init($("[data-init~=colorpicker]", e.target));
    });
  }
}(window.jQuery));


(function ($) {
  "use strict";

  var ns = ".coral-DragAction";

  /**
   * Find for the first parent that has an overflow of hidden, auto or scroll.
   * @ignore
   */
  function getViewContainer(element) {
    while (true) {
      var p = element.parent();

      if (p.length === 0) return p;
      if (p.is("body")) return p;

      var flow = p.css("overflow");
      if (flow === "hidden" || flow === "auto" || flow === "scroll") return p;

      element = p;
    }
  }

  function pagePosition(event) {
    var touch = {};
    if (event.originalEvent) {
      var o = event.originalEvent;
      if (o.changedTouches && o.changedTouches.length > 0) {
        touch = o.changedTouches[0];
      }
      if (o.touches && o.touches.length > 0) {
        touch = o.touches[0];
      }
    }

    return {
      x: touch.pageX || event.pageX,
      y: touch.pageY || event.pageY
    };
  }

  function within(x, y, element) {
    var offset = element.offset();
    return x >= offset.left && x < (offset.left + element.outerWidth()) &&
      y >= offset.top && y < offset.top + element.outerHeight();
  }


  CUI.DragAction = new Class(/** @lends CUI.DragAction# */{
    /**
     @classdesc

     @desc Constructs a new Drag Action. After the initialization the drag is performed immediatly.
     @constructs

     @param {Event} event The event that triggered the drag
     @param {jQuery} source The element that is the source of this drag
     @param {jQuery} dragElement The element that will be dragged
     @param {Array} dropZones An Array of elements that can be destinations for this drag
     @param {String} [restrictAxis] Restricts the drag movement to a particular axis. Value: ("horizontal" | "vertical")
     */
    construct: function (event, source, dragElement, dropZones, restrictAxis) {
      this.sourceElement = source;
      this.dragElement = dragElement;
      this.container = getViewContainer(dragElement);
      this.containerHeight = this.container.get(0).scrollHeight; // Save current container height before we start dragging
      this.dropZones = dropZones;
      this.axis = restrictAxis;
      this.scrollZone = 20; // Use 20px as scrolling zone, static for now

      this.dragStart(event);
    },

    currentDragOver: null,

    dragStart: function (event) {
      event.preventDefault();

      var p = this.dragElement.position();
      var pp = pagePosition(event);

      this.dragElement.css({
        "left": p.left,
        "top": p.top,
        "width": this.dragElement.width() + "px"
      }).addClass("is-dragging");

      this.dragStart = {x: pp.x - p.left, y: pp.y - p.top};

      $(document).on("touchmove" + ns + " mousemove" + ns, this.drag.bind(this));
      $(document).on("touchend" + ns + " mouseup" + ns, this.dragEnd.bind(this));

      this.sourceElement.trigger(this._createEvent("dragstart", event));

      this.drag(event);
    },

    drag: function (event) {
      event.preventDefault();

      var pos = pagePosition(event);

      // Need to scroll?
      if (this.container.is("body")) {
        if (pos.y - this.container.scrollTop() < this.scrollZone) {
          this.container.scrollTop(pos.y - this.scrollZone);
        }
        if (pos.y - this.container.scrollTop() > this.container.height() - this.scrollZone) {
          this.container.scrollTop(pos.y - this.container.height() - this.scrollZone);
        }
      } else {
        var oldTop = this.container.scrollTop();
        var t = this.container.offset().top + this.scrollZone;

        if (pos.y < t) {
          this.container.scrollTop(this.container.scrollTop() - (t - pos.y));
        }

        var h = this.container.offset().top + this.container.height() - this.scrollZone;

        if (pos.y > h) {
          var s = Math.min(this.container.scrollTop() + (pos.y - h), Math.max(this.containerHeight - this.container.height(), 0));
          this.container.scrollTop(s);
        }

        var newTop = this.container.scrollTop();
        this.dragStart.y += oldTop - newTop; // Correct drag start position after element scrolling
      }

      var newCss = {};
      if (this.axis !== "horizontal") {
        newCss.top = pos.y - this.dragStart.y;
      }
      if (this.axis !== "vertical") {
        newCss.left = pos.x - this.dragStart.x;
      }

      this.dragElement.css(newCss);

      this.triggerDrag(event);
    },

    dragEnd: function (event) {
      event.preventDefault();

      this.dragElement.removeClass("is-dragging");
      this.dragElement.css({top: "", left: "", width: ""});

      $(document).off(ns);

      this.triggerDrop(event);

      if (this.currentDragOver) {
        $(this.currentDragOver).trigger(this._createEvent("dragleave", event));
      }

      this.sourceElement.trigger(this._createEvent("dragend", event));
    },

    triggerDrag: function (event) {
      var dropElement = this._getCurrentDropZone(event);

      if (dropElement === this.currentDragOver) {
        if (this.currentDragOver) {
          $(this.currentDragOver).trigger(this._createEvent("dragover", event));
        }
        return;
      }

      if (this.currentDragOver) {
        $(this.currentDragOver).trigger(this._createEvent("dragleave", event));
      }

      this.currentDragOver = dropElement;

      if (this.currentDragOver) {
        $(this.currentDragOver).trigger(this._createEvent("dragenter", event));
      }
    },

    triggerDrop: function (event) {
      var dropElement = this._getCurrentDropZone(event);

      if (!dropElement) return;

      dropElement.trigger(this._createEvent("drop", event));
    },

    _getCurrentDropZone: function (event) {
      var pos = pagePosition(event);

      var dropElement = null;

      $.each(this.dropZones, function (index, value) {
        if (within(pos.x, pos.y, value)) {
          dropElement = value;
          return false;
        }
      });

      return dropElement;
    },

    _createEvent: function (name, fromEvent) {
      var pos = pagePosition(fromEvent);

      var event = jQuery.Event(name);
      event.pageX = pos.x;
      event.pageY = pos.y;
      event.sourceElement = this.sourceElement;
      event.item = this.dragElement;

      return event;
    }

  /**
   * Triggered on the drag source, when drag is started.
   *
   * @event CUI.DragAction#dragstart
   * @type {Object}
   *
   * @property {Number} pageX - Pointer position on x-axis
   * @property {Number} pageY - Pointer position on y-axis
   * @property {jQuery} sourceElement - container on from which the drag was initiated
   * @property {jQuery} item - element which is dragged
   */
  /**
   * Triggered on <em>a potential</em> drag target, when dragged element is
   * moved <strong>into</strong> the target's boundaries.
   *
   * @event CUI.DragAction#dragenter
   * @type {Object}
   *
   * @property {Number} pageX - Pointer position on x-axis
   * @property {Number} pageY - Pointer position on y-axis
   * @property {jQuery} sourceElement - container on from which the drag was initiated
   * @property {jQuery} item - element which is dragged
   */
  /**
   * Triggered on <em>a potential</em> drag target, when dragged element is
   * moved <strong>within</strong> the target's boundaries.
   *
   * @event CUI.DragAction#dragover
   * @type {Object}
   *
   * @property {Number} pageX - Pointer position on x-axis
   * @property {Number} pageY - Pointer position on y-axis
   * @property {jQuery} sourceElement - container on from which the drag was initiated
   * @property {jQuery} item - element which is dragged
   */
  /**
   * Triggered on <em>a potential</em> drag target, when dragged element is
   * moved <strong>out of</strong> the target's boundaries.
   *
   * @event CUI.DragAction#dragleave
   * @type {Object}
   *
   * @property {Number} pageX - Pointer position on x-axis
   * @property {Number} pageY - Pointer position on y-axis
   * @property {jQuery} sourceElement - container on from which the drag was initiated
   * @property {jQuery} item - element which is dragged
   */
  /**
   * Triggered on the drag target, when dragged element is dropped within the
   * target's boundaries.
   *
   * @event CUI.DragAction#drop
   * @type {Object}
   *
   * @property {Number} pageX - Pointer position on x-axis
   * @property {Number} pageY - Pointer position on y-axis
   * @property {jQuery} sourceElement - container on from which the drag was initiated
   * @property {jQuery} item - element which is dragged
   */
  /**
   * Triggered on the drag source, when drag is complete. This is always the
   * last event emitted by a DragAction.
   *
   * @event CUI.DragAction#dragend
   * @type {Object}
   *
   * @property {Number} pageX - Pointer position on x-axis
   * @property {Number} pageY - Pointer position on y-axis
   * @property {jQuery} sourceElement - container on from which the drag was initiated
   * @property {jQuery} item - element which is dragged
   */

  });
})(jQuery);

(function ($, console) {
  "use strict";

  var addButton =
    "<button type=\"button\" class=\"js-coral-Multifield-add coral-Multifield-add coral-Button\">" +
    "Add field" +
    "</button>";

  var removeButton =
    "<button type=\"button\" class=\"js-coral-Multifield-remove coral-Multifield-remove coral-Button coral-Button--square coral-Button--quiet\">" +
      "<i class=\"coral-Icon coral-Icon--sizeS coral-Icon--delete coral-Button-icon\"></i>" +
    "</button>";

  var moveButton =
    "<button type=\"button\" class=\"js-coral-Multifield-move coral-Multifield-move coral-Button coral-Button--square coral-Button--quiet\">" +
      "<i class=\"coral-Icon coral-Icon--sizeS coral-Icon--moveUpDown coral-Button-icon\"></i>" +
    "</button>";

  var listTemplate =
    "<ol class=\"js-coral-Multifield-list coral-Multifield-list\"></ol>";

  var fieldTemplate =
    "<li class=\"js-coral-Multifield-input coral-Multifield-input\">" +
    "<div class=\"js-coral-Multifield-placeholder\"></div>" +
    removeButton +
    moveButton +
    "</li>";


  CUI.Multifield = new Class(/** @lends CUI.Multifield# */{
    toString: "Multifield",
    extend: CUI.Widget,

    /**
     @extends CUI.Widget

     @classdesc A composite field that allows you to add/reorder/remove multiple instances of a component.
     The component is added based on a template defined in a <code>&lt;script type=&quot;text/html&quot;&gt;</code> tag.
     The current added components are managed inside a <code>ol</code> element.

     @desc Creates a Multifield component.
     @constructs
     */
    construct: function (options) {
      this.script = this.$element.find(".js-coral-Multifield-input-template");
      this.ol = this.$element.children(".js-coral-Multifield-list");

      if (this.ol.length === 0) {
        this.ol = $(listTemplate).prependTo(this.$element);
      }

      this._adjustMarkup();
      this._addListeners();
    },

    /**
     * Enhances the markup required for multifield.
     * @private
     */
    _adjustMarkup: function () {
      this.$element.addClass("coral-Multifield");
      this.ol.children(".js-coral-Multifield-input").append(removeButton, moveButton);
      this.ol.after(addButton);
    },

    /**
     * Initializes listeners.
     * @private
     */
    _addListeners: function () {
      var self = this;

      this.$element.on("click", ".js-coral-Multifield-add", function (e) {
        var item = $(fieldTemplate);
        item.find(".js-coral-Multifield-placeholder").replaceWith(self.script.html().trim());
        item.appendTo(self.ol);
        $(self.ol).trigger("cui-contentloaded");
      });

      this.$element.on("click", ".js-coral-Multifield-remove", function (e) {
        $(this).closest(".js-coral-Multifield-input").remove();
      });

      this.$element
        .on("taphold mousedown", ".js-coral-Multifield-move", function (e) {
          e.preventDefault();

          var item = $(this).closest(".js-coral-Multifield-input");
          item.prevAll().addClass("coral-Multifield-input--dragBefore");
          item.nextAll().addClass("coral-Multifield-input--dragAfter");

          // Fix height of list element to avoid flickering of page
          self.ol.css({height: self.ol.height() + $(e.item).height() + "px"});
          new CUI.DragAction(e, self.$element, item, [self.ol], "vertical");
        })
        .on("dragenter", function (e) {
          self.ol.addClass("drag-over");
          self._reorderPreview(e);
        })
        .on("dragover", function (e) {
          self._reorderPreview(e);
        })
        .on("dragleave", function (e) {
          self.ol.removeClass("drag-over").children().removeClass("coral-Multifield-input--dragBefore coral-Multifield-input--dragAfter");
        })
        .on("drop", function (e) {
          self._reorder($(e.item));
          self.ol.children().removeClass("coral-Multifield-input--dragBefore coral-Multifield-input--dragAfter");
        })
        .on("dragend", function (e) {
          self.ol.css({height: ""});
        });
    },

    _reorder: function (item) {
      var before = this.ol.children(".coral-Multifield-input--dragAfter").first();
      var after = this.ol.children(".coral-Multifield-input--dragBefore").last();

      if (before.length > 0) item.insertBefore(before);
      if (after.length > 0) item.insertAfter(after);
    },

    _reorderPreview: function (e) {
      this.ol.children(":not(.is-dragging)").each(function () {
        var el = $(this);
        var isAfter = e.pageY < (el.offset().top + el.outerHeight() / 2);
        el.toggleClass("coral-Multifield-input--dragAfter", isAfter);
        el.toggleClass("coral-Multifield-input--dragBefore", !isAfter);
      });
    }
  });

  CUI.Widget.registry.register("multifield", CUI.Multifield);

  if (CUI.options.dataAPI) {
    $(document).on("cui-contentloaded.data-api", function (e) {
      CUI.Multifield.init($("[data-init~=multifield]", e.target));
    });
  }
})(jQuery, window.console);

(function ($, window, undefined) {
  CUI.ColumnView = new Class(/** @lends CUI.ColumnView */{
    toString: 'ColumnView',
    extend: CUI.Widget,

    defaults: {
      multiselect: false,
      single: false
    },

    /**
     * Creates a new ColumnView
     *
     * @extends CUI.Widget
     * @classdesc A widget for column-based (miller or single) navigation
     * @constructs
     * @param {Object} options Component options
     * @param {Boolean} [options.multiselect=false] whether multiple items should be selectable
     * @param {Boolean} [options.single=false] whether the widget should be single column mode, which means that a single column is
     *        displayed at one time; good for low-horizontal space situations
     */
    construct: function() {
      this._activeColumnRequest = 0;

      this.$element.addClass('coral-ColumnView');

      if (this.get('single') || this.$element.hasClass('coral-ColumnView--single')) {
        this.set('single', true);
        this.$element.addClass('coral-ColumnView--single');
      }

      if (this.get('multiselect') || this.$element.hasClass('coral-ColumnView--multiselect')) {
        this.set('multiselect', true);
        this.$element.addClass('coral-ColumnView--multiselect');
      }

      // select: tap the text: single selection
      this.$element.on('click', '.coral-ColumnView-item', this._itemActivateHandler.bind(this));

      // check: tap the icon: multiple selection
      this.$element.on('click', '.coral-ColumnView-icon', this._itemSelectHandler.bind(this));

      // handles clicking the body of the column content
      this.$element.on('click', '.coral-ColumnView-column-content', this._columnContentHandler.bind(this));

      // if there is a data-src then we load the data
      if (this.get('src')) {
        this.setSource(this.get('src'));
      } else {
        // otherwise we just initialize the current column
        this._loadInnerMarkup();
      }

      this._makeAccessible();
    },

    /**
     * Cleans up the component by removing any internal data and listeners. The component should be
     * used anymore after calling this method.
     *
     * @instance
     */
    destroy: function() {
      // removes the reference to the coral component
      this.$element.removeData('columnView');

      // removes the item elements
      this.$element.off('click', '.coral-ColumnView-item');
      this.$element.off('click', '.coral-ColumnView-icon');
      this.$element.off('click', '.coral-ColumnView-column-content');

      // removes the listener for keyboard navigation
      this.$element.off('keydown');

      // removes the scroll event
      this.$element.find('.coral-ColumnView-column-content').off('scroll');

      // deletes the internal variables
      delete this._data;
      delete this.$element;
    },

    /** @private */
    _makeAccessible: function() {
      this.$element.attr('tabindex', '0');

      // removes the user-select when shift is up
      $(document).on('keyup', function(event) {
        if (event.which === 16) {
          this.$element.removeClass('is-unselectable');
        }
      }.bind(this));

      // removes the user-select when shift is up
      $(document).on('keydown', function(event) {
        if (event.which === 16) {
          this.$element.addClass('is-unselectable');
        }
      }.bind(this));

      this.$element.on('keydown', function(event) {

        var captureEvent = false;

        var $selectedItems = this.getSelectedItems();
        var $activeColumn;
        var lastSelected = this.$element.data('lastSelected');

        if ($selectedItems.length > 0) {
            switch(event.which) {
            case 38: // up
              captureEvent = true;
              if (event.shiftKey) {
                if(lastSelected.item.is(':not(:first-child)')) {
                  if(!lastSelected.direction ||lastSelected.direction === 'up') {
                    lastSelected.item = lastSelected.item.prev();

                    if(lastSelected.item.hasClass('is-selected') && !lastSelected.item.prev().hasClass('is-selected')) {
                      lastSelected.item = lastSelected.item.prev();
                    }
                  }

                  lastSelected.item.find('.coral-ColumnView-icon').trigger('click');

                  if(lastSelected.item.hasClass('is-selected') && lastSelected.item.prev().hasClass('is-selected')) {
                    lastSelected.item = lastSelected.item.prevUntil(':not(.is-selected)').last();
                  }

                  $selectedItems = this.getSelectedItems();
                  if($selectedItems.length === 1 && $selectedItems[0].item.is(':first-child')) {
                    lastSelected.item = $selectedItems[0].item.next();
                  }

                  this.$element.data('lastSelected', {
                    item: lastSelected.item,
                    direction: 'up'
                  });
                }
              } else {
                if ($selectedItems[0].item.prev().length !== 0) {
                  $selectedItems[0].item.prev().trigger('click');
                } else if ($selectedItems.length > 1) {
                  $selectedItems[0].item.trigger('click');
                }
              }
              break;
            case 40: // down
              captureEvent = true;
              if (event.shiftKey) {
                if(lastSelected.item.is(':not(:last-child)')) {
                  if(!lastSelected.direction ||lastSelected.direction === 'down') {
                    lastSelected.item = lastSelected.item.next();

                    if(lastSelected.item.hasClass('is-selected') && !lastSelected.item.next().hasClass('is-selected')) {
                      lastSelected.item = lastSelected.item.next();
                    }
                  }

                  lastSelected.item.find('.coral-ColumnView-icon').trigger('click');

                  if(lastSelected.item.hasClass('is-selected') && lastSelected.item.next().hasClass('is-selected')) {
                    lastSelected.item = lastSelected.item.nextUntil(':not(.is-selected)').last();
                  }

                  if($selectedItems.length === 1 && $selectedItems[0].item.is(':last-child')) {
                    lastSelected.item = $selectedItems[0].item;
                  }

                  $selectedItems = this.getSelectedItems();
                  if($selectedItems.length === 1 && $selectedItems[0].item.is(':last-child')) {
                    lastSelected.item = $selectedItems[0].item.prev();
                  }

                  this.$element.data('lastSelected', {
                    item: lastSelected.item,
                    direction: 'down'
                  });
                }
              } else {
                if ($selectedItems[$selectedItems.length - 1].item.next().length !== 0) {
                  $selectedItems[$selectedItems.length - 1].item.next().trigger('click', {metaKey: true});
                } else if ($selectedItems.length > 1) {
                  $selectedItems[$selectedItems.length - 1].item.trigger('click');
                }
              }
              break;
            case 39: // right
              captureEvent = true;

              if ($selectedItems[0].item.hasClass('coral-ColumnView-item--hasChildren')) {
                $activeColumn = this._getActiveColumn();
                $activeColumn.next().find('.coral-ColumnView-item').first().trigger('click');
              }
              break;
            case 37: // left
              captureEvent = true;

              $activeColumn = this._getActiveColumn();
              $activeColumn.prev().find('.coral-ColumnView-item.is-active').trigger('click');
              break;
          }

        } else {

          var $column = this.$element.children('.coral-ColumnView-column').first();
          var $item = $column.find('.coral-ColumnView-item');
          switch(event.which) {
            case 38: // up
              $item = $item.last();
              $item.trigger('click');
              this.$element.data('lastSelected', {
                item: $item,
                direction: 'up'
              });

              captureEvent = true;
              break;
            case 40: // down
            case 39: // right
              $item = $item.first();
              $item.trigger('click');
              this.$element.data('lastSelected', {
                item: $item,
                direction: 'down'
              });

              captureEvent = true;
              break;
          }
        }

        if (captureEvent) {
          event.stopImmediatePropagation();
          event.preventDefault();
        }

      }.bind(this));
    },

    /**
     * Initializes the component without a source.
     * @private
     */
    _loadInnerMarkup: function() {

      if(this.$element.children().length > 0) {
        // current markup inside the component
        var loadedColumn = this.$element.html();

        // stores the inner html as a the main content
        this._data = {};
        // stores the initial markup as the root
        this._data['/'] = loadedColumn;

        // clears the inner contents to properly initialize the column
        this.$element.empty();

        var activeColumnRequest = ++this._activeColumnRequest;
        this.setNextColumn('/').done(function(data, $column) {
          this._setActiveColumn($column, false, activeColumnRequest);
        }.bind(this));
      }
    },

    /**
     * Set the source for this ColumnView. This wipes any pre-existing data in this widget.
     *
     * @instance
     * @param {String} sourceHref the URL to load; this will be used for the first column in the widget
     * @returns {jQuery.Deferred} a promise that will be accepted when the data has been loaded and the first column rendered, or rejected
     *          if the data fails to load
     */
    setSource: function(sourceHref) {
      this.cancelNavigation();

      var deferred = $.Deferred();
      this._data = {};
      this.$element.empty();

      var activeColumnRequest = ++this._activeColumnRequest;
      this.setNextColumn(sourceHref).done(function(data, $column) {
        this._setActiveColumn($column, false, activeColumnRequest);
        deferred.resolve();
      }.bind(this)).fail(function() {
        deferred.reject();
      });

      return deferred.promise();
    },

    /**
     * Set raw data for this ColumnView
     *
     * @instance
     * @param {Object} data the data to set; needs to contain at least a self link
     * @param {Boolean} [clear=false] whether to wipe pre-existing data from the widget and set <code>data</code> as the first (and only) column
     */
    setData: function(data, clear) {
      if (!data._links || !data._links.self ||!data._links.self.href) {
        throw 'Invalid data: needs to contain self link (_links.self.href)';
      }
      var href = data._links.self.href;

      this._data = clear || !this._data ? {} : this._data;

      this._storeData(data);

      if (clear) {
        this.cancelNavigation();

        this.$element.empty();
        var activeColumnRequest = ++this._activeColumnRequest;
        this.setNextColumn(href).done(function(data, $column) {
          this._setActiveColumn($column, false, activeColumnRequest);
        }.bind(this));
      }
    },

    /**
     * Get the selected items. This does not include the breadcrumb items of other columns.
     *
     * @instance
     * @returns {Array}
     */
    getSelectedItems: function() {
      var items = [];
      this._getColumnContent(this._getActiveColumn()).children('.is-active').each(function(i, item) {
        var $item = $(item);
        items.push({
          'checked': $item.hasClass('is-selected'),
          'data': $item.data('data'),
          'item': $item
        });
      });
      return items;
    },

    /**
     * Get the items of the breadcrumb i.e. selected items not located in the active column.
     *
     * @instance
     * @returns {Array}
     */
    getBreadcrumbItems: function() {
      var breadcrumbs = [];
      this._getActiveColumn().prevAll().find('.is-active').each(function(i, item) {
        var $item = $(item);
        breadcrumbs.push({
          'checked': $item.hasClass('is-selected'),
          'data': $item.data('data'),
          'item': $item
        });
      });
      return breadcrumbs;
    },

    /**
     * Get the column where actions like adding or pasting items will be applied to. If a single folder is selected
     * this would be the sub column and otherwise the active column.
     *
     * @instance
     * @returns {Object} the data associated with the target column.
     */
    getTargetColumn: function() {
      var activeColumn = this._getActiveColumn();
      var items = this.getSelectedItems().filter(function(item) { return !item.checked; });
      if (items.length === 1 && items[0].data && items[0].data.hasChildren) {
        return activeColumn.next().data('data');
      } else {
        return activeColumn.data('data');
      }
    },

    /**
     * Navigate multiple levels at once.
     *
     * @instance
     * @param  {function} itemFinder a function that finds the item to select in a column; arguments: columnData, $column; the return value
     *                               of this function can be: an item (jQuery object, data object or href) that is to be selected,
     *                               <code>false</code> if the navigation is finished or <code>undefined</code> if the item was not found;
     *                               note that this method can be called multiple times for the same column if more data is available for it
     * @param  {jQuery} [column] the column where to start the navigation ("active", href or jQuery object); if omitted, the first column
     *                           is used
     * @return {jQuery.Deferred} a promise that will be resolved when the navigation is finished or rejected if some error occurs (e.g. an
     *                           item is not found); aditionally, the deferred object will have a <code>navigationId</code> property which
     *                           can be used in conjunction with {@link #cancelNavigation}.
     */
    navigate: function(itemFinder, column) {
      var self = this;
      var deferred = $.Deferred();
      var $column;
      if (!column) {
         $column = self.$element.find(".coral-ColumnView-column:eq(0)");
      } else if (column === 'active') {
        $column = self._getActiveColumn();
      } else if (typeof column === 'string') {
        $column = self.$element.children().filter(function() {
          return $(this).data('href') === column;
        });
      } else if (column instanceof $) {
        $column = column;
      }
      $column.nextAll().remove();

      self.cancelNavigation();
      self._navigation = self._navigation || {};
      var navigationId = (self._lastNavigationId || 0) + 1;
      self._lastNavigationId = navigationId;
      self._navigation[navigationId] = "pending";

      if ($column.length > 0) {
        var selectInColumn = function($column, activeColumnRequest) {
          if (self._navigation[navigationId] === "cancel") {
            self._navigation[navigationId] = "cancelled";
            deferred.reject();
            return;
          }
          var item = itemFinder(self._data[$column.data('href')], $column);
          if (item) {
            var $item = item instanceof $ ? item : $column.find(".coral-ColumnView-item").filter(function() {
              return $(this).data('href') === (item._links && item._links.self ? item._links.self.href : item);
            }).eq(0);
            var href = $item.data('href');

            if ($item && $item.length > 0) {
              self._setActiveColumn($item, false, activeColumnRequest);
              $item.addClass("is-active");
            }

            if ($item || href) {
              self.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
            }

            var newActiveColumnRequest = ++self._activeColumnRequest;

            if (href) {
              self.setNextColumn(href, function() {
                return self._navigation[navigationId] === "pending";
              }).done(function(data, $column) {
                selectInColumn($column, newActiveColumnRequest);
              }).fail(function() {
                self._navigation[navigationId] = "failed";
                deferred.reject();
              });
            } else {
              // scrolls to the active column
              self._scrollToColumn();
              self._navigation[navigationId] = "finished";
              deferred.resolve();
            }
          } else if (item === false) {
            // scrolls to the active column
            self._scrollToColumn();
            self._navigation[navigationId] = "finished";
            deferred.resolve();
          } else {
            self._loadNext($column).done(function() {
              selectInColumn($column, newActiveColumnRequest);
            }).fail(function() {
              self._navigation[navigationId] = "failed";
              deferred.reject();
            });
          }
        };
        selectInColumn($column, ++self._activeColumnRequest);
      } else {
        self._navigation[navigationId] = "failed";
        deferred.reject();
      }

      var promise = deferred.promise();
      promise.navigationId = navigationId;
      return promise;
    },

    /**
     * Cancel in-progress navigation requested with {@link #navigate}.
     *
     * @instance
     * @param {number} [navigationId] the navigationId returned by {@link #navigate}; leave unspecified to cancel all
     *                                navigation requests
     * @return {boolean} <code>true</code> if the navigation will be cancelled, <code>false</code> if <code>navigationId</code>
     *                                     was specified but invalid or already completed.
     */
    cancelNavigation: function(navigationId) {
      this._navigation = this._navigation || {};
      if (navigationId) {
        if (this._navigation.hasOwnProperty(navigationId) && this._navigation[navigationId] === 'pending') {
          this._navigation[navigationId] = "cancel";
          return true;
        }
        return false;
      } else {
        $.each(this._navigation, function(i, item) {
          if (this._navigation[i] === "pending") {
            this._navigation[i] = "cancel";
          }
        }.bind(this));
        return true;
      }
    },

    /**
     * Render a column. This method is not indended to be called directly, instead it is intended to be overridden by subclasses to
     * customize / alter column rendering.
     *
     * @instance
     * @param  {String} href the location that is being rendered in this column; the data for this location must be already loaded and
     *         present in the <code>_data</code> field
     * @returns {jQuery} a new jQuery object that will be added to the ColumnView widget
     * @see {@link CUI.ColumnView#setSource}
     * @see {@link CUI.ColumnView#setData}
     */
    renderColumn: function(href) {
      var data = this._data[href];

      if($.type(data) === 'object') {
        // create the column
        var $column = $('<div class="coral-ColumnView-column"></div>');

        // column content
        var $content = $('<div class="coral-ColumnView-column-content"></div>').appendTo($column);

        // back button (if needed)
        if (this.get('single') && data._links && data._links.up) {
          var backTitle = data._links.self ? data._links.self.title : '';
          var $back = $('<a class="coral-ColumnView-item coral-ColumnView-item--back"></a>')
              .append($('<div class="coral-ColumnView-label"></div>').text(backTitle));
          $column.prepend($back);
        }

        if (data._embedded && data._embedded.items) {
          // render items
          while (data) {
            if (data._embedded && data._embedded.items) {
              var items = data._embedded.items;
              for (var i=0; i < items.length; i++) {
                var item = items[i];
                this.renderItem(item).appendTo($content);
              }
            }
            data = this._data[data._links.next];
          }
        } else if (data.properties || data.preview) {
          $content.append(this.renderPreview(data));
        }

        return $column;
      }

      return $(data);
    },

    /**
     * Render an item. This method is not indended to be called directly, instead it is intended to be overridden by subclasses to
     * customize / alter item rendering.
     *
     * @instance
     * @param  {Object} item the data associated with the item being rendered
     * @returns {jQuery} a new jQuery object that will be added to a column
     */
    renderItem: function(item) {
      var $item = $('<div class="coral-ColumnView-item"></div>');
      if (item.hasChildren) {
        $item.addClass('coral-ColumnView-item--hasChildren');
      }
      if (item.icon || item.image) {
        var $icon = $('<div class="coral-ColumnView-icon"></div>').appendTo($item);
        if (item.image) {
          $('<img/>').addClass('coral-ColumnView-thumbnail').attr('src', item.image).appendTo($icon);
        } else {
          $('<i/>').addClass('coral-Icon coral-Icon--' + item.icon + ' coral-Icon--sizeS').appendTo($icon);
        }
      }
      $('<div class="coral-ColumnView-label"></div>').text(item._links.self.title).appendTo($item);
      return $item;
    },

    /**
     * Render the preview for an item. This method is not indended to be called directly, instead it is intended to be overridden by subclasses to
     * customize / alter preview rendering.
     *
     * @instance
     * @param  {Object} item the data associated with the item being rendered; this will have a <code>preview</code> and/or
     *         <code>properties</code> key
     * @returns {jQuery} a new jQuery object that will be added to a preview column
     */
    renderPreview: function(data) {
      var $content = $('<div class="coral-ColumnView-preview"></div>');
      // preview icon / image / thumbnail
      if (data.preview) {
        if (data.preview.image) {
          var imageContainer = $('<div class="coral-ColumnView-preview-icon"></div>');
          $('<img class="coral-ColumnView-preview-thumbnail">').attr('src', data.preview.image).appendTo(imageContainer);
          imageContainer.appendTo($content);
        } else if (data.preview.icon) {
          var iconContainer = $('<div class="coral-ColumnView-preview-icon"></div>');
          $('<i></i>').addClass('coral-Icon coral-Icon--' + data.preview.icon + ' coral-Icon--sizeL').appendTo(iconContainer);
          iconContainer.appendTo($content);
        }
      }
      // properties
      if (data.properties) {
        for (var j=0; j < data.properties.length; j++) {
          var property = data.properties[j];
          var label = $('<div class="coral-ColumnView-preview-label"></div>').text(property.label).appendTo($content);
          var value = $('<div class="coral-ColumnView-preview-value"></div>').text(property.value).appendTo($content);
          if (property.icon) {
            $('<i></i>').addClass('coral-Icon coral-Icon--' + property.icon + ' coral-Icon--sizeXS').prependTo(value);
            label.before('<div class="coral-ColumnView-preview-spacer"></div>');
          }
        }
      }

      return $content;
    },

    /**
     * Set the column to the right of the current active column to display the data at <code>href</code>; if there are any other columns to
     * the right of the active column, they are removed
     *
     * @instance
     * @param {String} href the location to display in the new column; the contents fetched from this location are cached, any subsequent
     *        calls with the same <code>href</code> do not issue a new request
     * @param {function} [validate] a callback that needs to return <code>true</code> if the next column should still be set when the data
     *                              becomes available or <code>false</code> if the request is no longer valid
     * @returns {jQuery.Deferred} a promise that will be resolved with the new column (as a jQuery object) or rejected if the data can not be
     *         loaded
     */
    setNextColumn: function(href, validate) {
      var deferred = $.Deferred();

      var handleData = function() {
        if ($.type(validate) === "function" && !validate()) {
          deferred.reject();
        } else {
          var $column = this.renderColumn(href);
          this._prepareColumn($column, href);

          var $activeColumn = this._getActiveColumn();
          if (this.get('single') && $activeColumn.length > 0) {
            $column.addClass('is-right');
          }
          $activeColumn.nextAll().empty().removeClass('is-active');
          if ($activeColumn.length > 0 && $activeColumn.next().length > 0) {
            $activeColumn.next().replaceWith($column);
          } else {
            this.$element.append($column);
          }
          this._loadMoreIfNeeded($column).always(function() {
            deferred.resolve(this._data[href], $column);
          }.bind(this));
        }
      }.bind(this);

      if (this._data[href]) {
        handleData(href);
      } else {
        this._loadData(href).done(handleData).fail(function() {
          deferred.reject();
        });
      }

      return deferred.promise();
    },

    /**
     * Set the column to the left of the current active column to display the data at <code>href</code>; any other columns to the left of
     * the active column, they are removed.
     *
     * @instance
     * @param {String} href the location to display in the new column; the contents fetched from this location are cached, any subsequent
     *        calls with the same <code>href</code> do not issue a new request
     * @param {function} [validate] a callback that needs to return <code>true</code> if the next column should still be set when the data
     *                              becomes available or <code>false</code> if the request is no longer valid
     * @returns {jQuery.Deferred} a promise that will be resolved with the new column (as a jQuery object) or rejected if the data can not be
     *         loaded
     */
    setPreviousColumn: function(href, validate) {
      var deferred = $.Deferred();

      var handleData = function() {
        if ($.type(validate) === "function" && !validate()) {
          deferred.reject();
        } else {
          var $column = this.renderColumn(href);
          this._prepareColumn($column, href);
          if (this.get('single')) {
            $column.addClass('is-left');
          }

          var $activeColumn = this._getActiveColumn();
          if ($activeColumn.length > 0) {
            $activeColumn.prevAll().remove();
          }
          this.$element.prepend($column);
          this._loadMoreIfNeeded($column).always(function() {
            deferred.resolve(this._data[href], $column);
          }.bind(this));
        }
      }.bind(this);

      if (this._data[href]) {
        handleData(href);
      } else {
        this._loadData(href).done(handleData).fail(function() {
          deferred.reject();
        });
      }

      return deferred.promise();
    },

    /**
     * Add an item to a column.
     *
     * @instance
     * @param {string|jQuery} itemOrData the item to add, specified by either item data (json+hal format) or jQuery object
     * @param {string|jQuery} [columnOrHref] the column in which to add the item, specified by either <code>href</code> or jQuery object;
     *                                       leave <code>undefined</code> to use the active column
     * @param {number} [index] the index where to add the item: 0 for first (top), unspecified for last (bottom)
     *
     * @return {jQuery} the item that was added
     */
    addItem: function(itemOrData, columnOrHref, index) {
      var $column;
      if (!columnOrHref) {
        $column = this._getActiveColumn();
      } else if ($.type(columnOrHref) === "string") {
        if (columnOrHref === "active") {
          $column = this._getActiveColumn();
        } else {
          $column = this.$element.children().filter(function() {
            return $(this).data("href") === columnOrHref;
          });
        }
      } else {
        $column = $(columnOrHref);
      }

      var $item;
      if (itemOrData instanceof $) {
        $item = itemOrData;
      } else {
        $item = this._prepareItem(this.renderItem(itemOrData), itemOrData);
      }

      var $content = this._getColumnContent($column);
      var $items = $content.children();

      if (index === 0) {
        $content.prepend($item);
      } else if (index > 0 && index < $items.length) {
        $items.eq(index - 1).after($item);
      } else {
        $content.append($item);
      }

      return $item;
    },

    /**
     * Get the active column.
     *
     * @instance
     * @private
     * @returns {jQuery}
     */
    _getActiveColumn: function() {
      return this.$element.children('.is-active');
    },

    /**
     * Get the content (.coral-ColumnView-column-content) for this column, or create it if it doesn't exist. Attach
     * appropriate listeners if needed.
     *
     * @instance
     * @private
     * @returns {jQuery}
     */
    _getColumnContent: function($column) {
      var $content = $column.children('.coral-ColumnView-column-content');
      if ($content.length === 0) {
        // TODO: check if this could add a double scroll event
        $content = $('<div class="coral-ColumnView-column-content"></div>').appendTo($column);
        $content.on('scroll', this._columnScrollHandler.bind(this));
      }
      return $content;
    },

    /**
     * Set data attributes, attach listeners etc. to a new column
     *
     * @instance
     * @private
     * @param  {jQuery} $column the new column
     * @param  {String} href the location of the new column
     * @returns {jQuery} $column, for chaining
     */
    _prepareColumn: function($column, href) {
      var data = this._data[href];
      var $content = this._getColumnContent($column);

      $column.data('href', href);

      // set data attributes
      if($.type(data) === 'object') {
        $column.data('data', data);

        if (data._links && data._links.next) {
          $column.data('next', data._links.next.href);
        }
        if (data._links && data._links.up) {
          $column.data('back', data._links.up.href);
        }

        // prepare items
        if (data._embedded && data._embedded.items) {
          var items = data._embedded.items;
          $content.find('.coral-ColumnView-item').each(function(i, item) {
            this._prepareItem($(item), items[i]);
          }.bind(this));
        }
      }

      // attach listeners
      $content.on('scroll', this._columnScrollHandler.bind(this));

      return $column; // for chaining
    },

    /**
     * Set data attributes, attach listeners etc. to a new item
     *
     * @instance
     * @private
     * @param  {jQuery} $item the new column
     * @param  {Object} data the data for the new item
     * @returns {jQuery} $item, for chaining
     */
    _prepareItem: function($item, data) {
      $item.data('data', data);
      if (data._links && data._links.self) {
        $item.data('href', data._links.self.href);
      }
      return $item; // for chaining;
    },

    /**
     * Puts data into the <code>_data</code> field. If the passed data contains deep hierarchies they are flattened so that paths can easily
     * be accessed via <code>_data[path]</code>.
     *
     * @instance
     * @private
     * @param  {Object} data the data to store
     */
    _storeData: function(data) {
      var href = data._links.self.href;

      this._data[href] = data;
      if (data._embedded && data._embedded.items) {
        var items = data._embedded.items;
        $.each(items, function(i, item) {
          if (item.properties || item.preview || (item._embedded && item._embedded.items)) {
            this._storeData(item);
          }
        }.bind(this));
      }
    },

    /**
     * Loads data from a href and stores it in <code>this._data</code>. If there's already a request in progress for
     * this href, its promise is returned.
     *
     * @instance
     * @private
     * @param  {String} href the URL to load data from
     * @param {jQuery} [$column] the column for which data is being loaded
     * @returns {jQuery.Deferred}
     */
    _loadData: function(href, $column) {
      if (this._data && this._data[href]) {
        return $.Deferred().resolve(this._data[href]);
      }
      this._pendingRequests = this._pendingRequests || {};
      if (!this._pendingRequests[href]) {
        // cache: false stops IE from caching the requests
        this._pendingRequests[href] = $.ajax({url: href, cache: false}).done(function(data) {
          this._data = this._data || {};
          this._data[href] = data;

          // stores the json data
          if ($.type(data) === 'object') {
            this._storeData(data);
          }

          this.$element.trigger('coral-columnview-load', [href, data]);
          delete this._pendingRequests[href];
        }.bind(this));
      }
      return this._pendingRequests[href];
    },

    /**
     * If the current contents of the column to not exceed its height, this method loads more items (if possible).
     *
     * @instance
     * @private
     * @param  {jQuery} $column the column in which to load items
     * @returns {jQuery.Deferred} a promise that will be rejected if no items are to be loaded and resolved
     */
    _loadMoreIfNeeded: function($column) {
      var deferred = $.Deferred();
      var $content = this._getColumnContent($column);
      var items = $content.children('.coral-ColumnView-item');
      var itemsHeight = 0;
      items.each(function(i, item) {
        itemsHeight += $(item).height();
      });
      if (itemsHeight < $content.height() && $column.data('next')) {
        this._loadNext($column).done(function() {
          this._loadMoreIfNeeded($column).done(function() {
            deferred.resolve();
          }).fail(function() {
            deferred.reject();
          });
        }.bind(this)).fail(function() {
          deferred.reject();
        });
      } else {
        deferred.resolve();
      }
      return deferred.promise();
    },

    /**
     * Handles the column click. When the column body is clicked, we need to
     * deselect everything up to that column. This behavior is not available
     * in single mode.
     *
     * @instance
     * @private
     * @param {jQuery.Event} event
     */
    _columnContentHandler: function(event) {
      // this behavior is not supported in single mode
      if (this.get('single')) { return; }

      // we only deselect all the items when the user clicked on the content
      // and not an item
      var $target = $(event.target);
      if (!$target.hasClass('coral-ColumnView-column-content')) { return; }

      this.cancelNavigation();
      event.preventDefault();

      var $column = $target.closest('.coral-ColumnView-column');

      // we remove every column to the right of the select one
      $column.nextAll().empty().removeClass('is-active');

      // we deselect every item in the clicked column
      $column.find('.coral-ColumnView-item').removeClass('is-active');

      // if our parent exists, we mark it as active and scroll to it
      var $parentColumn = $column.prev();
      if ($parentColumn.length !== 0) {
        $parentColumn.addClass('is-active');
      }

      $column.removeClass('is-active');

      this._scrollToColumn();

      // announces the new selection
      var $item = $parentColumn.find('.coral-ColumnView-item.is-active');
      this.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
    },

    /**
     * Handles the item selection, this causes the current item to get active and sets the next column to the
     * item's href.
     *
     * @instance
     * @private
     * @param {jQuery.Event} event
     */
    _itemActivateHandler: function(event) {
      // clicking on a single item, activates the item and deactivates
      // items in the former active column
      this.cancelNavigation();
      event.preventDefault();

      var $item = $(event.target).closest('.coral-ColumnView-item');

      // @polyfill ie
      // ie does not respect user-none
      if(event.shiftKey) {

        // @polyfill ie9
        if (document.selection) {
          document.selection.empty();
        }
        else if (window.getSelection) {
          // @polyfill ie11
          if (window.getSelection().removeAllRanges) {
            window.getSelection().removeAllRanges();
          }
        }
      }

      // handles it as a select in case command or ctrl or shift where pressed
      if (event.metaKey || event.ctrlKey || event.shiftKey) {
        return this._itemSelectHandler(event);
      }

      var href = $item.data('href');
      var $column = $item.closest('.coral-ColumnView-column');

      this.$element.data('lastSelected', {
        item: $item
      });

      var activeColumnRequest = ++this._activeColumnRequest;
      if (href) {
        if (this.get('single')) {
          this.setNextColumn(href).done(function(data, $column) {
            setTimeout(function() {
              // without the timeout the CSS animations don't kick in
              this._setActiveColumn($column, false, activeColumnRequest);
            }.bind(this), 30);
          }.bind(this));
        } else {
          if ($item.hasClass('is-active') && !$item.hasClass('is-selected') && $column[0] === this._getActiveColumn()[0]) {
            $item.removeClass('is-active');

            //always close all next columns
            $column.nextAll().empty().removeClass('is-active');

            var $parentColumn = $column.prev();
            if ($parentColumn.length !== 0) {
              $parentColumn.addClass('is-active');
            }

            $column.removeClass('is-active');
            this._scrollToColumn();
          } else {
            this._setActiveColumn($item, false);
            $item.addClass('is-active');
            $item.focus();
            this.setNextColumn(href).done(function(data, $column) {
              this._scrollToColumn();
            }.bind(this));
          }
        }
      } else if ($item.hasClass('coral-ColumnView-item--back')) {
        if ($column.data('back')) {
          this.setPreviousColumn($column.data('back')).done(function(data, $column) {
            setTimeout(function() {
              // without the timeout the CSS animations don't kick in
              this._setActiveColumn($column, false, activeColumnRequest);
            }.bind(this), 30);
          }.bind(this));
        }
      }

      // the current active item is also regarded as selected
      this.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
    },

    /**
     * Handles selecting multiple items in the same column. Selection could result in none, a single or multiple
     * selected items.
     *
     * @instance
     * @private
     * @param {jQuery.Event} event
     */
    _itemSelectHandler: function(event) {
      if (!this.get('multiselect')) {
        return;
      }

      // selecting multiple items
      event.stopPropagation();
      event.preventDefault();

      var $item = $(event.target).closest('.coral-ColumnView-item');
      this._setActiveColumn($item, true);

      var href = $item.data('href');
      var direction;

      $item.toggleClass('is-active is-selected');

      if (this.getSelectedItems().length === 0) {
        // unchecked last item of a column: parent column (if available) is new active column
        var $column = this._getActiveColumn();
        var $parentColumn = $column.prev();
        if ($parentColumn.length !== 0) {
          $parentColumn.addClass('is-active');
        }

        $column.removeClass('is-active');
      }

      if(event.shiftKey) {
        if(this.getSelectedItems().length === 1) {
          if($item.is(':not(:first-child)')) {
            var $firstItem = $item.siblings().first();
            $firstItem
              .addClass('is-active is-selected')
              .nextUntil($item).addClass('is-active is-selected');
          }

          direction = 'down';
        }
        else {
          if(this.$element.data('lastSelected').item.index() < $item.index()) {
            this.$element.data('lastSelected').item.nextUntil($item).addClass('is-active is-selected');
            direction = 'down';
          }
          else {
            this.$element.data('lastSelected').item.prevUntil($item).addClass('is-active is-selected');
            direction = 'up';
          }
        }
      }

      this.$element.data('lastSelected', {
        item: $item.hasClass('is-selected') ? $item : $item.siblings('.is-selected').first(),
        direction: direction
      });

      this._scrollToColumn();

      this.$element.trigger('coral-columnview-item-select', [$item.data('data'), $item]);
    },

    /**
     * This method is called by the scroll event on a column's content. If the scroll has reached the bottom, more items are potentially
     * loaded.
     *
     * @instance
     * @private
     * @param  {jQuery.Event} event
     */
    _columnScrollHandler: function(event) {
      var $content = $(event.target);
      var $column = $content.closest('.coral-ColumnView-column');
      var tolerance = 10;
      if ($content[0].scrollTop + $content.height() + tolerance >= $content[0].scrollHeight) {
        this._loadNext($column);
      }
    },

    /**
     * Loads more items in a column, if available. I.e. if the column has a <code>next</code> data attribute.
     *
     * @instance
     * @private
     * @param  {jQuery} $column the column that needs more items
     * @returns {jQuery.Deferred} a promise that is resolved if more items are loaded successfully and rejected otherwise
     */
    _loadNext: function($column) {
      var deferred = $.Deferred();
      var next = $column.data('next');

      if (next) {
        // make sure multiple requests for the same 'next' don't go through
        $column.removeAttr('data-next');
        $column.removeData('next');

        var $content = this._getColumnContent($column);
        var handleData = function() {

          // data has to be loaded from the cache
          var data = this._data[next];

          var clearNext = false;

          if($.type(data) === 'object') {
            if (data._embedded && data._embedded.items) {
              var items = data._embedded.items;
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                this._prepareItem(this.renderItem(item), item).appendTo($content);
              }
              this._data[$column.data('href')]._embedded.items =
                  this._data[$column.data('href')]._embedded.items.concat(data._embedded.items);
            }
            if (data._links && data._links.next) {
              $column.data('next', data._links.next.href);
            } else {
               clearNext = true;
            }
          } else {
            var $loadedColumn = $(data);

            // adds the next link to the column in case there is more data to load.
            if($loadedColumn.data('next')) {
              $column.data('next', $loadedColumn.data('next'));
            } else {
               clearNext = true;
            }

            // appends every new item to the end of the current column
            $loadedColumn.find('.coral-ColumnView-item').appendTo($content);
          }

          if(clearNext) {
            // removes both the attribute and the data value
            $column.removeAttr('data-next');
            $column.removeData('next');
          }

          deferred.resolve();
        }.bind(this);
        if (this._data[next]) {
          handleData(this._data[next]);
        } else {
          this._loadData(next, $column).done(handleData).fail(function() {
            deferred.reject();
          });
        }
      } else {
        deferred.reject();
      }

      return deferred.promise();
    },

    /**
     * Sets the current active column. Selected items are deselected and unchecked. If the former active column is the same as the new one
     * the items will be unchecked solely if <code>forceUncheck</code> is true.
     *
     * @instance
     * @private
     * @param {jQuery} $item the item whose column to set as active, or the column itself
     * @param {Boolean} checking <code>true</code> when the 'checkbox' (icon) was tapped
     */
    _setActiveColumn: function($item, checking, request) {
      if (request !== undefined && request < this._activeColumnRequest) {
        return;
      }
      var $formerActiveColumn = this._getActiveColumn();
      var $activeColumn = $item.closest('.coral-ColumnView-column');
      var $activeContent = this._getColumnContent($activeColumn);


      var isColumnViewItem = false;

      if ($item.is(".coral-ColumnView-item")) {
        isColumnViewItem =  true;

        if (checking === true) {
          // tapping 'checkbox': convert selected item of active column into checked
          $activeContent.children('.is-active:not(.is-selected)').addClass('is-selected');
        } else {
          // tapping label: deselect all items (note: does not include checked items, see below)
          $activeContent.children('.is-active:not(.is-selected)').removeClass('is-active');
        }

        if (checking === false || $activeColumn.hasClass('is-active') === false) {
          // tapping label or a 'checkbox' in a different column: uncheck all items
          $activeContent.children('.is-selected').removeClass('is-active is-selected');
        }
      }

      // the parent of the item is the new active column
      $formerActiveColumn.removeClass('is-active');

      // the column is added as active if: it is not the initial column or if
      // something was clicked by the user. This causes the initial state of the
      // columnview not to have an "active" column.
      if ($formerActiveColumn.length !== 0 || isColumnViewItem) {
        $activeColumn.addClass('is-active');
      }

      if (!this.get('single')) {
        // clear the columns after the new active column
        $activeColumn.nextAll().empty().removeData().removeClass('is-active');
      } else {
        if ($formerActiveColumn.index() < $activeColumn.index()) {
          $formerActiveColumn.addClass('is-left');
          $activeColumn.removeClass('is-right');
        } else if ($formerActiveColumn.index() > $activeColumn.index()) {
          $formerActiveColumn.addClass('is-right');
          $activeColumn.removeClass('is-left');
        }
      }
    },

    /**
     * Scroll to the relevant column. If the target column is right of the visible area it will be scrolled into
     * view. Otherwise if the active column is left of the visible area this one will be scrolled into view.
     *
     * @instance
     * @private
     */
    _scrollToColumn: function() {
      var left, duration;
      var $activeColumn = this._getActiveColumn();

      // if no columns are active, we need to scroll back to the root
      if ($activeColumn.length === 0) {
        left = 0;
        duration = this.$element.scrollLeft() * 1.5; // constant speed

        this.$element.animate({
          scrollLeft: left
        }, duration);

        return;
      }

      // most right column: target column, preview column or active column
      var $rightColumn;
      var items = this.getSelectedItems().filter(function(item) { return !item.checked; });
      if (items.length === 1) {
        $rightColumn = $activeColumn.next();
      } else {
        $rightColumn = $activeColumn;
      }

      if ($rightColumn.position() && $rightColumn.position().left + $rightColumn.outerWidth() >= this.$element.width()) {
        // most right column is (partially) right of visible area: scroll right column into view

        // remove empty columns right of most right column
        $rightColumn.nextAll().remove();

        left = this.$element[0].scrollWidth - this.$element.outerWidth();
        duration = (left - this.$element.scrollLeft()) * 1.5; // constant speed

        this.$element.animate({
          scrollLeft: left
        }, duration);

      } else if ($activeColumn.position() && $activeColumn.position().left < 0) {
        // active column is (partially) left of visible area: scroll active column into view

        left = 0;
        $activeColumn.prevAll().each(function() {
          left += $(this).outerWidth();
        });
        duration = (this.$element.scrollLeft() - left) * 1.5; // constant speed

        this.$element.animate({
          scrollLeft: left
        }, duration);
      }
    }

    /**
     * Triggered when an item is selected. Use getSelectedItems() to get
     * an array with all the selected items.
     *
     * @name CUI.ColumnView#coral-columnview-item-select
     * @event
     *
     * @param {jQuery.Event} evt              The event object
     * @param {String} href                   The selected item's href
     * @param {Object} item                   The selected item
     */

    /**
     * Triggered when some data is loaded.
     *
     * @name CUI.ColumnView#coral-columnview-load
     * @event
     *
     * @param {jQuery.Event} evt              The event object.
     * @param {String} href                   The loaded URL.
     * @param {Object} data                   The loaded data.
     */
  });

  CUI.Widget.registry.register('columnview', CUI.ColumnView);

  // Data API
  if (CUI.options.dataAPI) {
    $(document).on('cui-contentloaded.data-api', function(event) {
      CUI.ColumnView.init($('[data-init~=columnview]', event.target));
    });
  }

}(jQuery, this));

(function($) {

    // Instance ID counter
    var pathbrowser_guid = 0;

    var CLASS_INPUT = 'js-coral-pathbrowser-input',
        CLASS_BUTTON = 'js-coral-pathbrowser-button',
        CLASS_COLLAPSED = 'is-collapsed',
        CLASS_DISABLED = 'is-disabled',
        CLASS_HIGHLIGHTED = 'is-highlighted',

        HTML_CRUMBS = '<nav class="coral-Crumbs"></nav>',
        HTML_PICKER = [
            '<div class="coral-Pathbrowser-picker coral-Modal" id="%ID%">',
                '<div class="coral-Modal-header">',
                    '<h2 class="coral-Modal-title coral-Heading coral-Heading--2"></h2>',
                    '<button type="button" class="js-coral-pathbrowser-confirm coral-Button coral-Button--square coral-Button--primary" title="Confirm">',
                        '<i class="coral-Icon coral-Icon-sizeXS coral-Icon--check"></i>',
                    '</button>',
                    '<button type="button" class="js-coral-pathbrowser-cancel coral-Button coral-Button--square coral-Button" title="Cancel">',
                        '<i class="coral-Icon coral-Icon-sizeXS coral-Icon--close"></i>',
                    '</button>',
                '</div>',
                '<div class="coral-Modal-body">',
                    '<div class="coral-Pathbrowser-pickerBar">' + HTML_CRUMBS + '</div>',
                    '<div class="coral-Pathbrowser-pickerPanel">',
                        '<div class="coral-ColumnView"></div>',
                    '</div>',
                '</div>',
            '</div>'
        ].join(''),
        HTML_WAIT = '<div class="coral-Wait coral-Wait--large coral-Wait--center"></div>',

        PATH_SEPARATOR = "/";

    var Registry = function() {
        var map = {};

        return {
            register: function(key, config) {
                if (!map.hasOwnProperty(key)) {
                    map[key] = [config];
                } else {
                    map[key].push(config);
                }
            },
            get: function(key, filter) {
                var results = [];

                var res = filter("test", "test");

                if (!map.hasOwnProperty(key)) {
                    return results;
                }

                if (typeof filter === 'function') {
                    return $.grep(map[key], filter);
                }

                return map[key];
            }
        };
    };

    var registry = new Registry();

    CUI.PathBrowser = new Class(/** @lends CUI.PathBrowser# */{
        toString: 'PathBrowser',
        extend: CUI.Widget,

        // Public API //

        /**
         @extends CUI.Widget
         @classdesc An autocompletable path browser widget

         <p>
            <select data-init="pathbrowser" data-placeholder="Select path">
                <option>/apps</option>
                <option>/content</option>
                <option>/etc</option>
                <option>/libs</option>
                <option>/tmp</option>
                <option>/var</option>
            </select>
         </p>

         @desc Creates a path browser field
         @constructs

         @param {Object}   options                                    Component options
         @param {Array}    [options.options=empty array]              Array of available options (will be read from &lt;select&gt; by default)
         @param {Array}    [options.optionDisplayStrings=empty array] Array of alternate strings for display (will be read from &lt;select&gt; by default)
         @param {Mixed}    [options.optionLoader=use options]         (Optional) Callback to reload options list. Can be synch or asynch. In case of asynch handling, use second parameter as callback function: optionLoader(string currentPath, function callback) with callback(array resultArray)
                                                                      If type String, the function is looked up in the CUI.PathBrowser registry. See {@link CUI.PathBrowser.register} for details.
                                                                      Type String is necessary when using the data API (no Function-as-string support).
         @param {String}   [options.optionLoaderRoot=use options]     (Optional) Nested key to use as root to retrieve options from the option loader result
         @param {Mixed}    [options.optionValueReader=use options]    (Optional) Custom function to call to retrieve the value from the option loader result
                                                                      If type String, the function is looked up in the CUI.PathBrowser registry. See {@link CUI.PathBrowser.register} for details.
                                                                      type String is necessary when using the data API (no Function-as-string support).
         @param {Mixed}    [options.optionTitleReader=use options]    (Optional) Custom function to call to retrieve the title from the option loader result.
                                                                      If type String, the function is looked up in the CUI.PathBrowser registry. See {@link CUI.PathBrowser.register} for details.
                                                                      type String is necessary when using the data API (no Function-as-string support).
         @param {Boolean}  [options.showTitles=true]                  Should option titles be shown?
         @param {String}   [options.rootPath='/content']              The root path where completion and browsing starts.
                                                                      Use the empty string for the repository root (defaults to '/content').
         @param {String}   [options.placeholder=null]                 Define a placeholder for the input field
         @param {Number}   [options.delay=200]                        Delay before starting autocomplete when typing
         @param {Number}   [options.disabled=false]                   Is this component disabled?
         @param {String}   [options.name=null]                        (Optional) name for an underlying form field.
         @param {Mixed}    [options.autocompleteCallback=use options] Callback for autocompletion.
                                                                      If type String, the function is looked up in the CUI.PathBrowser registry. See {@link CUI.PathBrowser.register} for details.
                                                                      type String is necessary when using the data API (no Function-as-string support).
         @param {Mixed}    [options.optionRenderer=default renderer]  (Optional) Renderer for the autocompleter and the tag badges.
                                                                      If type String, the function is looked up in the CUI.PathBrowser registry. See {@link CUI.PathBrowser.register} for details.
                                                                      type String is necessary when using the data API (no Function-as-string support).
         @param {String}   [options.position="below"]                 Where to position the dropdown list. "above" or "below"
         @param {Boolean}  [options.autoPosition=true]                Should the dropdown auto position itself if there's not enough space for the default position in the window?
         @param {String}   [options.pickerSrc]                        (Optional) The src from which to load the CUI.ColumnView, in the Picker UI.
         @param {String}   [options.pickerTitle="Select path"]        (Optional) The title of the CUI.Modal, in the Picker UI.
         @param {String}   [options.pickerValueKey="value"]           (Optional) The data key to use for reading path values from CUI.ColumnView selections.
         @param {String}   [options.pickerIdKey="id"]                 (Optional) The data key to use for navigating CUI.ColumnView path items from path tokens.
         @param {Mixed}    [options.crumbRoot="Content"]              (Optional) String, Object or jQuery to use as configuration for root crumb, in the Picker UI.
                                                                      String sets link text. Object allows for provision of title, icon, isAvailable and isNavigable properties.
         @param {Boolean}   [options.pickerMultiselect=false]         (Optional) Enable multiselect on the column view of the picker. This requires attaching own event listeners to the path browser to receive the
                                                                      list of selections outside of the path browser.
         */
        construct: function(options) {
            var opt, defaultHandler, config;
            var regOpts = [ 'optionLoader', 'optionValueReader', 'optionTitleReader', 'autocompleteCallback', 'optionRenderer' ];
            this.guid = pathbrowser_guid += 1;

            // Read functions from registry for all registry-based options
            for (var i = 0; i < regOpts.length; i++) {
                opt = this.options[regOpts[i]];
                defaultHandler = this._getHandler(regOpts[i], 'cui.pathbrowser.' + regOpts[i].toLowerCase() + '.default');

                if (typeof opt === 'function') {
                    this[regOpts[i]] = opt.bind(this); // Use the option as provided, if it is a function.
                } else if (typeof opt === 'string') {
                    config = this._getHandler(regOpts[i], opt); // Otherwise, lookup the name against the option in the registry.
                    this[regOpts[i]] = (config) ? config :
                                               (defaultHandler) ? defaultHandler : $.noop();
                } else if (defaultHandler) {
                    this[regOpts[i]] = defaultHandler; // Finally, take a default if it is provided.
                }
            }

            // Adjust DOM to our needs
            this._render();

            // Populate alternative display strings if necessary
            while (this.options.optionDisplayStrings.length < this.options.options.length) {
                this.options.optionDisplayStrings.push(this.options.options[this.options.optionDisplayStrings.length]);
            }

            this._selectlist = this.$element.find('.coral-SelectList');
            if (this._selectlist.length === 0) {
              this._selectlist = $('<ul/>', {
                'id': CUI.util.getNextId(),
                'class': 'coral-SelectList'
              }).appendTo(this.$element);
            } else if (!this._selectlist.attr('id')) {
              this._selectlist.attr('id', CUI.util.getNextId());
            }

            // Define input element as owner of select list; aids keyboard accessibility
            this.inputElement.attr('aria-owns', this._selectlist.attr('id'));

            this.dropdownList = new CUI.SelectList({
              element: this._selectlist,
              relatedElement: this.$element,
              autofocus: false,
              autohide: true
            });

            // Picker
            this.$button = this.$element.find("."+CLASS_BUTTON);
            this.pickerEnabled = this.$button.length !== 0 && this.options.pickerSrc;

            if (this.pickerEnabled) {
                this._constructPicker();
            }

            // Listen to property changes
            this.$element.on('change:disabled', this._update.bind(this));
            this.$element.on('change:placeholder', this._update.bind(this));
            this.$element.on('change:options', this._changeOptions.bind(this));

            // Listen to events
            this.$element.on("input", "."+CLASS_INPUT, function() {
                if (this.options.disabled) {
                    return;
                }
                if (this.typeTimeout) {
                    clearTimeout(this.typeTimeout);
                }
                this.typeTimeout = setTimeout(this._inputChanged.bind(this), this.options.delay);
            }.bind(this));

            if (this.pickerEnabled) {
                this.$button.on("click", this._clickedPickerButton.bind(this));
                this.$picker.on("beforehide", this._beforeHidePicker.bind(this));
                this.$picker.on(PICKER_EVENT_CONFIRM, this._pickerSelectionConfirmed.bind(this));
            }

            this.$element.on("blur", "."+CLASS_INPUT, function() {
                if (this.options.disabled) {
                    return;
                }
                if (this.typeTimeout) {
                    clearTimeout(this.typeTimeout);
                }
                this.typeTimeout = null;
                // Set to existing selection for single term use
                if (this.selectedIndex >= 0) {
                    if (this.inputElement.val() === "") {
                        this.setSelectedIndex(-1);
                    } else {
                        this._update();
                    }
                }
            }.bind(this));

            this.$element.on("keydown", "input", this._keyPressed.bind(this));
            this.$element.on("keyup", "input", this._keyUp.bind(this));

            this.dropdownList.on("selected", function(event) {
                var selVal = (event.selectedValue != null) ? event.selectedValue.toString() : null;

                this.dropdownList.hide(200);
                // TODO improve this
                // relative and absolute path handling
                this.setSelectedIndex(this.options.options.indexOf(selVal));
                this.inputElement.focus();
            }.bind(this));

        },

        defaults: {
            autocompleteCallback: $.noop(),
            options: [],
            optionDisplayStrings: [],
            optionLoader: $.noop(),
            optionLoaderRoot: null,
            optionValueReader: $.noop(),
            optionTitleReader: $.noop(),
            showTitles: true,
            rootPath: "/content",
            delay: 200,
            placeholder: null,
            optionRenderer: $.noop(),
            position: "below",
            autoPosition: true,
            pickerSrc: null,
            pickerTitle: "Select path",
            pickerValueKey: "value",
            pickerIdKey: "id",
            crumbRoot: "Content"
        },

        dropdownList: null, // Reference to instance of CUI.DropdownList
        inputElement: null,
        typeTimeout: null,
        selectedIndex: -1,
        triggeredBackspace: false,

        /**
         * @param {Number} index Sets the currently selected option by its index.
         *                    -1 removes any selected index.
         */
        setSelectedIndex: function(index) {
            if (index < -1 || index >= this.options.options.length) {
                return;
            }
            this.selectedIndex = index;
            this._update();
        },

        /**
         * @return {Number} The currently selected options by index or -1 if none is selected
         */
        getSelectedIndex: function() {
            return this.selectedIndex;
        },

        // Internals //

        /** @ignore */
        _changeOptions: function(event) {
            if (event.widget !== this) {
                return;
            }
            this.selectedIndex = -1;
            this._update();
        },

        /** @ignore */
        _render: function() {
            this._readDataFromMarkup();

            // If there was an select in markup: use it for generating options
            if (this.$element.find("select option").length > 0 && this.options.options.length === 0) {
                this.options.options = [];
                this.options.optionDisplayStrings = [];
                this.$element.find("select option").each(function(i, e) {
                    this.options.options.push($(e).val());
                    this.options.optionDisplayStrings.push($.trim($(e).text()));

                    // Save selected state
                    if ($(e).attr("selected")) {
                        this.selectedIndex = i;
                    }

                }.bind(this));
            }

            this.inputElement = this.$element.find("."+CLASS_INPUT);

            this.$element.removeClass(CLASS_HIGHLIGHTED);

            if (!this.options.placeholder) {
                this.options.placeholder = this.inputElement.attr("placeholder");
            }

            this._update();
        },

        /** @ignore */
        _readDataFromMarkup: function() {
            var defaultHandler, config;
            var attrToKeyMap = [
                { attr: 'data-option-loader',         key: 'optionLoader' },
                { attr: 'data-option-value-reader',   key: 'optionValueReader' },
                { attr: 'data-option-title-reader',   key: 'optionTitleReader' },
                { attr: 'data-autocomplete-callback', key: 'autocompleteCallback' },
                { attr: 'data-option-renderer',       key: 'optionRenderer' }
            ];

            for (var i = 0; i < attrToKeyMap.length; i++) {
                if (this.$element.attr(attrToKeyMap[i].attr)) {
                    defaultHandler = this._getHandler(attrToKeyMap[i].key, 'cui.pathbrowser.' + attrToKeyMap[i].key.toLowerCase() + '.default');
                    config = this._getHandler(attrToKeyMap[i].key, this.$element.attr(attrToKeyMap[i].attr));
                    this[attrToKeyMap[i].key] = (config) ? config :
                                                (defaultHandler) ? defaultHandler : $.noop();
                }
            }

            if (this.$element.attr("data-option-loader-root")) {
                this.options.optionLoaderRoot = this.$element.attr("data-option-loader-root");
            }

            if (this.$element.attr("data-root-path")) {
                this.options.rootPath = this.$element.attr("data-root-path");
            }

            if (this.$element.attr("placeholder")) {
                this.options.placeholder = this.$element.attr("placeholder");
            }

            if (this.$element.attr("data-placeholder")) {
                this.options.placeholder = this.$element.attr("data-placeholder");
            }

            if (this.$element.attr("disabled") || this.$element.attr("data-disabled")) {
                this.options.disabled = true;
            }
        },

        /** @ignore */
        _update: function() {
            if (this.options.placeholder) {
                this.inputElement.attr("placeholder", this.options.placeholder);
            }

            if (this.options.disabled) {
                this.$element.addClass(CLASS_DISABLED);
                this.inputElement.add(this.$button).prop("disabled", true);
            } else {
                this.$element.removeClass(CLASS_DISABLED);
                this.inputElement.add(this.$button).prop("disabled", false);
            }

            if (this.selectedIndex >= 0) {
                // Value to set is what is currently in the input field until the last slash + the option value
                var option = this.options.options[this.selectedIndex];
                if (option && option.indexOf(PATH_SEPARATOR) !== 0) {
                    // Option contains a relative path
                    var parentPath = "";
                    var iLastSlash = this.inputElement.val().lastIndexOf(PATH_SEPARATOR);
                    if (iLastSlash >= 0) {
                        parentPath = this.inputElement.val().substring(0, iLastSlash + 1);
                    }
                    option = parentPath + option;
                }
                this._setInputValue(option, true);
            }
        },

        /** @ignore */
        _setInputValue: function(newValue, moveCursor) {
            // Using select text util to select starting from last character to last character
            // This way, the cursor is placed at the end of the input text element
            if (newValue != null) {
                this.inputElement.val(newValue);
                this.inputElement.change();
                //IE11 fix is.(":focus") triggers blur event. Replaced by this.inputElement == document.activeElement
                if (moveCursor && this.inputElement == document.activeElement) {
                    CUI.util.selectText(this.inputElement, newValue.length);
                }
            }
        },

        /** @ignore */
        _keyUp: function(event) {
            var key = event.keyCode;
            if (key === 8) {
                this.triggeredBackspace = false; // Release the key event
            }
        },

        /** @ignore */
        _keyPressed: function(event) {
            var key = event.keyCode;
            if (!this.dropdownList.get('visible')) {
            //if (!this.dropdownList.isVisible()) {
                if (key === 40) {
                    this._inputChanged(); // Show box now!
                    event.preventDefault();
                }
            }
        },

        /** @ignore */
        _inputChanged: function() {
            var self = this;

            var searchFor = this.inputElement.val();
            if (searchFor.length > 0) {
                this.autocompleteCallback(searchFor)
                    .done(
                        function(results) {
                            self._showAutocompleter(results);
                        }
                    )
                    .fail(
                        function() {
                            // TODO: implement
                        }
                    )
                ;
            } else {
                this.dropdownList.hide();
            }
        },

        /** @ignore */
        _showAutocompleter: function(results) {
            this.dropdownList.hide();

            if ((!results) || results.length === 0) {
                return;
            }

            this._selectlist.empty();

            for (var i=0; i < results.length; i++) {
              this._selectlist.append((this.optionRenderer)(null, results[i]));
            }

            this.dropdownList.show();
        },

        /** @ignore */
        _rebuildOptions: function(def, path, object) {
            var self = this;

            var root = CUI.util.getNested(object, self.options.optionLoaderRoot);
            if (root) {
                var newOptions = [];
                var newOptionDisplayStrings = [];
                $.each(root, function(i, v) {
                    // Read the title and the value either from provided custom reader
                    // or using default expected object structure
                    var value;
                    if (self.optionValueReader) {
                        value = self.optionValueReader(v);
                    } else {
                        value = typeof v === "object" ? v.path : v;
                    }
                    newOptions.push(value);

                    var title = "";
                    if (self.optionTitleReader) {
                        title = self.optionTitleReader(v);
                    } else if (typeof v === "object") {
                        title = v.title;
                    }
                    newOptionDisplayStrings.push(title);
                }.bind(self));

                self.options.options = newOptions;
                self.options.optionDisplayStrings = newOptionDisplayStrings;

                var filtered = self._filterOptions(path);
                def.resolve(filtered);
            } else {
                def.reject();
            }
        },

        /** @ignore */
        _filterOptions: function(searchFor) {
            var result = [];
            var lastSegment = searchFor.split('/');
            lastSegment = lastSegment[lastSegment.length - 1].toLowerCase();

            $.each(this.options.options, function(key, value) {
               if (value.toLowerCase().indexOf(lastSegment, 0) >= 0) {
                    result.push(key);
               }
            }.bind(this));

            return result;
        },

        /** @ignore */
        _getHandler: function(key, name) {
            var filterFactory = function(comparator) {
                return function(item, index) {
                    return item.name === comparator;
                };
            };

            var a = filterFactory.call(this, name);
            var config = registry.get(key, a)[0];

            return (config && typeof config['handler'] === 'function') ? config.handler.bind(this) : undefined;
        },

        /** @ignore */
        _constructPicker: function () {
            // Create the Picker .coral-Modal, if not already existing in markup
            var id = "mod-guid-" + this.guid,
                idSel = "#" + id + ".coral-Modal",
                pickerOptions;

            this.$picker = $('body').find(idSel);

            if (this.$picker.length === 0) {
                $('body').append(HTML_PICKER.replace("%ID%", id));
                this.$picker = $('body').find(idSel);
            }

            pickerOptions = $.extend({}, this.options, {'element': this.$picker});
            this.picker = new Picker(pickerOptions);
        },

        /** @ignore */
        _clickedPickerButton: function () {
            var $wait;

            if (!this.options.disabled) {
                // The picker data hasn't loaded; display a loading indicator until resolution
                if (!this.picker.columnView) {
                    $wait = $(HTML_WAIT).appendTo('body');
                    this.picker.startup(this.inputElement.val()).always(function() {
                        $wait.remove();
                    });
                } else {
                    this.picker.startup(this.inputElement.val());
                }
            }
        },

        /** @ignore */
        _beforeHidePicker: function () {
            this.pickerShown = false;
            this.inputElement.removeClass(CLASS_HIGHLIGHTED);
        },

        /** @ignore */
        _pickerSelectionConfirmed: function (event) {
            if (event.selectedValue) {
                if (this.options.options.indexOf(event.selectedValue) !== -1) {
                    this.setSelectedIndex(event.selectedValue);
                } else {
                    this.setSelectedIndex(-1);
                    this._setInputValue(event.selectedValue, true);
                }
                this.inputElement.focus();
            }
        }
    });

    var PICKER_CLASS_CONFIRM = 'js-coral-pathbrowser-confirm',
        PICKER_CLASS_CANCEL = 'js-coral-pathbrowser-cancel',
        PICKER_CLASS_MODAL_BACKDROP = 'coral-Pathbrowser-picker-backdrop',
        PICKER_CLASS_MODAL_TITLE = 'coral-Modal-title',
        PICKER_CLASS_COLUMNVIEW = 'coral-ColumnView',
        PICKER_CLASS_COLUMNVIEW_COLUMN = 'coral-ColumnView-column',
        PICKER_CLASS_COLUMNVIEW_ITEM = 'coral-ColumnView-item',

        PICKER_EVENT_CONFIRM = 'coral-pathbrowser-picker-confirm',
        PICKER_EVENT_COLUMNVIEW_ITEM_SELECT = 'coral-columnview-item-select';

    var Picker = new Class(/** @lends Picker# */{
        toString: 'Picker',
        extend: CUI.Widget,

        // Public API //

        /**
         * @extends CUI.Widget
         * @classdesc Widget that handles creation and interaction with the CUI.PathBrowser Picker UI.
         *
         * @constructs
         * @param {Object} options
         */
        construct: function (options) {
            // Init CUI.Modal
            this.$element.modal({visible: false});
            this.modal = this.$element.data("modal");

            // Add class to manage layering above other modals (from which the picker may be launched)
            this.modal.backdrop.addClass(PICKER_CLASS_MODAL_BACKDROP);

            // Init CUI.ColumnView
            this.$columnView = this.$element.find('.'+PICKER_CLASS_COLUMNVIEW);

            // Init Crumbs
            this.$crumbs = this.$element.find('.'+CRUMBS_CLASS_CRUMBS);
            this.crumbs = new Crumbs({'element': this.$crumbs});

            this._setCrumbRootHref(this.options.pickerSrc);

            // Find elements
            this.$cancel = this.$element.find('.'+PICKER_CLASS_CANCEL);
            this.$confirm = this.$element.find('.'+PICKER_CLASS_CONFIRM);

            // Event listening
            this._setupListeners();
        },

        /**
          Public to CUI.PathBrowser
          Begins a path-picking session
          @param {String} path The path to initialize at
          @returns {jQuery.Deferred} a promise that will be accepted when picker has loaded, or rejected if the data fails to load
         */
        startup: function (path) {
            var deferred = $.Deferred(), cv, self = this,
                onDataLoaded = function() {
                    self._renderPicker();
                    self._showPicker();

                    // Try different paths, until we either select a valid path or gracefully fail.
                    // 1. Full path, with anchor
                    self.selectPath(path).fail(function() {
                          if (path.indexOf("#") != -1) {
                              path = path.substring(0, path.lastIndexOf("#"));

                              // 2. Path, without anchor
                              self.selectPath(path).fail(function() {
                                    if (path.indexOf(".") != -1) {
                                        path = path.substring(0, path.lastIndexOf("."));

                                        // 3. Path, without anchor and extension
                                        self.selectPath(path).always(function() {
                                            self._buildCrumbs(self._determineCrumbs());
                                        });
                                    }
                                }).always(function() {
                                    self._buildCrumbs(self._determineCrumbs());
                                });
                          }
                      }).always(function() {
                          self._buildCrumbs(self._determineCrumbs());
                      });
                };

            // We haven't loaded initial src data, setup the CUI.ColumnView.
            if (!self.columnView) {
                cv = new CUI.ColumnView({
                  'element': self.$columnView,
                  'multiselect': self.options.pickerMultiselect || false
                });

                cv.setSource(self.options.pickerSrc).done(function() {
                    self.columnView = cv;
                    onDataLoaded();
                    deferred.resolve();
                    // gives focus the Column View so that arrow keys work
                    self.$columnView.focus();
                }).fail(function() {
                    deferred.fail();
                });
            } else {
                onDataLoaded();
                deferred.resolve();
                // gives focus the Column View so that arrow keys work
                self.$columnView.focus();
            }

            // Confirm action on Enter press if we have a valid selection.
            $(document).on('keypress.pathbrowser-confirm', function (event) {
              if (event.which === 13) { // Enter
                // Just take down, if the cancel button has focus
                if ($(':focus').is(this.$cancel)) {
                  this._takeDown();
                } else if (!this.$confirm.prop('disabled')) {
                  this._selectionConfirmed();
                }
              }
            }.bind(this));

            return deferred.promise();
        },

        /**
          Navigates to the CUI.ColumnView item at the path provided
          @param {String} path The path to navigate to
          @return {jQuery.Deferred} A promise; resolved when navigation completes or rejects on error (i.e. full path navigation failed)
         */
        selectPath : function(path) {
            var rootPath, parts, itemFinder, dataAttr,
                deferred = $.Deferred();

            path = path.replace(/\/$/, ""); // Remove trailing slash
            rootPath = this.options.rootPath || PATH_SEPARATOR;

            if (path && (path.slice(0, rootPath.length) == rootPath)) {
                path = path.slice(rootPath.length); // Begin navigation after root path
                path = (path.charAt(0) == PATH_SEPARATOR) ? path.substr(1) : path; // Remove opening slash before splitting
                parts = path.split(PATH_SEPARATOR);
                dataAttr = this.options.pickerIdKey;

                if (parts.length) {
                    var i = 0;

                    itemFinder = function(columnData, $column) {
                            if (i == parts.length){
                                return false;
                            }

                            var $item = $column.find('.'+PICKER_CLASS_COLUMNVIEW_ITEM).filter(function() {
                                var data = $(this).data('data'), match;

                                if (data && data[dataAttr]) {
                                    match = data[dataAttr] === parts[i];
                                } else {
                                    match = $(this).data(dataAttr) === parts[i];
                                }

                                return match;
                            });

                            i++;

                            if ($item.length == 1) {
                                return $item; // Select the correct item in the column
                            }

                            return undefined;
                    };

                    return this.columnView.navigate(itemFinder);
                } else {
                    deferred.reject();
                }
            } else {
                deferred.reject();
            }

            return deferred;
        },

        // Internals //

        /** @ignore */
        _showPicker: function () {
            this.modal.show();
        },

        /** @ignore */
        _hidePicker: function () {
            this.modal.hide();
        },

        /** @ignore */
        _takeDown: function () {
            $(document).off('keypress.pathbrowser-confirm');
            this._hidePicker();
        },

        /** @ignore */
        _setupListeners: function () {
            this.$cancel.on('click', this._takeDown.bind(this));
            this.$confirm.on('click', this._selectionConfirmed.bind(this));
            this.$columnView.on(PICKER_EVENT_COLUMNVIEW_ITEM_SELECT, this._itemSelected.bind(this));
        },

        /** @ignore */
        _setupCrumbListeners: function (crumb) {
            var self = this;

            $(crumb).on('click', function(event) {
                if (!$(crumb).hasClass(CRUMBS_MOD_UNAVAILABLE || CRUMBS_MOD_NONAVIGATION)) {
                    var item = crumb.data('coral-columnview-item'), first = true, href, itemFinder, $el;

                    if (item && item.item) {
                        $el = item.item;
                        itemFinder = function(columnData, $column) {
                            if (first) { // First column in navigation only
                                first = false;
                                return $column.find($el).click(); // Select the correct item in the column
                            }
                            return undefined;
                        };
                    } else { // No item, no selection
                        itemFinder = function(columnData, $column) {
                            return undefined;
                        };
                    }

                    href = $(crumb).attr('href');

                    if (href) {
                        self.columnView.navigate(itemFinder, href).done(function() {
                            self._buildCrumbs();
                        });
                    }
                }

                event.preventDefault();
            });
        },

        /** @ignore */
        _itemSelected: function (event) {
            this._buildCrumbs(this._determineCrumbs());
        },

        /** @ignore */
        _selectionConfirmed: function() {
            var items = this.columnView.getSelectedItems(), v;

            if (items.length > 0) {
                // Single selection only
                if (items[0].data && items[0].data[this.options.pickerValueKey]) {
                    v = items[0].data[this.options.pickerValueKey]; // Read value from data object
                } else if (items[0].item) {
                    v = items[0].item.data(this.options.pickerValueKey); // Otherwise, try attribute
                }

                this.$element.trigger($.Event(PICKER_EVENT_CONFIRM, { "selectedValue": v }));
            } else {
                // No items selected, take the root path
                this.$element.trigger($.Event(PICKER_EVENT_CONFIRM, { "selectedValue": this.options.rootPath }));
            }

            this._takeDown();
        },

        /** @ignore */
        _renderPicker: function () {
            this.$element.find('.'+PICKER_CLASS_MODAL_TITLE).text(this.options.pickerTitle);
        },

        /** @ignore */
        _resetPicker: function () {
            this.columnView.setSource(this.options.pickerSrc);
            this._buildCrumbs();
        },

        /** @ignore */
        _buildCrumbs: function (crumbs) {
            this.crumbs.removeAllItems();

            // Root crumb always present, even if no crumbs are available
            var $rootCrumb = this.crumbs.addItem(this.options.crumbRoot, this.options.pickerSrc);
            $rootCrumb.on('click', function(event) {
                event.preventDefault();
                this._resetPicker();
            }.bind(this));

            if (crumbs) {
                $.each(crumbs, function(i, crumb) {
                    var $crumb;
                    if (crumb) {
                        $crumb = this.crumbs.addItem(crumb);
                        this._setupCrumbListeners($crumb);
                    }
                }.bind(this));
            }

            this.crumbs.truncate(); // Ensure crumbs fit in container
        },

        /** @ignore */
        _determineCrumbs: function() {
            var crumbs = this.columnView.getBreadcrumbItems();
            var items = this.columnView.getSelectedItems();

            // Prior Crumbs
            $.each(crumbs, function(i, val) {
                crumbs[i] = this._getCrumbFromColumnViewItem(val, false);
            }.bind(this));

            // Final Crumb
            if (items.length > 0) {
                crumbs.push(this._getCrumbFromColumnViewItem(items[0], true));
            }

            return crumbs;
        },

        /** @ignore */
        _getCrumbFromColumnViewItem: function (item, unavailable) {
            var data = item.data, $el = item.item, crumb = $('<a></a>'), href;

            // Attach the CUI.ColumnView item to the crumb as data
            crumb.data('coral-columnview-item', item);

            crumb.toggleClass(CRUMBS_MOD_UNAVAILABLE, unavailable);

            // Link taken from parent column href
            href = $($el).closest('.'+PICKER_CLASS_COLUMNVIEW_COLUMN).data('href');

            if (href) {
                crumb.attr('href', href);

                // Set the crumb title from data if available, otherwise from element text
                if (data && data._links && data._links.self && data._links.self.title) {
                    return crumb.text(data._links.self.title);
                } else if ($el) {
                    return crumb.text($el.text().trim());
                }
            }

            return undefined;
        },

        /** @ignore */
        _setCrumbRootHref: function(href) {
            if ($.isPlainObject(this.options.crumbRoot)) {
                this.options.crumbRoot.href = href;
            } else if (this.options.crumbRoot && this.options.crumbRoot.jquery) {
                this.options.crumbRoot.attr('href', href);
            }
        }

        /**
          Triggered when path selection is confirmed

          @name Picker#coral-pathbrowser-picker-confirm
          @event

          @param {Object} event Event object
          @param {String} event.value The selected value
         */
    });

    var CRUMBS_CLASS_CRUMBS = 'coral-Crumbs',
        CRUMBS_CLASS_CRUMBS_ITEM = 'coral-Crumbs-item',

        CRUMBS_MOD_ELLIPSIS = CRUMBS_CLASS_CRUMBS_ITEM + '--ellipsis',
        CRUMBS_MOD_UNAVAILABLE = CRUMBS_CLASS_CRUMBS_ITEM + '--unavailable',
        CRUMBS_MOD_NONAVIGATION = CRUMBS_CLASS_CRUMBS_ITEM + '--noNavigation',

        CRUMBS_HTML_ICON = '<i class="coral-Crumbs-item-icon coral-Icon"></i>',
        CRUMBS_HTML_ELLIPSIS = '<a class="' + CRUMBS_CLASS_CRUMBS_ITEM + ' ' + CRUMBS_MOD_ELLIPSIS + '" href="#"></a>',

        CRUMBS_TRUNCATE_HORIZONTAL_SPACING = 100;

    var Crumbs = new Class(/** @lends Crumbs# */{
        toString: 'Crumbs',
        extend: CUI.Widget,

        // Public API //

        /**
          @extends CUI.Widget
          @classdesc Widget to display a series of links that know how to truncate when there's not enough space
          to show all the links.

          @constructs
          @param {Object} options
         */
        construct: function (options) {
            this._decorateElement();
            this._findOrCreateEllipsis();

            this.truncate();
        },

        /**
          Adds new a crumb. Returns the given or generated element

          @param titleOrObjectOrElement {string | Object | jQuery}
          @param href {string} Specifies the link to use, when the first argument is a string.

          @returns {jQuery} The crumbs as it got added.
         */
        addItem: function (titleOrObjectOrElement, href) {
            var $item = this._itemFromTitleOrObjectOrElement(titleOrObjectOrElement, href);

            this.$element.append($item);
            return $item;
        },

        /**
          Removes all crumbs, and returns them.

          @returns {*}
         */
        removeAllItems: function () {
            delete this._firstCrumb;
            return this.$element.children().remove().not('.'+CRUMBS_MOD_ELLIPSIS);
        },

        /**
          Truncate each item just enough to fit all crumbs. The first and the last
          item always stay.
         */
        truncate: function () {
            var items = this.$element.children(),
              availableWidth = this.$element.width() - CRUMBS_TRUNCATE_HORIZONTAL_SPACING;

            items.removeClass(CLASS_COLLAPSED);
            this._ellipsis.remove();

            var fullWidth = Array.prototype.reduce.call(items, function (memo, v) {
                return memo += $(v).outerWidth();
            }, 0);

            if (items.length && (fullWidth > availableWidth)) {

                // Truncate each item just enough. The first and the last item always stay:
                var w = fullWidth;
                for (var i = 1, ln = items.length - 1; i < ln && w > availableWidth; i++) {
                    var item = $(items[i]);
                    w -= item.width();
                    item.addClass(CLASS_COLLAPSED);
                }

                this._ellipsis.insertAfter(items[0]).addClass(CLASS_COLLAPSED);
            }
        },

        // Internals //

        _ellipsis: $(),

        /** @ignore */
        _decorateElement: function () {
            if (!this.$element.is('nav')) {
                throw new Error('Crumbs expects to be attached to a nav element');
            }

            this.$element.addClass(CRUMBS_CLASS_CRUMBS);
            this.$element.children().addClass(CRUMBS_CLASS_CRUMBS_ITEM);
        },

        /** @ignore */
        _findOrCreateEllipsis: function () {
            var $ellipsis = this.$element.find('.'+CRUMBS_MOD_ELLIPSIS);
            if ($ellipsis.length === 0) {
                $ellipsis = $(CRUMBS_HTML_ELLIPSIS);
            }
            this._ellipsis = $ellipsis;
        },

        /** @ignore */
        _itemFromTitleOrObjectOrElement: function (titleOrObjectOrElement, href) {
            var a1 = titleOrObjectOrElement,
              title = (typeof a1 === 'string') ? a1 : undefined,
              object = $.isPlainObject(a1) ? a1 : undefined,
              element = (a1 && a1.jquery) ? a1 : undefined,
              $item;

            if (element) {
                $item = element;
                $item.addClass(CRUMBS_CLASS_CRUMBS_ITEM);
            } else if (object) {
                $item = this._constructItemFromObject(object);
            } else {
                $item = this._constructItemFromTitleAndRef(title, href);
            }
            return $item;
        },

        /** @ignore */
        _constructItemFromTitleAndRef: function (title, href) {
            return $('<a>').
              attr('href', href).
              text(title).
              addClass(CRUMBS_CLASS_CRUMBS_ITEM);
        },

        /** @ignore */
        _constructItemFromObject: function (object) {
            var $anchor = this._constructItemFromTitleAndRef(object.title, object.href);

            if (object.hasOwnProperty('isAvailable') && !object.isAvailable) {
                $anchor.addClass(CRUMBS_MOD_UNAVAILABLE);
                $anchor.attr('tabindex', -1);
            }
            if (object.hasOwnProperty('isNavigable') && !object.isNavigable) {
                $anchor.addClass(CRUMBS_MOD_NONAVIGATION);
            }
            if (object.hasOwnProperty('icon')) {
                var $icon = $(CRUMBS_HTML_ICON);
                $icon.addClass(object.icon);
                $anchor.prepend($icon);
            }
            return $anchor;
        }
    });

    CUI.util.plugClass(CUI.PathBrowser);

    // Data API
    if (CUI.options.dataAPI) {
        $(document).on("cui-contentloaded.data-api", function(e) {
            $("[data-init~='pathbrowser']", e.target).pathBrowser();
        });
    }

    /**
     Registers an option handler.

     Example handler config:
     var myHandlerConfig = {
       name: "cui.pathbrowser.optionrenderer.myoptionrenderer"
       handler: function(param1, param2, ...) {
        // The option handler
       }
     }

     Example usage:
     CUI.PathBrowser.register("optionRenderer", myHandlerConfig);

     @param {String} key The option to register the handler for against.
     @param {Object} config The handler configuration (name and handler function).

     @static
     */
    CUI.PathBrowser.register = function(key, config) {
        registry.register(key, config);
    };

    CUI.PathBrowser.register('optionRenderer', {
        name: 'cui.pathbrowser.optionrenderer.default',
        handler: function(iterator, index) {
            var value = this.options.options[index];

            if (value.indexOf(PATH_SEPARATOR) === 0) {
                // Option contains an absolute path
                var iLastSlash = value.lastIndexOf(PATH_SEPARATOR);
                value = value.substring(iLastSlash + 1);
            }

            // Use alternate display strings if possible
            var titleMarkup = '';
            if (this.options.showTitles && this.options.optionDisplayStrings[index] && this.options.optionDisplayStrings[index].length > 0) {
                titleMarkup = ' ' + this.options.optionDisplayStrings[index];
            }

            return $('<li class="coral-SelectList-item coral-SelectList-item--option" data-value="'+ value +'">'+ value + titleMarkup  +'</li>');
        }
    });

    CUI.PathBrowser.register('autocompleteCallback', {
        name: 'cui.pathbrowser.autocompletecallback.default',
        handler: function(path) {
            var self = this;
            var def = $.Deferred();

            // If the input value doesn't start with a slash abort autocomplete,
            // since this is not an absolute path
            if (path.indexOf('/') !== 0) {
                def.resolve([]);
                return def.promise();
            }

            // Check if the input value ends with a slash
            // If so, the options loader will be called if it exists, in order
            // to refresh the available options list.
            // Otherwise, it will just filter the options to only show the
            // matching ones in the auto completer div.

            var basePath = path.substring(0, path.lastIndexOf(PATH_SEPARATOR)) || PATH_SEPARATOR;
            if (basePath != this.lastBasePath && self.optionLoader) {
                var isCustomRoot = false;
                if (basePath === PATH_SEPARATOR) {
                    // Use configured root path
                    if (self.options.rootPath) {
                        path = self.options.rootPath.replace(/\/$/, "");
                        if (path !== "") {
                            isCustomRoot = true;
                        } else {
                            path = PATH_SEPARATOR;
                        }
                    }
                }

                // Replace field value if the entered path was a custom root path
                if (isCustomRoot) {
                    basePath = path;
                    path = path + PATH_SEPARATOR;
                    self._setInputValue(path);
                }

                // Make the option loader a promise to guarantee that the callback is
                // executed at the right rime
                var loader = {
                    loadOptions: self.optionLoader
                };
                var loaderDef = $.Deferred();
                loaderDef.promise(loader);
                loader.done(
                  function(object) {
                      if ($.isFunction(object.promise)) {
                          // Original function was already returning a promise
                          // Bind the rebuild options on that object's 'done' method
                          object.done(
                            function(object) {
                                self._rebuildOptions(def, path, object);
                            }
                          );
                      } else {
                          // Original function was not returning a promise
                          self._rebuildOptions(def, path, object);
                      }
                  }
                );

                // Asynch optionLoader
                var results = loader.loadOptions(basePath, function(data) {
                    loaderDef.resolve(data);
                });

                //  Synch optionLoader
                if (results) loaderDef.resolve(results);

            } else {
                def.resolve(self._filterOptions(path));
            }

            this.lastBasePath = basePath;

            return def.promise();
        }
    });

}(window.jQuery));

/*!
 * jQuery Cookie Plugin v1.3
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function ($, document, undefined) {

	var pluses = /\+/g;

	function raw(s) {
		return s;
	}

	function decoded(s) {
		return decodeURIComponent(s.replace(pluses, ' '));
	}

	var config = $.cookie = function (key, value, options) {

		// write
		if (value !== undefined) {
			options = $.extend({}, config.defaults, options);

			if (value === null) {
				options.expires = -1;
			}

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setDate(t.getDate() + days);
			}

			value = config.json ? JSON.stringify(value) : String(value);

			return (document.cookie = [
				encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// read
		var decode = config.raw ? raw : decoded;
		var cookies = document.cookie.split('; ');
		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			if (decode(parts.shift()) === key) {
				var cookie = decode(parts.join('='));
				return config.json ? JSON.parse(cookie) : cookie;
			}
		}

		return null;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) !== null) {
			$.cookie(key, null, options);
			return true;
		}
		return false;
	};

})(jQuery, document);

(function ($, window, undefined) {

    //Assign the appropriate requestAnimationFrame function to the global requestAnimationFrame.
  window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

  // debounce function will be extracted
  function debounce(fn, threshold, execAsap) {
    var timeout;
    return function debounced () {
      var obj = this, args = arguments; // arguments which were passed
      function delayed () {
        if (!execAsap) {
          fn.apply(obj, args); // execute now
        }

        // clear timeout handle
        timeout = null;
      }
      // stop any current detection period
      if (timeout) {
        clearTimeout(timeout);
      } else if (execAsap) { // otherwise, if we're not already waiting and we're executing at the beginning of the detection period
        fn.apply(obj, args); // execute now
      }
        timeout = setTimeout(delayed, threshold || 100);
    };
  }

  function saveState(name, value) {
    $.cookie(name, value, { expires: 7, path: '/' });
  }

  function clearState(name) {
    $.removeCookie(name, { path: '/' });
  }

  function toggleBreadcrumbBar() {
    $('.endor-Brand').toggleClass('is-closed');

    var contentPanel = $('.endor-Panel-header.endor-BreadcrumbBar + .endor-Panel-content');

    var onTransitionEnded = function(event) {
      // remove the event listener
      contentPanel.off('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', onTransitionEnded);
      contentPanel.removeClass('is-transitioning');
    };

    contentPanel.toggleClass('is-transitioning').on('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', onTransitionEnded);

    return !$('.endor-Panel-header.endor-BreadcrumbBar').toggleClass('is-closed').hasClass('is-closed');
  }

  function truncateCrumbs() {
    var crumbs = $('.endor-Crumbs');
    var items = crumbs.find('.endor-Crumbs-item');

    var availableWidth = crumbs.width() - 100; // 50 for spacing

    items.removeClass('is-collapsed');

    var fullWidth = Array.prototype.reduce.call(items, function(memo, v) {
      return memo += $(v).outerWidth();
    }, 0);

    // truncate each item just enough
    // the first and the last item always stay
    var w = fullWidth;
    for (var i = 1, ln = items.length -1; i < ln && w > availableWidth; i++) {
      var item = $(items[i]);
      w -= item.width();
      item.addClass('is-collapsed');
    }
  }

  /**
   * Toggles the navigation rail. The behaviour depends on the size of
   * the screen since only one bar sidepanel.
   */
  function toggleNavRail() {
    var page = $('.js-endor-page');
    var navrail = $('.js-endor-navrail');

    // if the screen is small, the inner rail is closed
    if (window.innerWidth <= 1024 && page.hasClass('is-innerRailOpen')) {
      toggleInnerRail();

      // stops the rail styles from triggering in case the rail was already open
      if (!navrail.hasClass('is-closed')) {
        return true;
      }
    }

    navrail.toggleClass('is-closed');
    $('.endor-BreadcrumbBar').toggleClass('is-compact');
    $('.js-endor-navrail-toggle').toggleClass('is-active');

    return !navrail.hasClass('is-closed');
  }

  function toggleInnerRail(activator) {
    var page = $('.js-endor-page');
    var activeView = $('.coral-MultiPanel.is-active').first();

    var targetView, targetId;

    if (activator) {
      targetId = activator.data('target');

      // if no target then close the rail
      if (targetId) {
        var target = $(targetId).first();

        if (!activeView.is(target)) {
          targetView = target;
        }
      }
    }

    var toggles = $('.js-endor-innerrail-toggle').removeClass('is-selected');

    if (targetView) {
      toggles.filter('[data-target="' + targetId + '"]').addClass('is-selected');

      activeView.removeClass('is-active');
      targetView.addClass('is-active');
      page.addClass('is-innerRailOpen');

      return targetId;
    } else {
      activeView.removeClass('is-active');
      page.removeClass('is-innerRailOpen');
    }
  }

  /**
   * Calculates if the content (js-endor-scrollarea) is smaller thant the content panel (js-endor-content).
   * If yes the footer is positioned sticky at the bottom, if not it follows the content.
   */
  function alignFooter() {
    var $footer = $('.endor-Footer');
    var $content = $('.js-endor-content');
    var $scrollArea = $('.js-endor-scrollarea');

    if ($footer.length === 0 || $content.length === 0 || $scrollArea.length === 0) {
      // scroll area, content or footer undefined: not possible to calculate
      return;
    }

    var footerHeight = $('.endor-Footer').outerHeight(true);
    var contentHeight = $content.outerHeight();
    var scrollHeight = $scrollArea[0].scrollHeight;

    if ($footer.hasClass('endor-Footer--sticky') === false) {
      // footer is sticky; hence it is currently not part of the content: do not consider for calculation
      footerHeight = 0;
    }

    $footer.toggleClass('endor-Footer--sticky', scrollHeight + footerHeight < contentHeight);
  }

  function performNavNextFrame(currentColumn, targetColumn, isBack) {
    if (window.requestAnimationFrame) {
      var animationStart = null,
          waitForFrame = function (timestamp) {
            //If animationStart is null then this is the first time that this method has
            //been called by requestAnimationFrame. This means that a repaint has not happend
            //yet. Call requestAnimationFrame one more time and we can be sure that the new
            //components that were added have been drawn.
            if (animationStart === null) {
              animationStart = timestamp;
              window.requestAnimationFrame(waitForFrame.bind(this));
            } else {
              performNav(currentColumn, targetColumn, isBack);
            }
          };

      // add the correct class as an initial state
      targetColumn.removeClass('is-left is-right is-sliding');
      if(isBack) {
        targetColumn.addClass('is-left');
      } else {
        targetColumn.addClass('is-right');
      }

      //An animation frame is is called right before a repaint.
      //Since we want this to happen after a repaint we are actually going
      //to call this twice.
      window.requestAnimationFrame(waitForFrame.bind(this));
    } else {
      //If requestAnimationFrame does not exist (IE9) then call _performNav immediately.
      performNav(currentColumn, targetColumn, isBack);
    }
  }

  function performNav(currentColumn, targetColumn, isBack) {
    // used to clear all the added classes
    var onSlideEnd = function(event) {
      $(event.currentTarget).off('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', onSlideEnd);
      $(event.currentTarget).removeClass('is-sliding is-left is-right');
    };

    // removes any previous animations
    currentColumn.removeClass('is-left is-right is-active is-sliding');
    targetColumn.removeClass('is-left is-right is-sliding');

    // sets the correct direction of the transition
    if (isBack) {
      currentColumn.addClass('is-right');
    } else {
      currentColumn.addClass('is-left');
    }

    // is-sliding class enables the css transitions
    currentColumn.addClass('is-sliding');
    targetColumn.addClass('is-sliding');

    // marks the current column as active which causes to animate to
    // the center no matter the current position
    targetColumn.addClass('is-active');

    // listens to transition end to remove all the added classes
    currentColumn.on('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', onSlideEnd);
    targetColumn.on('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', onSlideEnd);
  }

  function navigateColumnView(activator) {
    var columnView = activator.closest('.coral-ColumnView');
    var currentColumn = activator.closest('.coral-ColumnView-column');
    var targetId = activator.data('coral-columnview-target');
    var isBack = activator.hasClass('coral-ColumnView-item--back');

    var targetColumn = columnView.find('.coral-ColumnView-column[data-coral-columnview-id="' + targetId +'"]');

    if (targetColumn.length) {
      performNavNextFrame(currentColumn, targetColumn, isBack);
    } else if(activator.prop('href')) {

      // adds a wait to indicate the load
      var wait = $('<div class="coral-Wait coral-Wait--large coral-Wait--center"></div>').appendTo(currentColumn);
      // makes an async call to get the next column
      $.get(activator.prop('href')).done(function(html) {

        // adds the column to the html. We do not add is-left or if-right
        // since this will be handled by the performNavNextFrame
        targetColumn = $(html).appendTo(columnView);

        if (targetColumn) {
          performNavNextFrame(currentColumn, targetColumn, isBack);
        }
      })
      .always(function() {
        wait.remove();
      });
    }
  }


  $(document).on('click', '.coral-ColumnView-item[data-coral-columnview-target]', function(e) {
    e.preventDefault();
    navigateColumnView($(this));
  });

  $(document).on('click', '.js-endor-navrail-toggle', function(e) {
    e.preventDefault();
    var open = toggleNavRail();
    saveState('endor.navrail.open', open);
  });

  $(document).on('click', '.js-endor-innerrail-toggle', function(e) {
    e.preventDefault();
    var current = toggleInnerRail($(this));

    if (current) {
      saveState('endor.innerrail.current', current);
    } else {
      clearState('endor.innerrail.current');
    }
  });

  $(document).on('click', '.endor-BreadcrumbBar, .endor-BlackBar-title', function(e) {
    if ($(e.target).closest(".endor-Crumbs-item:not(.endor-Crumbs-item--unavailable)").length) {
      return;
    }

    e.preventDefault();

    var open = toggleBreadcrumbBar();
    saveState('endor.breadcrumbbar.open', open);
  });

  $(document).on('click', '.js-endor-BlackBar-back', function(e) {
    e.preventDefault();

    $('.endor-BreadcrumbBar .endor-Crumbs-item').toArray().reverse().some(function(item) {
      var el = $(item);
      if (el.hasClass('endor-Crumbs-item--unavailable')) {
        return false;
      }

      window.location = item.href;
      return true;
    });
  });

  // See CUI-2007
  $(document).on('transitionend webkitTransitionEnd', '.endor-Page-sidepanel', function(e) {
    var resize = $.Event('resize');
    resize._sidepanel = true; // 1. A flag to indicate the event from sidepanel
    $(window).trigger(resize);
  });

  $(window).on('resize load', debounce(function(e) {
    if (e._sidepanel) return; // If from sidepanel [1], ignore. Otherwise [2] is going to always close the rail.

    truncateCrumbs();
  }, 500));

  $(window).on('resize', debounce(function(e) {
    alignFooter();
  }, 100));

  $(document).on('cui-contentloaded', alignFooter);
  $(document).on('endor-alignfooter', alignFooter);  // event to trigger the alignment the footer (sticky/non sticky)

}(jQuery, window));

/*
 *
 * ADOBE CONFIDENTIAL
 * __________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function (window, $, undefined) {

    // ========================= smartresize ===============================

    /*
     * smartresize: debounced resize event for jQuery
     *
     * latest version and complete README available on Github:
     * https://github.com/louisremi/jquery.smartresize.js
     *
     * Copyright 2011 @louis_remi
     * Licensed under the MIT license.
     */

    var $event = $.event,
            resizeTimeout;

    $event.special.smartresize = {
        setup:function () {
            $(this).bind("resize", $event.special.smartresize.handler);
        },
        teardown:function () {
            $(this).unbind("resize", $event.special.smartresize.handler);
        },
        handler:function (event, execAsap) {
            // Save the context
            var context = this,
                    args = arguments;

            // set correct event type
            event.type = "smartresize";

            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(function () {
                $event.dispatch.apply(context, args);
            }, execAsap === "execAsap" ? 0 : 10);
        }
    };

    $.fn.smartresize = function (fn) {
        return fn ? this.bind("smartresize", fn) : this.trigger("smartresize", ["execAsap"]);
    };

    // constructor
    $.CUIGridLayout = function (options, element, callback) {
        this.element = $(element);
        this._create(options);
        this._init(callback);
    };

    var $window = $(window);

    $.CUIGridLayout.settings = {
        colWidth: 240,
        gutterX: 15,
        gutterY: 15,
        marginLeft:0,
        marginRight:0,
        selector:"article"
//        itemClass:"macboard-card"
    };

    // TODO layout only takes image sizes into account; may fail when cards have differing "legends"

    $.CUIGridLayout.prototype = {

        option:function(options) {
            this.options = $.extend({}, $.CUIGridLayout.settings, options);
        },

        // sets up widget
        _create:function (options) {

            this.options = $.extend({}, $.CUIGridLayout.settings, options);

            this.items = [];

            this.itemsByPath = {};

            this.numCols = -1;

            this.pendingImages = 0;

            this.update();


            // bind resize method
            var self = this;
            $window.bind('smartresize.cui.gridlayout', function () {
                self.updateDimensions();
                self.layout();
            });

        },

        _init:function (callback) {
            this.updateDimensions();
            this.layout(callback);

            // Give browser a chance to lay out elements and calculate layout a second time after
            // all CSS is applied correctly by the browser. Without this second, timed calculation is sometimes wrong due
            // to race conditions with the rendering engine of the browser.
            setTimeout(function() {
                this.numCols = -1;
                this.updateDimensions();
                this.layout(callback);

                this.element.trigger($.Event("cui-gridlayout-initialized", {
                    "widget": this
                }));
            }.bind(this), 1);
        },

        update:function () {
            var items = [],
                itemsByPath = {};

            this.element.find(this.options.selector).each(function (i) {
                var $card = $(this);
                var $img = $("img", $card);
                if ($img.length === 0) {
                    $img = null;
                }
                var item = {
                    path: $card.data().path,
                    i:i,
                    $el:$card,
                    $img:$img
                };
                items.push(item);
                itemsByPath[item.path] = item;
            });

            this.items = items.sort(function (i1, i2) {
                var i1key = i1.$el.data("gridlayout-sortkey") || 0,
                    i2key = i2.$el.data("gridlayout-sortkey") || 0;

                return i2key - i1key || i1.i - i2.i;
            });
            this.itemsByPath = itemsByPath;
        },

        _imageLoaded: function() {

            if (--this.pendingImages === 0) {
//                console.log("all images loaded");
                // force relayout
                this.numCols = -1;
                this.layout();
            }

        },
        updateDimensions: function() {
            var self = this;
            this.items.every(function (i) {
                var $el = i.$el;

                i.w = $el.width();
                i.h = $el.height();

                // check if card has an image and if it's loaded
                if (i.$img) {
                    // Hack: Recalculate element size if browser has wrong values. This sometimes occurs with loaded
                    // images when the elements are not yet displayed on screen.
                    if (i.$img.width() > i.w) {
                        i.h = (i.h - i.$img.height()) + (i.$img.height() / i.$img.width() * i.w);
                    }

                    if (i.$img.height() === 0) {
                        // just assume 1:1 for now
                        i.h += i.w;
                        self.pendingImages++;
                        i.$img.on("load.cui.gridlayout", function() {
                            i.$img = null;
                            i.w = $el.width(); // Set width AND height to ensure proper ratio
                            i.h = $el.height();

//                            console.log("image loaded.", i);
                            self._imageLoaded();
                        });
                    } else {
                        // we don't need to know this info anymore
                        i.$img = null;
                    }
                }

                // debug
//                $("h4", i.$el).html("Card Nr " + i.i + " (" + i.w + "x" + i.h + ")");

                return true;
            });

        },

        layout:function () {
            var self = this;
            var $this = this.element;
            var colWidth = this.options.colWidth;
            var marginLeft = this.options.marginLeft;
            var marginRight = this.options.marginRight;
            var gx = this.options.gutterX;
            if ($this.width() === 0) {
          //need not to layout the div whose width is 0
                return;
            }
            // calculate # columns:
            // containerWidth = marginLeft + (colWidth + gx) * n - gx + marginRight;
            // use: "round" for avg width, "floor" for minimal width, "ceil" for maximal width
            var n = Math.floor(($this.width() - marginLeft - marginRight + gx) / (colWidth + gx));

            if (n < 1) n = 1; // Minimum 1 column!

            if (n == this.numCols) {
                // nothing to do. CSS takes care of the scaling
                return;
            }

            this.numCols = n;

            // calculate actual column width:
            // containerWidth = marginLeft + (cw + gx) * n - gx + marginRight;
            var cw =  (($this.width() - marginLeft - marginRight + gx) / n) - gx;

            // initialize columns
            var cols = [];
            var colHeights = [];
            while (cols.length < n) {
                cols.push([]);
                colHeights.push(0);
            }

            this.items.every(function (i) {
                // determine height of card, based on the ratio
                var height = (i.h / i.w) * cw;

                // find lowest column
                var min = colHeights[0];
                var best = 0;
                for (var c = 0; c < colHeights.length; c++) {
                    var h = colHeights[c];
                    if (h < min) {
                        min = h;
                        best = c;
                    }
                }

                // update columns and heights array
                cols[best].push(i);
                colHeights[best] += height + self.options.gutterY;
                return true;
            });

            // detach all the cards first
            $this.detach(this.options.selector);

            // remember old columns. because otherwise the
            // event handlers bound on the cards would be removed
            var $cols = $this.contents();

            // now fill up all the columns
            for (var c=0; c<cols.length; c++) {
                var $col = $('<div class="grid-'+n+'"></div>').appendTo($this);
                for (var j=0; j<cols[c].length; j++) {
                    $col.append(cols[c][j].$el);
                }
            }

            // remove old columns
            $cols.remove();

            $(document).trigger("cui-gridlayout-layout");
        },

        destroy: function() {
            $window.unbind("smartresize.cui.gridlayout");
            this.element.removeData("cuigridlayout");
        }
    };

    var logError = function (message) {
        if (window.console) {
            window.console.error(message);
        }
    };

    // plugin bridge
    $.fn.cuigridlayout = function (options, callback) {
        if (typeof options === 'string') {
            // call method
            var args = Array.prototype.slice.call(arguments, 1);

            this.each(function () {
                var instance = $.data(this, 'cuigridlayout');
                if (!instance) {
                    logError("cannot call methods on cuigridlayout prior to initialization; " +
                            "attempted to call method '" + options + "'");
                    return;
                }
                if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                    logError("no such method '" + options + "' for cuigridlayout instance");
                    return;
                }
                // apply method
                instance[ options ].apply(instance, args);
            });
        } else {
            this.each(function () {
                var instance = $.data(this, 'cuigridlayout');
                if (instance) {
                    // apply options & init
                    instance.option(options);
                    instance._init(callback);
                } else {
                    // initialize new instance
                    $.data(this, 'cuigridlayout', new $.CUIGridLayout(options, this, callback));
                }
            });
        }
        // return jQuery object
        // so plugin methods do not have to
        return this;
    };
})(window, jQuery);


(function($, window, undefined) {

  var defaults = {
    "threshold": 200, // How often the resize and reflow events should be considered
    "applyClassToElement": undefined
  };

  // Utility functions to help calculating sizes
  var size = {
    "rem": function () {
      // This caches the rem value to calculate it only once, but might lead to wrong results if the font size gets changed
      if (size._rem === undefined) {
        size._rem = parseInt($("body").css("font-size"));
      }
      return size._rem;
    },
    "em": function (elem) {
      return parseFloat(elem.css("font-size"));
    }
  };

  // Adds and removes classes to the given element depending on the result of the associated functions.
  // Can be called with or without parameters:
  // When a breakpoints object is provided, the reflow listener gets setup to the given element.
  // The options parameter is optional, it allows to change the default settings.
  // When no parameters are provided it triggers a reflow event on the provided object.
  $.fn.reflow = function reflow(breakpoints, options) {
    return this.each(function reflowEach() {
      var elem = $(this),
        didApplyClassNames = false,
        scheduledReflowCheck = false,
        settings;

      if (breakpoints) {
        settings = $.extend({}, defaults, options);
        settings.applyClassToElement = settings.applyClassToElement || elem;

        function reflowEventHandler() {
          if (elem.is(":visible")) {
            if (!scheduledReflowCheck) {
              applyClassNames();
              scheduledReflowCheck = setTimeout(function reflowCheck() {
                scheduledReflowCheck = false;
                if (!didApplyClassNames && elem.is(":visible")) {
                  applyClassNames();
                }
              }, settings.threshold);
            } else {
              didApplyClassNames = false;
            }
          }
        }

        function applyClassNames() {
          didApplyClassNames = true;
          for (var className in breakpoints) {
            settings.applyClassToElement.toggleClass(className, breakpoints[className](elem, size));
          }
        }

        elem.on("reflow", reflowEventHandler);
        $(window).on("resize.reflow", reflowEventHandler);
      }

      elem.trigger("reflow");

    });
  }

}(jQuery, this));

(function ($, window, undefined) {
  var storageKey = 'cui-state',
    storageLoadEvent = 'cui-state-restore',
    store = {},
    loaded = false,
    $doc = $(document);

  /**
   * state object to enable UI page refresh stable states
   * TODO:
   *  - all states are global, lack of an auto restore mode which is aware of the URL
   *  - client side only (localStorage)
   *  - lack of an abstraction layer for the client side storage
   * @type {Object}
   */
  CUI.util.state = {

    /*saveForm: function (form, elem) {

     },*/

    config: {
      serverpersistence: true
    },

    /**
     * Persist attributes of a DOM node
     *
     * @param {String} selector
     * @param {String|Array}[attribute] single attribute or list of attributes to be saved. If null then all attributes will be saved
     * @param {Boolean} [autorestore]
     * @param {String} [customEvent] custom event name
     */
    save: function (selector, attribute, autorestore, customEvent) {
      var elem = $(selector),
        saveLoop = function (i, attr) {
          store.global[selector] = store.global[selector] || {};
          store.global[selector][attr] = store.global[selector][attr] || {};
          store.global[selector][attr].val = elem.attr(attr);
          store.global[selector][attr].autorestore = autorestore || false;
          store.global[selector][attr].customEvent = customEvent || null;
        };


      if (attribute) { // save single or multiple attributes
        if ($.isArray(attribute)) { // multiple values to save
          $.each(attribute, saveLoop);
        } else { // save all attributes
          saveLoop(0, attribute);
        }
      } else { // save all attributes
        // TODO
        // not supported yet because the browser implementation of Node.attributes is a mess
        // https://developer.mozilla.org/en-US/docs/DOM/Node.attributes
      }

      localStorage.setItem(storageKey, JSON.stringify(store));

      if (CUI.util.state.config.serverpersistence) {
        $.cookie(storageKey, JSON.stringify(store), {
          expires: 7,
          path: '/'
        });
      }
    },

    /**
     *
     * @param {String} [selector]
     * @param {Function} [filter] filter function for the attributes of the given selector
     */
    restore: function (selector, filter) {
      var check = filter || function () {
          return true;
        },
        sel,
        elem,
        selectorLoop = function (item, noop) {
          sel = item;
          elem = $(sel);

          if (store.global[sel]) {
            $.each(store.global[sel], restoreLoop);
          }
        },
        restoreLoop = function (attr, obj) {
          if (check(sel, attr, obj)) {
            elem.attr(attr, obj.val);

            if (obj.customEvent) {
              $doc.trigger(obj.customEvent, [elem, obj]);
            }

            $doc.trigger(storageLoadEvent, [elem, obj]);
          }
        };

      if (!loaded) {
        loaded = CUI.util.state.load();
      }


      if (selector) { // restore single selector
        selectorLoop(selector);
      } else { // restore everything
        $.each(store.global, selectorLoop);
      }
    },

    load: function () {
      var val = localStorage.getItem(storageKey);

      store = val ? JSON.parse(val) : {
        global: {}
      };

      return true;
    },

    // support for "temporary" storage that will be automatically cleared if
    // the browser session ends; currently uses a set/get pattern rather than
    // loading the entire thing on document ready. Also note that the data is currently
    // not sent to the server.

    setSessionItem: function(name, value, ns) {
      var key = name;
      if (ns) {
        key = name + ":" + ns;
      }
      sessionStorage.setItem(key, JSON.stringify(value));
    },

    getSessionItem: function(name, ns) {
      var key = name;
      if (ns) {
        key = name + ":" + ns;
      }
      var value = sessionStorage.getItem(key);
      if (value) {
        value = JSON.parse(value);
      }
      return value;
    },

    removeSessionItem: function(name, ns) {
      var key = name;
      if (ns) {
        key = name + ":" + ns;
      }
      sessionStorage.removeItem(key);
    },

    clearSessionItems: function(ns) {
      if (ns) {
        ns = ":" + ns;
        var keyCnt = sessionStorage.length;
        var toRemove = [ ];
        for (var k = 0; k < keyCnt; k++) {
          var keyToCheck = sessionStorage.key(k);
          var keyLen = keyToCheck.length;
          if (keyLen > ns.length) {
            if (keyToCheck.substring(keyLen - ns.length) === ns) {
              toRemove.push(keyToCheck);
            }
          }
        }
        var removeCnt = toRemove.length;
        for (var r = 0; r < removeCnt; r++) {
          sessionStorage.removeItem(toRemove[r]);
        }
      }
    }

  };

  $doc.ready(function () {
    CUI.util.state.restore(null, function (selector, attr, val) {
      if (val.autorestore) {
        return true;
      }

      return false;
    });
  });
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($) {

  var DISPLAY_GRID = "grid";

  var DISPLAY_LIST = "list";

  var SELECTION_MODE_COUNT_SINGLE = "single";

  var SELECTION_MODE_COUNT_MULTI = "multiple";

  var DEFAULT_SELECTOR_CONFIG = {

    "itemSelector": "article",                      // selector for getting items
    "headerSelector": "header",                     // selector for headers
    "dataContainer": "grid-0",                      // class name of the data container
    "enableImageMultiply": true,                    // flag if images should be multiplied
    "view": {
      "selectedItem": {                           // defines what classes (cls) on what elements (selector; optional) are used to mark a selection
        "list": {
          "cls": "selected",
          "prv": "selected-prev"
        },
        "grid": {
          "cls": "selected",
          "prv": "selected-prev"
        }
      },
      "selectedItems": {                          // defines the selector that is used for determining the current selection; a resolver function may be specified that adjusts the selection (for exmaple by determining a suitable parent element)
        "list": {
          "selector": "article.selected"
        },
        "grid": {
          "selector": "article.selected"
        }
      }
    },
    "controller": {
      "selectElement": {                          // defines the selector that is used for installing the tap/click handlers
        "list": "article > i.select",
        /* "listNavElement": "article", */      // may be used to determine the element that is responsible for navigating in list view (required only if different from the Grid's select item)
        "grid": "article"
      },
      "moveHandleElement": {                      // defines the selector that is used to determine the object that is responsible for moving an item in list view
        "list": "article > i.move"
      },
      "targetToItem": {                           // defines methods that are used to resolve the event target of a tap/click event to a card view item
        "list": function ($target) {
          return $target.closest("article");
        },
        "grid": function ($target) {
          return $target.closest("article");
        },
        "header": function ($target) {
          return $target.closest("header");
        }
      },
      "gridSelect": {                             // defines the class that is used to trigger the grid selection mode
        "cls": "selection-mode"
      },
      "selectAll": {                              // defines the "select all" config (list view only)
        "selector": "header > i.select",
        "cls": "selected"
      },
      "sort": {                                   // defines the config for column sort
        "columnSelector": ".label > *"
      }
    }

  };

  var ensureItem = function (item) {
    if (item.jquery) {
      return item.data("cardView-item");
    }
    return item;
  };

  /**
   * @classdesc
   * Internal class that provides utility functionality to the card view.
   */
  var Utils = {

    /**
     * Check two jQuery objects for equality.
     * @param {jQuery} $1 first jQuery object
     * @param {jQuery} $2 second jQuery object
     * @return {boolean} True if both objects are considered equal
     */
    equals: function ($1, $2) {
      return ($1.length === $2.length) && ($1.length === $1.filter($2).length);
    },

    /**
     * Gets a CardView widget for the specified jQuery object.
     * @param {jQuery} $el The jQuery object
     * @return {CUI.CardView} The widget
     */
    getWidget: function ($el) {
      var widget;
      if ($el.length > 0) {
        widget = $($el[0]).data("cardView");
      }
      return widget;
    },

    /**
     * Mixes two objects so that for every missing property in object1 the properties of object2 are used. This is also done
     * for nested objects.
     * @param {object} Object 1
     * @param {object} Object 2
     * @return {object} The mixed object with all properties
     */
    mixObjects: function (object1, object2) {
      if (object1 === undefined) return object2;

      var result = {};
      for (var i in object2) {
        if (object1[i] === undefined) {
          result[i] = object2[i];
          continue;
        }
        var p = object1[i];

        // Go one step deeper in the object hierarchy if we find an object that is not a string.
        // Note: typeof returns "function" for functions, so no special testing for functions needed.
        if (typeof(object1[i]) == "object" && (!(object1[i] instanceof String))) {
          p = this.mixObjects(object1[i], object2[i]);
        }
        result[i] = p;
      }
      return result;
    },

    /**
     * Resolves each of the DOM elements in the specified jQuery object with a given
     * function into a new jQuery object.
     * @param {jQuery} $el The jQuery object to resolve
     * @param {Function} fn The resolver function
     * @return {jQuery} The resolved jQuery object
     */
    resolve: function ($el, fn) {
      var resolved = [ ];
      $el.each(function () {
        resolved.push.apply(resolved, fn($(this)).toArray());
      });
      return $(resolved);
    },

    /**
     * Multiplies the image with the provided color. This will insert a canvas element
     * before the img element.
     * @param {HTMLElement} $images image element to multiply with the color
     * @param {Number[]} color RGB array of values between 0 and 1
     */
    multiplyImages: function ($images, color) {
      // Filter out images where the multiply effect has already been inserted to the DOM, or images that aren't visible
      $images = $images.filter(function () {
        var $image = $(this);
        return !$image.is(".multiplied") && !$image.prev().is(".multiplied") && $image.is(":visible");
      });

      var imageMaxCounter = $images.length;
      var imageIteratorCounter = 0;

      function multiplyNextImage() {
        if (imageIteratorCounter < imageMaxCounter) {
          // Not adding the timeout for the first image will make it feel more reactive.
          multiplyOneImage($images[imageIteratorCounter]);

          imageIteratorCounter++;

          // But adding a timeout for the other images will make it non-blocking.
          setTimeout(multiplyNextImage, 0);
        }
      }

      function multiplyOneImage(image) {
        var width = image.naturalWidth,
          height = image.naturalHeight;

        // defer if image is not yet available
        if ((width === 0) && (height === 0)) {
          window.setTimeout(function () {
            multiplyOneImage(image);
          }, 200);
          return;
        }

        try {
          var canvas = $("<canvas width='" + width + "' height='" + height + "'></canvas>")[0];

          var context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width, height);

          var imageData = context.getImageData(0, 0, width, height);
          var data = imageData.data;

          for (var i = 0, l = data.length; i < l; i += 4) {
            data[i] *= color[0];
            data[i + 1] *= color[1];
            data[i + 2] *= color[2];
          }

          context.putImageData(imageData, 0, 0);

          // re-sizing of canvases are handled different in IE and Opera, thus we have to use an image
          $("<img class='" + image.className + " multiplied' " +
            "width='" + image.width + "' " +
            "src='" + canvas.toDataURL("image/png") + "'/>").insertBefore(image);

        } catch(err) {
          // CUI-2187: we have to catch the error produced by getImageDate, such that
          // it does not break the selection. When the error was produced, the navigation
          // was performed instead of selecting the card.
        }
      }

      multiplyNextImage();
    }
  };

  var ListItemAutoScroller = new Class(/** @lends CUI.CardView.ListItemAutoScroller# */{

    /**
     * The item element
     * @type jQuery
     * @private
     */
    $el: null,

    /**
     * The scrolling container element (with overflow auto/visible and position
     * absolute)
     * @type jQuery
     * @private
     */
    $containerEl: null,

    /**
     * Size of a scrolling step (= number of pixels that get scrolled per autoscrolling
     * 'tick'
     * @type Number
     * @private
     */
    stepSize: 0,

    /**
     * Timeout ID
     * @type Number
     * @private
     */
    iid: undefined,

    /**
     * @private
     */
    autoMoveOffset: 0,

    /**
     * The maximum value that is allowed for scrollTop while autoscrolling
     * @type Number
     * @private
     */
    maxScrollTop: 0,


    /**
     * @ignore
     * @name CUI.CardView.ListItemAutoScroller
     * @classdesc
     * Internal class that implements auto scrolling while moving cards in list view.
     *
     * @desc
     * Creates a new auto scroller.
     *
     * @constructs
     *
     * @param {jQuery} $el The jQuery container element of the card item that is moved
     * @param {Number} stepSize The step size (number of pixels scrolled per 'tick')
     * @param {Function} autoMoveFn Function that gets executed on every auto scroll
     *        "event". The function must actually reposition the item element to
     *        the coordinate specified as parameters (first parameter: x; second
     *        parameter: y
     */
    construct: function ($el, stepSize, autoMoveFn) {
      this.$el = $el;
      this.stepSize = stepSize;
      this.$containerEl = this._getScrollingContainer($el);
      var cont = this.$containerEl[0];
      this.maxScrollTop = Math.max(cont.scrollHeight - cont.clientHeight, 0);
      this.autoMoveFn = autoMoveFn;
    },

    /**
     * Gets a suitable container element that limits the scrolling area.
     * @param {jQuery} $el The card item's container element
     * @return {jQuery} The container element
     * @private
     */
    _getScrollingContainer: function ($el) {
      while (($el.length > 0) && !$el.is("body")) {
        var ovflY = $el.css("overflowY");
        var pos = $el.css("position");
        if (((ovflY === "auto") || (ovflY === "visible")) && (pos === "absolute")) {
          return $el;
        }
        $el = $el.parent();
      }
      return $(window);
    },

    /**
     * Checks if scrolling is necessary according to the item element's current position
     * and the scroll container's state and executes a single scrolling step by
     * adjusting the scroll container's scrollTop property if necessary.
     * @return {Boolean} True if scrolling occured; false if no scrolling was necessary
     * @private
     */
    _execute: function () {
      var cont = this.$containerEl[0];
      var clientHeight = cont.clientHeight;
      var scrollTop = cont.scrollTop;
      var offsetTop = $.isWindow(cont) ? 0 : this.$containerEl.offset().top;
      var itemTop = this.$el.offset().top - offsetTop;
      var itemBottom = itemTop + this.$el.height();
      var isAutoScroll = false;
      if (itemTop <= 0) {
        // auto scroll upwards
        if (scrollTop > 0) {
          scrollTop -= this.stepSize;
          this.autoMoveOffset = -this.stepSize;
          if (scrollTop < 0) {
            scrollTop = 0;
          }
          cont.scrollTop = scrollTop;
          isAutoScroll = true;
        }
      } else if (itemBottom >= clientHeight) {
        // auto scroll downwards
        if (scrollTop < this.maxScrollTop) {
          scrollTop += this.stepSize;
          this.autoMoveOffset = this.stepSize;
          if (scrollTop > this.maxScrollTop) {
            scrollTop = this.maxScrollTop;
          }
          cont.scrollTop = scrollTop;
          isAutoScroll = true;
        }
      }
      return isAutoScroll;
    },

    /**
     * Moves the card item's element by calculating its new position and calling
     * the function that was provided in the constructor as autoMoveFn.
     * @private
     */
    _autoMove: function () {
      if (this.autoMoveOffset && this.autoMoveFn) {
        var itemOffs = this.$el.offset();
        var itemTop = itemOffs.top + this.autoMoveOffset;
        this.autoMoveFn(itemOffs.left, itemTop);
      }
    },

    /**
     * Checks if autoscrolling is currently necessary; if so, the autoscrolling is
     * executed and a timer is started that will check again later if additional
     * auto scrolling is necessary (and execute again if so).
     */
    check: function () {
      var self = this;
      this.stop();
      var isAutoScroll = this._execute();
      if (isAutoScroll) {
        this.iid = window.setTimeout(function () {
          self.iid = undefined;
          self._autoMove();
        }, 50);
      }
    },

    /**
     * Stops autoscrolling.
     */
    stop: function () {
      if (this.iid !== undefined) {
        window.clearTimeout(this.iid);
        this.autoMoveOffset = 0;
        this.iid = undefined;
      }
    }

  });

  var ListItemMoveHandler = new Class(/** @lends CUI.CardView.ListItemMoveHandler# */{

    /**
     * The list's jQuery element
     * @type {jQuery}
     * @private
     */
    $listEl: null,

    /**
     * The moved item's jQuery element
     * @type {jQuery}
     * @private
     */
    $itemEl: null,

    /**
     * A jQuery element that contains all items of the list
     * @type {jQuery}
     * @private
     */
    $items: null,

    /**
     * The document
     * @type {jQuery}
     * @private
     */
    $doc: null,

    /**
     * The jQuery object that represents the card that is right before the moved card
     * just before the move; undefined, if the moved card is the first card of the list
     * @type {jQuery}
     * @private
     */
    $oldBefore: null,

    /**
     * The CSS class that is added to the item while it is moved
     * @type String
     * @private
     */
    dragCls: null,

    /**
     * Flag that determines if the horizontal position of an item should be fixed
     * while it is moved
     * @type {Boolean}
     * @private
     */
    fixHorizontalPosition: false,

    /**
     * The autoscroller module
     * @type {ListItemAutoScroller}
     * @private
     */
    autoScroller: null,

    /**
     * @ignore
     * @name CUI.CardView.ListItemMoveHandler
     *
     * @classdesc
     * Internal class that implements the reordering of cards in list view.
     *
     * @constructor
     * @desc
     * Creates a new handler for moving a item around in a list by drag &amp; drop (or
     * its touch counterpart).
     */
    construct: function (config) {
      var self = this;
      this.$listEl = config.$listEl;
      this.$itemEl = config.$itemEl;
      this.$items = config.$items;
      this.dragCls = config.dragCls;
      this.fixHorizontalPosition = (config.fixHorizontalPosition !== false);
      this.autoScroller = (config.autoScrolling ?
        new ListItemAutoScroller(this.$itemEl, 8, function (x, y) {
          self._autoMove(x, y);
        }) : undefined);
    },

    /**
     * Gets the page coordinates of the specified event, regardless if it is a mouse
     * or a touch event.
     * @param {Object} e The event
     * @return {{x: (Number), y: (Number)}} The page coordinates
     * @private
     */
    _getEventCoords: function (e) {
      if (!e.originalEvent.touches) {
        return {
          x: e.pageX,
          y: e.pageY
        };
      }
      return (e.originalEvent.touches.length > 0 ? {
        x: e.originalEvent.touches[0].pageX,
        y: e.originalEvent.touches[0].pageY
      } : e.originalEvent.changedTouches.length > 0 ? {
        x: e.originalEvent.changedTouches[0].pageX,
        y: e.originalEvent.changedTouches[0].pageY
      } : {
        x: e.pageX,
        y: e.pageY
      });
    },

    /**
     * Limits the specified coordinates to the list's real estate.
     * @param {Number} top vertical coordinate to limit
     * @param {Number} left horizontal coordinate to limit
     * @return {{top: *, left: *}}
     * @private
     */
    _limit: function (top, left) {
      if (left < this.listOffset.left) {
        left = this.listOffset.left;
      }
      if (top < this.listOffset.top) {
        top = this.listOffset.top;
      }
      var right = left + this.size.width;
      var bottom = top + this.size.height;
      var limitRight = this.listOffset.left + this.listSize.width;
      var limitBottom = this.listOffset - top + this.listSize.height;
      if (right > limitRight) {
        left = limitRight - this.size.width;
      }
      if (bottom > limitBottom) {
        top = limitBottom - this.size.height;
      }
      if (this.fixHorizontalPosition) {
        left = this.listOffset.left;
      }
      return {
        "top": top,
        "left": left
      };
    },

    /**
     * Gets the coordinates of the specified event in a device (mouse, touch) agnostic
     * way.
     * @param {Object} e The event
     * @return {{x: Number, y: Number}} The coordinates
     * @private
     */
    _getEventPos: function (e) {
      var evtPos = this._getEventCoords(e);
      return {
        x: evtPos.x - this.delta.left,
        y: evtPos.y - this.delta.top
      };
    },

    /**
     * Adjust the position of the moved item by limiting it to the containing list
     * and executing autoscrolling.
     * @param {Number} x The original x coordinate
     * @param {Number} y The original y coordinate
     * @private
     */
    _adjustPosition: function (x, y) {
      this.$itemEl.offset(this._limit(y, x));
      if (this.autoScroller) {
        this.autoScroller.check();
      }
    },

    /**
     * Changes the order of the items in the list if necessary.
     * @private
     */
    _changeOrderIfRequired: function () {
      var itemPos = this.$itemEl.offset();
      var hotX = itemPos.left + (this.size.width / 2);
      var hotY = itemPos.top + (this.size.height / 2);
      var $newTarget = null;
      // check if we are overlapping another item at least 50% -> then we will take
      // its position
      var isInsertBefore = false;
      for (var i = 0; i < this.$items.length; i++) {
        var $item = $(this.$items[i]);
        if (!Utils.equals($item, this.$itemEl)) {
          var offs = $item.offset();
          var width = $item.width();
          var height = $item.height();
          var bottom = offs.top + height;
          if ((hotX >= offs.left) && (hotX < offs.left + width) &&
            (hotY >= offs.top) && (hotY < bottom)) {
            isInsertBefore = ((hotY - offs.top) > (bottom - hotY));
            $newTarget = $item;
            break;
          }
        }
      }
      if ($newTarget) {
        var _offs = this.$itemEl.offset();
        if (isInsertBefore) {
          $newTarget.before(this.$itemEl);
        } else {
          $newTarget.after(this.$itemEl);
        }
        this.$itemEl.offset(_offs);
      }
    },

    /**
     * Callback for auto move (called by auto scroller implementation)
     * @param x {Number}The horizontal position
     * @param y {Number}The vertical position
     * @private
     */
    _autoMove: function (x, y) {
      this._adjustPosition(x, y);
      this._changeOrderIfRequired();
    },

    /**
     * Starts moving the list item.
     * @param {Object} e The event that starts the move
     */
    start: function (e) {
      this.$oldPrev = this.$itemEl.prev();
      this.$oldNext = this.$itemEl.next();

      var evtPos = this._getEventCoords(e);
      if (this.dragCls) {
        this.$itemEl.addClass(this.dragCls);
      }
      var self = this;
      this.$doc = $(document);
      this.$doc.on("touchmove.listview.drag mousemove.listview.drag",
        function (e) {
          self.move(e);
        });
      this.$doc.on("touchend.listview.drag mouseup.listview.drag",
        function (e) {
          self.end(e);
        });
      this.offset = this.$itemEl.offset();
      this.delta = {
        "left": evtPos.x - this.offset.left,
        "top": evtPos.y - this.offset.top
      };
      this.size = {
        "width": this.$itemEl.width(),
        "height": this.$itemEl.height()
      };
      this.listOffset = this.$listEl.offset();
      this.listSize = {
        "width": this.$listEl.width(),
        "height": this.$listEl.height()
      };
      e.stopPropagation();
      e.preventDefault();
      /*
       console.log("offset", this.offset, "delta", this.delta, "size", this.size,
       "listoffs", this.listOffset, "listsize", this.listSize);
       */
    },

    /**
     * Moves the card item.
     * @param {Object} e The event that is responsible for the move
     */
    move: function (e) {
      // console.log("move", e);
      var pos = this._getEventPos(e);
      this._adjustPosition(pos.x, pos.y);
      this._changeOrderIfRequired();
      e.stopPropagation();
      e.preventDefault();
    },

    /**
     * Finishes moving the card item.
     * @param {Object} e The event that is responsible for finishing the move
     */
    end: function (e) {
      var pos = this._getEventPos(e);
      this._adjustPosition(pos.x, pos.y);
      // console.log("end", e);
      if (this.dragCls) {
        this.$itemEl.removeClass(this.dragCls);
      }
      if (this.autoScroller) {
        this.autoScroller.stop();
      }
      this.$itemEl.css("position", "");
      this.$itemEl.css("top", "");
      this.$itemEl.css("left", "");
      this.$doc.off("touchmove.listview.drag");
      this.$doc.off("mousemove.listview.drag");
      this.$doc.off("touchend.listview.drag");
      this.$doc.off("mouseup.listview.drag");
      var $newPrev = this.$itemEl.prev();
      var $newNext = this.$itemEl.next();

      this.$itemEl.trigger($.Event("item-moved", {
        newPrev: $newPrev,
        newNext: $newNext,
        oldPrev: this.$oldPrev,
        oldNext: this.$oldNext,
        hasMoved: !Utils.equals($newPrev, this.$oldPrev)
      }));
      e.stopPropagation();
      e.preventDefault();
    }

  });

  /*
   * This class represents a single item in the list model.
   */
  var Item = new Class(/** @lends CUI.CardView.Item# */{

    /**
     * The jQuery object that represents the card
     * @type {jQuery}
     * @private
     */
    $itemEl: null,

    /**
     * @ignore
     * @name CUI.CardView.Item
     *
     * @classdesc
     * Internal class that represents a single card/list item in a card view's data
     * model.
     *
     * @constructor
     * @desc
     * Create a new card/list item.
     */
    construct: function ($itemEl) {
      this.$itemEl = $itemEl;
      this.reference();
    },

    /**
     * Get the card/list item's jQuery object.
     * @return {jQuery} The jQuery object
     */
    getItemEl: function () {
      return this.$itemEl;
    },

    /**
     * References the item's data model in the jQzery object.
     */
    reference: function () {
      this.$itemEl.data("cardView-item", this);
    }

  });

  var Header = new Class(/** @lends CUI.CardView.Header# */{

    /**
     * The jQuery object that represents the header
     * @type {jQuery}
     * @private
     */
    $headerEl: null,

    /**
     * The first item that follows the header
     * @type {CUI.CardView.Item}
     */
    itemRef: null,

    /**
     * @ignore
     * @name CUI.CardView.Header
     *
     * @classdesc
     * This class represents a list header (that is shown in list view only) in the
     * card view's data model.
     *
     * @constructor
     * @desc
     * Create a new list header.
     */
    construct: function ($headerEl, itemRef) {
      this.$headerEl = $headerEl;
      this.itemRef = itemRef;
    },

    /**
     * Get the jQuery object that is assosciated with the list header.
     * @return {jQuery} The associated jQuery object
     */
    getHeaderEl: function () {
      return this.$headerEl;
    },

    /**
     * Get the list item that follows the header directly.
     * @return {CUI.CardView.Item} The item
     */
    getItemRef: function () {
      return this.itemRef;
    },

    /**
     * Set the list item that follows the header directly.
     * @param {CUI.CardView.Item} itemRef The item
     */
    setItemRef: function (itemRef) {
      this.itemRef = itemRef;
    }

  });

  /**
   Handles resort according to columns
   */
  var ColumnSortHandler = new Class(/** @lends CUI.CardView.ColumnSortHandler# */{
    construct: function (options) {
      this.model = options.model;
      this.comparators = options.comparators;
      this.selectors = options.selectors;
      this.columnElement = options.columnElement;

      this.headerElement = options.columnElement.closest(this.selectors.headerSelector);
      var header = this.model.getHeaderForEl(this.headerElement);
      this.items = this.model.getItemsForHeader(header);

      this.isReverse = this.columnElement.hasClass("sort-asc"); // switch to reverse?
      this.toNatural = this.columnElement.hasClass("sort-desc"); // back to natural order?
      this.fromNatural = !this.headerElement.hasClass("sort-mode");

      this.comparator = null;

      // Choose the right comparator
      if (this.comparators) {
        for (var selector in this.comparators) {
          if (!this.columnElement.is(selector)) continue;
          this.comparator = this.comparators[selector];
        }
      }

      if (!this.comparator) this.comparator = this._readComparatorFromMarkup();
    },
    _readComparatorFromMarkup: function () {
      var selector = this.columnElement.data("sort-selector");
      var attribute = this.columnElement.data("sort-attribute");
      var sortType = this.columnElement.data("sort-type");
      var ignoreCase = this.columnElement.data("ignorecase");
      if (!selector && !attribute) return null;
      return new CUI.CardView.DefaultComparator(selector, attribute, sortType, ignoreCase);

    },
    _adjustMarkup: function () {
      // Adjust general mode class
      if (this.fromNatural) this.headerElement.addClass("sort-mode");
      if (this.toNatural) this.headerElement.removeClass("sort-mode");

      // Adjust column classes
      this.headerElement.find(this.selectors.controller.sort.columnSelector).removeClass("sort-asc sort-desc");
      this.columnElement.removeClass("sort-desc sort-asc");
      if (!this.toNatural) this.columnElement.addClass(this.isReverse ? "sort-desc" : "sort-asc");

      // Show or hide d&d elements
      var showMoveHandle = this.toNatural;
      $.each(this.items, function () {
        this.getItemEl().find(".move").toggle(showMoveHandle);
      });
    },
    sort: function () {
      if (!this.comparator && !this.toNatural) return;

      this._adjustMarkup();

      // Re-Sort items
      var items = this.items.slice(); // Make a copy before sorting
      // By default items are in their "natural" order, most probably defined by the user with d&d

      // Only sort if we have a comparator
      if (this.comparator) {
        this.comparator.setReverse(this.isReverse);
        var fn = this.comparator.getCompareFn();
        if (!this.toNatural) items.sort(fn);   // Only sort if we do not want to go back to natural order
      }

      // Adjust DOM
      var prevItem = this.headerElement; // Use header as starting point;
      $.each(this.items, function () {
        this.getItemEl().detach();
      }); // First: Detach all items

      // Now: reinsert in new order
      for (var i = 0; i < items.length; i++) {
        var item = items[i].getItemEl();
        prevItem.after(item);
        prevItem = item;
      }
    }
  });


  var DirectMarkupModel = new Class(/** @lends CUI.CardView.DirectMarkupModel# */{

    /**
     * The jQuery object that is the parent of the card view
     * @type {jQuery}
     * @private
     */
    $el: null,

    /**
     * List of items; original/current sorting order (without UI sorting applied)
     * @type {CUI.CardView.Item[]}
     * @private
     */
    items: null,

    /**
     * List of headers
     * @type {CUI.CardView.Header[]}
     * @private
     */
    headers: null,

    /**
     * CSS selector config
     * @type {Object}
     * @private
     */
    selectors: null,

    /**
     * @ignore
     * @name CUI.CardView.DirectMarkupModel
     *
     * @classdesc
     * This class represents a data model that is created via a selector from an
     * existing DOM.
     *
     * @constructor
     * @desc
     * Create a new data model.
     * @param {jQuery} $el The jQuery object that is the parent of the card view
     * @param {Object} selectors The CSS selector config
     */
    construct: function ($el, selectors) {
      this.$el = $el;
      this.items = [ ];
      this.selectors = selectors;
      var $items = this.$el.find(selectors.itemSelector);
      var itemCnt = $items.length;
      for (var i = 0; i < itemCnt; i++) {
        this.items.push(new Item($($items[i])));
      }
      this.headers = [ ];
      var $headers = this.$el.find(selectors.headerSelector);
      var headerCnt = $headers.length;
      for (var h = 0; h < headerCnt; h++) {
        var $header = $($headers[h]);
        var $itemRef = $header.nextAll(selectors.itemSelector);
        var itemRef = ($itemRef.length > 0 ?
          this.getItemForEl($($itemRef[0])) : undefined);
        this.headers.push(new Header($header, itemRef));
      }
    },

    /**
     * Initialize the data model.
     */
    initialize: function () {
      var self = this;
      this.$el.on("item-moved", this.selectors.itemSelector, function (e) {
        if (e.hasMoved) {
          self._reorder(e);
        }
      });
    },

    /**
     * Reorder the cards according to the specified event.
     * @param {Event} e The reordering event
     * @private
     */
    _reorder: function (e) {
      var itemToMove = this.getItemForEl($(e.target));
      var newBefore = this.getItemForEl(e.newPrev);
      var isHeaderInsert = false;
      var header;
      if (!newBefore) {
        header = this.getHeaderForEl(e.newPrev);
        if (header) {
          isHeaderInsert = true;
          var refPos = this.getItemIndex(header.getItemRef());
          if (refPos > 0) {
            newBefore = this.getItemAt(refPos - 1);
          }
        }
      }
      var oldPos = this.getItemIndex(itemToMove);
      this.items.splice(oldPos, 1);
      // if the item to move is directly following a header, the header's item ref
      // has to be updated
      var headerRef = this._getHeaderByItemRef(itemToMove);
      if (headerRef) {
        headerRef.setItemRef(this.getItemAt(oldPos));
      }
      var insertPos = (newBefore ? this.getItemIndex(newBefore) + 1 : 0);
      this.items.splice(insertPos, 0, itemToMove);
      if (isHeaderInsert) {
        header.setItemRef(itemToMove);
      }
      // console.log(itemToMove, newBefore, isHeaderInsert);
    },

    /**
     * Get the number of cards/list items.
     * @return {Number} The number of cards/list items
     */
    getItemCount: function () {
      return this.items.length;
    },

    /**
     * Get the card/list item that is at the specified list position.
     * @param {Number} pos The position
     * @return {CUI.CardView.Item} The item at the specified position
     */
    getItemAt: function (pos) {
      return this.items[pos];
    },

    /**
     * Get the list position of the specified card/list item.
     * @param {CUI.CardView.Item} item The item
     * @return {Number} The list position; -1 if the specified item is not a part of
     *         the list
     */
    getItemIndex: function (item) {
      for (var i = 0; i < this.items.length; i++) {
        if (item === this.items[i]) {
          return i;
        }
      }
      return -1;
    },

    /**
     * Get the card/list item that is associated with the specified jQuery object.
     * @param {jQuery} $el The jQuery object
     * @return {CUI.CardView.Item} The item; undefined if no item is associated with
     *         the specified jQuery object
     */
    getItemForEl: function ($el) {
      var itemCnt = this.items.length;
      for (var i = 0; i < itemCnt; i++) {
        var item = this.items[i];
        if (Utils.equals(item.getItemEl(), $el)) {
          return item;
        }
      }
      return undefined;
    },

    /**
     * <p>Inserts the specified card(s)/list item(s) at the given position.</p>
     * <p>Please note that you can specify multiple items either as an array of jQuery
     * objects or a single jQuery object that contains multiple DOM objects, each
     * representing an item.</p>
     * @param {jQuery|jQuery[]} $items The item(s) to insert
     * @param {Number} pos The position to insert
     * @param {Boolean} beforeHeader True if the items should added before headers (only
     *        applicable if the items are inserted directly at a position where also
     *        a header is present); needs to be false if the list has a single header
     *        that is placed at the top of the list
     */
    insertItemAt: function ($items, pos, beforeHeader) {
      if (!$.isArray($items)) {
        $items = $items.toArray();
      }
      for (var i = $items.length - 1; i >= 0; i--) {

        var $item = $items[i];
        if (!$item.jquery) {
          $item = $($item);
        }

        // adjust model
        var followupItem;
        var item = new Item($item);
        if ((pos === undefined) || (pos === null)) {
          this.items.push(item);
          pos = this.items.length - 1;
        } else {
          followupItem = this.items[pos];
          this.items.splice(pos, 0, item);
        }
        var insert = {
          "item": followupItem,
          "mode": "item"
        };

        // adjust header references if item is inserted directly behind a header
        var headerCnt = this.headers.length;
        for (var h = 0; h < headerCnt; h++) {
          var header = this.headers[h];
          if (header.getItemRef() === followupItem) {
            if (beforeHeader) {
              insert = {
                "item": header,
                "mode": "header"
              };
              break;
            } else {
              header.setItemRef(item);
            }
          }
        }

        // trigger event
        this.$el.trigger($.Event("change:insertitem", {
          "insertPoint": insert,
          "followupItem": followupItem,
          "item": item,
          "pos": pos,
          "widget": Utils.getWidget(this.$el),
          "moreItems": (i > 0)
        }));
      }
    },

    /**
     * Get the number of list headers.
     * @return {Number} The number of headers
     */
    getHeaderCount: function () {
      return this.headers.length;
    },

    /**
     * Get a list header by its position in the list of headers.
     * @param {Number} pos The list header
     * @return {CUI.CardView.Header} The list header at the specified position
     */
    getHeaderAt: function (pos) {
      return this.headers[pos];
    },

    /**
     * Get all list headers.
     * @return {CUI.CardView.Header[]} List headers
     */
    getHeaders: function () {
      var headers = [ ];
      headers.push.apply(headers, this.headers);
      return headers;
    },

    /**
     * Get the list header that is associated with the specified jQuery object.
     * @param {jQuery} $el The jQuery object
     * @return {CUI.CardView.Header} The list header; undefined if no header is
     *         associated with the jQuery object
     */
    getHeaderForEl: function ($el) {
      var headerCnt = this.headers.length;
      for (var h = 0; h < headerCnt; h++) {
        var header = this.headers[h];
        if (Utils.equals(header.getHeaderEl(), $el)) {
          return header;
        }
      }
      return undefined;
    },

    /**
     * Get the header that directly precedes the specified list item.
     * @param {CUI.CardView.Item} itemRef The item
     * @return {CUI.CardView.Header} header The header
     * @private
     */
    _getHeaderByItemRef: function (itemRef) {
      for (var h = 0; h < this.headers.length; h++) {
        if (this.headers[h].getItemRef() === itemRef) {
          return this.headers[h];
        }
      }
      return undefined;
    },

    /**
     * Get all list items that are preceded by the specified header.
     * @param header {CUI.CardView.Header} The header
     * @return {CUI.CardView.Item[]} The list items
     */
    getItemsForHeader: function (header) {
      // TODO does not handle empty headers yet
      var itemRef = header.getItemRef();
      var headerCnt = this.headers.length;
      var itemCnt = this.items.length;
      var itemsForHeader = [ ];
      var isInRange = false;
      for (var i = 0; i < itemCnt; i++) {
        var item = this.items[i];
        if (isInRange) {
          for (var h = 0; h < headerCnt; h++) {
            if (this.headers[h].getItemRef() === item) {
              isInRange = false;
              break;
            }
          }
          if (isInRange) {
            itemsForHeader.push(item);
          } else {
            break;
          }
        } else {
          if (item === itemRef) {
            isInRange = true;
            itemsForHeader.push(itemRef);
          }
        }
      }
      return itemsForHeader;
    },

    /**
     * Get the list items (data model) from their associated DOM objects.
     * @param {jQuery} $elements The jQuery object that specifies the items' DOM
     *        objects
     * @return {CUI.CardView.Item[]} List items
     */
    fromItemElements: function ($elements) {
      var items = [ ];
      $elements.each(function () {
        var item = $(this).data("cardView-item");
        if (item) {
          items.push(item);
        }
      });
      return items;
    },

    /**
     * Write back references to the data model to the respective DOM objects.
     */
    reference: function () {
      var itemCnt = this.items.length;
      for (var i = 0; i < itemCnt; i++) {
        this.items[i].reference();
      }
    },

    /**
     * Removes all items without triggering respective events.
     */
    removeAllItemsSilently: function () {
      this.items.length = 0;
      for (var h = 0; h < this.headers.length; h++) {
        this.headers[h].setItemRef(undefined);
      }
    }

  });

  var DirectMarkupView = new Class(/** @lends CUI.CardView.DirectMarkupView# */{

    /**
     * The jQuery object that is the parent of the card view
     * @type {jQuery}
     * @private
     */
    $el: null,

    /**
     * CSS selector config
     * @type {Object}
     * @private
     */
    selectors: null,

    /**
     * @ignore
     * @name CUI.CardView.DirectMarkupView
     *
     * @classdesc
     * This class represents a view for data represented by a DirectMarkupModel.
     *
     * @constructor
     * @desc
     * Create a new view.
     * @param {jQuery} $el The jQuery object that is the parent of the card view
     * @param {Object} selectors The CSS selector config
     */
    construct: function ($el, selectors) {
      this.$el = $el;
      this.selectors = selectors;
    },

    /**
     * Initializes the view.
     */
    initialize: function () {
      var self = this;
      this.$el.on("change:displayMode", function (e) {
        var oldMode = e.oldValue;
        var newMode = e.value;
        self.cleanupAfterDisplayMode(oldMode);
        self.prepareDisplayMode(newMode);
      });
      this.$el.on("change:insertitem", function (e) {
        self._onItemInserted(e);
      });
      this.$el.reflow({
        "small": function ($el, size) {
          return $el.width() > 40 * size.rem() && $el.width() < 50 * size.rem();
        },
        "xsmall": function ($el, size) {
          return $el.width() > 30 * size.rem() && $el.width() < 40 * size.rem();
        },
        "xxsmall": function ($el, size) {
          return $el.width() < 30 * size.rem();
        }
      });
    },

    /**
     * Handler that adjusts the view after a new card/list item has been inserted.
     * @param {Event} e The event
     * @private
     */
    _onItemInserted: function (e) {
      var $dataRoot = this.$el;
      if (this.selectors.dataContainer) {
        $dataRoot = $dataRoot.find("." + this.selectors.dataContainer);
      }
      var $item = e.item.getItemEl();
      var followupItem = e.followupItem;
      switch (this.getDisplayMode()) {
        case DISPLAY_LIST:
          if (!followupItem) {
            $dataRoot.append($item);
          } else {
            var insert = e.insertPoint;
            var item = insert.item;
            var $ref = (insert.mode === "item" ?
              item.getItemEl() : item.getHeaderEl());
            $ref.before($item);
          }
          break;
        case DISPLAY_GRID:
          if (!e.moreItems) {
            var widget = Utils.getWidget(this.$el);
            widget._restore();
            widget.layout();
          }
          break;
      }
    },

    /**
     * Get the current display mode (grid view/list view)
     * @return {String} The display mode; defined by constants prefixed by DISPLAY_
     */
    getDisplayMode: function () {
      return Utils.getWidget(this.$el).getDisplayMode();
    },

    /**
     * Set the selection state of the specified item.
     * @param {CUI.CardView.Item} item The item
     * @param {String} selectionState The selection state; currently supported:
     *        "selected", "unselected"
     */
    setSelectionState: function (item, selectionState) {
      var displayMode = this.getDisplayMode();
      var selectorDef = this.selectors.view.selectedItem[displayMode];
      var $itemEl = item.getItemEl();
      if (selectorDef.selector) {
        $itemEl = $itemEl.find(selectorDef.selector);
      }
      if (selectionState === "selected") {
        $itemEl
          .addClass(selectorDef.cls)
          .prev()
          .addClass(selectorDef.prv);
        if (displayMode === DISPLAY_GRID) {
          this._drawSelectedGrid(item);
        }
      } else if (selectionState === "unselected") {
        $itemEl
          .removeClass(selectorDef.cls)
          .prev()
          .removeClass(selectorDef.prv);
      }
    },

    /**
     * Get the selection state of the specified item.
     * @param {CUI.CardView.Item} item The item
     * @return {String} The selection state; currently supported: "selected",
     *         "unselected"
     */
    getSelectionState: function (item) {
      var selectorDef = this.selectors.view.selectedItem[this.getDisplayMode()];
      var $itemEl = item.getItemEl();
      if (selectorDef.selector) {
        $itemEl = $itemEl.find(selectorDef.selector);
      }
      var cls = selectorDef.cls.split(" ");
      for (var c = 0; c < cls.length; c++) {
        if (!$itemEl.hasClass(cls[c])) {
          return "unselected";
        }
      }
      return "selected";
    },

    /**
     * Get a list of currently selected items.
     * @return {jQuery} The list of selected items
     */
    getSelectedItems: function () {
      var selectorDef = this.selectors.view.selectedItems[this.getDisplayMode()];
      var $selectedItems = this.$el.find(selectorDef.selector);
      if (selectorDef.resolver) {
        $selectedItems = selectorDef.resolver($selectedItems);
      }
      return $selectedItems;
    },

    /**
     * <p>Restors the card view.</p>
     * <p>The container is purged and the cards are re-inserted in original order
     * (note that this is necessary, because the item elements get reordered for
     * card view; original order has to be restored for list view),</p>
     * @param {CUI.CardView.DirectMarkupModel} model The data model
     * @param {Boolean} restoreHeaders True if header objects should be restored as
     *        well (for list view)
     */
    restore: function (model, restoreHeaders) {
      var $container = $("<div class='" + this.selectors.dataContainer + "'>");
      this.$el.empty();
      this.$el.append($container);
      var itemCnt = model.getItemCount();
      for (var i = 0; i < itemCnt; i++) {
        $container.append(model.getItemAt(i).getItemEl());
      }
      if (restoreHeaders) {
        var headerCnt = model.getHeaderCount();
        for (var h = 0; h < headerCnt; h++) {
          var header = model.getHeaderAt(h);
          var $headerEl = header.getHeaderEl();
          var itemRef = header.getItemRef();
          if (itemRef) {
            itemRef.getItemEl().before($headerEl);
          } else {
            $container.append($headerEl);
          }
        }
      }
    },

    /**
     * Prepares the specified display mode (grid vs. list view).
     * @param {String} displayMode The display mode ({@link CUI.CardView.DISPLAY_GRID},
     *        {@link CUI.CardView.DISPLAY_LIST})
     */
    prepareDisplayMode: function (displayMode) {
      if (displayMode === DISPLAY_GRID) {
        this._drawAllSelectedGrid();
      }
    },

    /**
     * Clean up before the specified display mode is left.
     * @param {String} displayMode The display mode ({@link CUI.CardView.DISPLAY_GRID},
     *        {@link CUI.CardView.DISPLAY_LIST})
     */
    cleanupAfterDisplayMode: function (displayMode) {
      // not yet required; may be overridden
    },

    /**
     * Draw the multiplied version (used for displaying a selection) of the specified
     * image.
     * @param {jQuery} $image The image
     * @private
     */
    _drawImage: function ($image, $item) {
      if ($image.length === 0) {
        return;
      }

      if (this._colorFloat === undefined) {
        var color256 = $image.closest("a, .card", $item[0]).css("background-color");  // Let's grab the color from the card background

        if (!color256 || color256.indexOf("rgb(") < 0) {
            return;
        }

        this._colorFloat = $.map(color256.match(/(\d+)/g), function (val) { // RGB values between 0 and 1
          return val / 255;
        });
      }

      Utils.multiplyImages($image, this._colorFloat);
    },

    /**
     * Create the multiplied images for selected state (in grid view) for all cards.
     * @private
     */
    _drawAllSelectedGrid: function () {
      if (!this.selectors.enableImageMultiply) {
        return;
      }
      var self = this;

      $(this.selectors.view.selectedItems.grid.selector).each(function () {
        var $item = $(this);
        var $img = $item.find("img");

        self._drawImage($img, $item);
        $img.load(function () {
          self._drawImage($(this), $item);
        });
      });
    },

    /**
     * Create the multiplied image for the selected state of the specified card (in
     * grid view).
     * @param {CUI.CardView.Item} item The card/list item
     * @private
     */
    _drawSelectedGrid: function (item) {
      if (!this.selectors.enableImageMultiply) {
        return;
      }
      var self = this;
      var $item = item.getItemEl();
      var $img = $item.find("img");

      this._drawImage($img, $item);
      $img.load(function () {
        self._drawImage($(this), $item);
      });
    },

    /**
     * Removes all items from the view without triggering respective events.
     */
    removeAllItemsSilently: function () {
      this.$el.find(this.selectors.itemSelector).remove();
    }

  });

  var DirectMarkupController = new Class(/** @lends CUI.CardView.DirectMarkupController# */{

    /**
     * The jQuery object that is the parent of the card view
     * @type {jQuery}
     * @private
     */
    $el: null,

    /**
     * CSS selector config
     * @type {Object}
     * @private
     */
    selectors: null,

    /**
     * comparator config for list sorting
     * @type {Object}
     * @private
     */
    comparators: null,

    /**
     * The selection mode
     * @type {String}
     * @private
     */
    selectionModeCount: null,

    /**
     * @ignore
     * @name CUI.CardView.DirectMarkupController
     *
     * @classdesc
     * This class implements the controller for data represented by DirectMarkupModel
     * and displayed by DirectMarkupView.
     *
     * @constructor
     * @desc
     * Create a new controller.
     * @param {jQuery} $el The jQuery object that is the parent of the card view
     * @param {Object} selectors The CSS selector config
     * @param {Object} comparators The comparator config for column sorting
     */
    construct: function ($el, selectors, comparators) {
      this.$el = $el;
      this.selectors = selectors;
      this.comparators = comparators;
      this.selectionModeCount = SELECTION_MODE_COUNT_MULTI;
    },

    /**
     * Initializes the controller
     */
    initialize: function () {
      this.setDisplayMode(this.$el.hasClass("list") ? DISPLAY_LIST : DISPLAY_GRID);
      var self = this;

      // Selection
      this.$el.on("click.cardview.select",
        this.selectors.controller.selectElement.list, function (e) {
          var widget = Utils.getWidget(self.$el);
          if (widget.getDisplayMode() === DISPLAY_LIST) {
            var item = ensureItem(self.getItemElFromEvent(e));
            if (widget.toggleSelection(item)) {
              e.stopPropagation();
              e.preventDefault();
            }
          }
        });
      this.$el.on("click.cardview.select",
        this.selectors.controller.selectElement.grid, function (e) {
          var widget = Utils.getWidget(self.$el);
          if ((widget.getDisplayMode() === DISPLAY_GRID) &&
            widget.isGridSelectionMode()) {
            var item = ensureItem(self.getItemElFromEvent(e));
            if (widget.toggleSelection(item)) {
              e.stopPropagation();
              e.preventDefault();
            }
          }
        });
      // list header
      this.$el.on("click.cardview.selectall",
        this.selectors.controller.selectAll.selector, function (e) {
          var widget = Utils.getWidget(self.$el);
          if (widget.getDisplayMode() === DISPLAY_LIST) {
            var cls = self.selectors.controller.selectAll.cls;
            var $header = self.selectors.controller.targetToItem.header(
              $(e.target));
            var header = widget.getModel().getHeaderForEl($header);
            if ($header.hasClass(cls)) {
              widget.deselectAll(header);
            } else {
              widget.selectAll(header);
            }
          }
        });

      // list sorting
      this.$el.on("click.cardview.sort",
        this.selectors.headerSelector + " " + this.selectors.controller.sort.columnSelector, function (e) {

          var widget = Utils.getWidget(self.$el);
          var model = widget.getModel();

          // Trigger a sortstart event
          var event = $.Event("sortstart");
          $(e.target).trigger(event);
          if (event.isDefaultPrevented()) return;

          var sorter = new ColumnSortHandler({
            model: model,
            columnElement: $(e.target),
            comparators: self.comparators,
            selectors: self.selectors
          });
          sorter.sort();

          // Trigger an sortend event
          event = $.Event("sortend");
          $(e.target).trigger(event);
        });

      // Prevent text selection of headers!
      this.$el.on("selectstart.cardview", this.selectors.headerSelector + " " + this.selectors.controller.sort.columnSelector, function (e) {
        e.preventDefault();
      });

      // reordering
      this.$el.on("touchstart.cardview.reorder mousedown.cardview.reorder",
        this.selectors.controller.moveHandleElement.list, function (e) {
          var $itemEl = self.getItemElFromEvent(e);
          var handler = new ListItemMoveHandler({
            $listEl: self.$el,
            $itemEl: $itemEl,
            $items: $(self.selectors.itemSelector),
            dragCls: "dragging",
            autoScrolling: true
          });
          handler.start(e);
        });
      // handle select all state
      this.$el.on("change:selection", function (e) {
        if (e.moreSelectionChanges) {
          return;
        }
        self._adjustSelectAllState(e.widget);
      });
      this.$el.on("change:insertitem", function (e) {
        if (e.moreItems) {
          return;
        }
        self._adjustSelectAllState(e.widget);
      });
    },

    /**
     * Adjusts the state of the "select all" element of all list headers.
     * @param {CUI.CardView} widget The card view widget
     * @private
     */
    _adjustSelectAllState: function (widget) {
      var cls = this.selectors.controller.selectAll.cls;
      var selectionState = widget.getHeaderSelectionState();
      var headers = selectionState.headers;
      var headerCnt = headers.length;
      for (var h = 0; h < headerCnt; h++) {
        var header = headers[h];
        var $header = header.header.getHeaderEl();
        if (header.hasUnselected) {
          $header.removeClass(cls);
        } else {
          $header.addClass(cls);
        }
      }
    },

    /**
     * Resolves the target of the specified event to a jQuery element that represents
     * a card.
     * @param {Event} e The event
     * @return {jQuery} The jQuery object that represents a card
     */
    getItemElFromEvent: function (e) {
      var $target = $(e.target);
      var resolver = this.selectors.controller.targetToItem[this.getDisplayMode()];
      if ($.isFunction(resolver)) {
        return resolver($target);
      }
      return $target.find(resolver);
    },

    /**
     * Checks if selection mode is enabled for grid view.
     * @return {Boolean} True if selection mode is enabled
     */
    isGridSelect: function () {
      var selectorDef = this.selectors.controller.gridSelect;
      var $el = this.$el;
      if (selectorDef.selector) {
        $el = $el.find(selectorDef.selector);
      }
      return $el.hasClass(selectorDef.cls);
    },

    /**
     * Set selection mode for grid view.
     * @param {Boolean} isGridSelect True to turn selection mode on
     */
    setGridSelect: function (isGridSelect) {
      if (this.isGridSelect() !== isGridSelect) {
        var selectorDef = this.selectors.controller.gridSelect;
        var $el = this.$el;
        if (selectorDef.selector) {
          $el = $el.find(selectorDef.selector);
        }
        if (isGridSelect) {
          $el.addClass(selectorDef.cls);
        } else {
          $el.removeClass(selectorDef.cls);
          Utils.getWidget($el).clearSelection();
        }
        this.$el.trigger($.Event("change:gridSelect", {
          "widget": this.$el.data("cardView"),
          "oldValue": !isGridSelect,
          "value": isGridSelect
        }));
      }
    },

    /**
     * Get current display mode (grid/list view).
     * @return {String} Display mode ({@link CUI.CardView.DISPLAY_GRID},
     *         {@link CUI.CardView.DISPLAY_LIST})
     */
    getDisplayMode: function () {
      if (this.$el.hasClass("list")) {
        return DISPLAY_LIST;
      }
      if (this.$el.hasClass("grid")) {
        return DISPLAY_GRID;
      }
      return null;
    },

    /**
     * @return {boolean} true if this widget is currently in list mode and has a column sorting on any header applied
     */
    isColumnSorted: function () {
      return (this.getDisplayMode() == "list") && this.$el.find(this.selectors.headerSelector).filter(".sort-mode").length > 0;
    },

    /**
     * Set display mode.
     * @param {String} displayMode Display mode ({@link CUI.CardView.DISPLAY_GRID},
     *        {@link CUI.CardView.DISPLAY_LIST})
     */
    setDisplayMode: function (displayMode) {
      var oldValue = this.getDisplayMode();
      if (oldValue !== displayMode) {
        var widget = Utils.getWidget(this.$el);
        widget._restore(displayMode === DISPLAY_LIST);
        switch (displayMode) {
          case DISPLAY_GRID:
            this.$el.removeClass("list");
            this.$el.addClass("grid");
            if (oldValue !== null) {
              var selection = widget.getSelection();
              this.setGridSelect(selection.length > 0);
              widget.layout();
            }
            break;
          case DISPLAY_LIST:
            this.$el.cuigridlayout("destroy");
            this.$el.removeClass("grid");
            this.$el.addClass("list");
            break;
        }
        this.$el.trigger($.Event("change:displayMode", {
          "widget": this.$el.data("cardView"),
          "oldValue": oldValue,
          "value": displayMode
        }));
      }
    },

    /**
     * Get selection mode (single/multiple).
     * @return {String} The selection mode;
     *         {@link CUI.CardView.SELECTION_MODE_COUNT_SINGLE},
     *         {@link CUI.CardView.SELECTION_MODE_COUNT_MULTI}
     */
    getSelectionModeCount: function () {
      return this.selectionModeCount;
    },

    /**
     * Set selection mode (single/multiple).
     * @param {String} modeCount The selection mode;
     *         {@link CUI.CardView.SELECTION_MODE_COUNT_SINGLE},
     *         {@link CUI.CardView.SELECTION_MODE_COUNT_MULTI}
     */
    setSelectionModeCount: function (modeCount) {
      this.selectionModeCount = modeCount;
    }

  });

  var DirectMarkupAdapter = new Class(/** @lends CUI.CardView.DirectMarkupAdapter# */{

    /**
     * The jQuery object that is the parent of the card view
     * @type {jQuery}
     * @private
     */
    $el: null,

    /**
     * CSS selector config
     * @type {Object}
     * @private
     */
    selectors: null,

    /**
     * comparator config
     * @type {Object}
     * @private
     */
    comparators: null,

    /**
     * The model
     * @type {CUI.CardView.DirectMarkupModel}
     * @private
     */
    model: null,

    /**
     * The view
     * @type {CUI.CardView.DirectMarkupView}
     * @private
     */
    view: null,

    /**
     * The controller
     * @type {CUI.CardView.DirectMarkupController}
     * @private
     */
    controller: null,

    /**
     * @ignore
     * @name CUI.CardView.DirectMarkupAdapter
     *
     * @classdesc
     * Internal class that wires model, controller and view.
     *
     * @constructor
     * @desc
     * Create a new adapter.
     * @param {jQuery} $el The jQuery object that is the parent of the card view
     * @param {Object} selectors The CSS selector config
     */
    construct: function (selectors, comparators) {
      this.selectors = selectors;
      this.comparators = comparators;
    },

    /**
     * Initialize the adapter (and the wrapped model, view & controller).
     * @param {jQuery} $el The card view's parent element
     */
    initialize: function ($el) {
      this.$el = $el;
      this.setModel(new DirectMarkupModel($el, this.selectors));
      this.setView(new DirectMarkupView($el, this.selectors));
      this.setController(new DirectMarkupController($el, this.selectors, this.comparators));
      this.model.initialize();
      this.view.initialize();
      this.controller.initialize();
    },

    /**
     * Set the model.
     * @param {CUI.CardView.DirectMarkupModel}model The model
     */
    setModel: function (model) {
      this.model = model;
    },

    /**
     * Get the model.
     * @return {CUI.CardView.DirectMarkupModel}The model
     */
    getModel: function () {
      return this.model;
    },

    /**
     * Set the view.
     * @param {CUI.CardView.DirectMarkupView} view The view
     */
    setView: function (view) {
      this.view = view;
    },

    /**
     * Get the view.
     * @return {CUI.CardView.DirectMarkupView} The view
     */
    getView: function () {
      return this.view;
    },

    /**
     * Set the controller.
     * @param {CUI.CardView.DirectMarkupController} controller The controller
     */
    setController: function (controller) {
      this.controller = controller;
    },

    /**
     * Get the controller.
     * @return {CUI.CardView.DirectMarkupController} The controller
     */
    getController: function () {
      return this.controller;
    },

    /**
     * Check if the specified card/list item is selected.
     * @param {CUI.CardView.Item} item The card/item
     * @return {Boolean} True if it is selected
     */
    isSelected: function (item) {
      var selectionState = this.view.getSelectionState(item);
      return (selectionState === "selected");
    },

    /**
     * Set the selection state of zhe specified card/list item.
     * @param {CUI.CardView.Item} item The card/item
     * @param {Boolean} isSelected True if it is selected
     */
    setSelected: function (item, isSelected) {
      var selectionState = (isSelected ? "selected" : "unselected");
      this.view.setSelectionState(item, selectionState);
    },

    /**
     * Get a list of selected items
     * @param {Boolean} useModel True if {@link CUI.CardView.Item}s should be returned;
     *        false for jQuery objects
     * @return {CUI.CardView.Item[]|jQuery}
     */
    getSelection: function (useModel) {
      var selection = this.view.getSelectedItems();
      if (useModel === true) {
        selection = this.model.fromItemElements(selection);
      }
      return selection;
    },

    /**
     * Get the display mode.
     * @return {String} The display mode ({@link CUI.CardView.DISPLAY_GRID} or
     *         {@link CUI.CardView.DISPLAY_LIST})
     */
    getDisplayMode: function () {
      return this.controller.getDisplayMode();
    },

    /**
     * @return {boolean} true if this widget is currently in list mode and has a column sorting on any header applied
     */
    isColumnSorted: function () {
      return this.controller.isColumnSorted();
    },

    /**
     * Set the display mode.
     * @param {String} selectionMode The display mode ({@link CUI.CardView.DISPLAY_GRID}
     *        or {@link CUI.CardView.DISPLAY_LIST})
     */
    setDisplayMode: function (selectionMode) {
      this.controller.setDisplayMode(selectionMode);
    },

    /**
     * Check if selection mode is active in grid view.
     * @return {Boolean} True if selection mode is active
     */
    isGridSelectionMode: function () {
      return this.controller.isGridSelect();
    },

    /**
     * Set if selection mode is active in grid view.
     * @param {Boolean} isSelectionMdoe True if selection mode is active
     */
    setGridSelectionMode: function (isSelectionMode) {
      this.controller.setGridSelect(isSelectionMode);
    },

    /**
     * Get the general selection mode (single/multiple items)
     * @return {String} The selection mode
     *         ({@link CUI.CardView.SELECTION_MODE_COUNT_SINGLE},
     *         {@link CUI.CardView.SELECTION_MODE_COUNT_MULTI})
     */
    getSelectionModeCount: function () {
      return this.controller.getSelectionModeCount();
    },

    /**
     * Set the general selection mode (single/multiple items)
     * @param {String} modeCount The selection mode
     *        ({@link CUI.CardView.SELECTION_MODE_COUNT_SINGLE},
     *        {@link CUI.CardView.SELECTION_MODE_COUNT_MULTI})
     */
    setSelectionModeCount: function (modeCount) {
      this.controller.setSelectionModeCount(modeCount);
    },

    /**
     * Restores the opriginal DOM structure of the widget.
     * @param {Boolean} restoreHeaders True if list headers should also be restored
     *        (list view)
     * @protected
     */
    _restore: function (restoreHeaders) {
      this.view.restore(this.model, restoreHeaders);
      this.model.reference();
    },

    /**
     * Removes all items from the card view.
     */
    removeAllItems: function () {
      var widget = Utils.getWidget(this.$el);
      widget.clearSelection();
      this.model.removeAllItemsSilently();
      this.view.removeAllItemsSilently();
    }

  });

  CUI.CardView = new Class(/** @lends CUI.CardView# */{

    toString: 'CardView',

    extend: CUI.Widget,

    adapter: null,


    /**
     * @extends CUI.Widget
     * @classdesc
     * <p>A display of cards that can either be viewed as a grid or a list.</p>
     * <p>The display mode - grid or list view - can be changed programmatically
     * whenever required.</p>
     * <p>Grid view has two modes: navigation and selection, which can also be switched
     * programmatically. In navigation mode, the user can use cards to navigate
     * hierarchical structures ("to another stack of cards"). In selection mode, the
     * cards get selected on user interaction instead. List view combines both selection
     * and navigation modes.</p>
     * <p>The card view uses a data model internally that abstracts the cards. This
     * data model is currently not opened as API. Therefore you will often encounter
     * unspecified objects that represent cards in the data model. You can use them
     * interchangibly (for example, if one method returns a card data object, you can
     * pass it to another method that takes a card data object as a parameter), but
     * you shouldn't assume anything about their internals. You may use
     * {@link CUI.CardView#prepend}, {@link CUI.CardView#append} and
     * {@link CUI.CardView#removeAllItems} to manipulate the data model.</p>
     * <p>Please note that the current implementation has some limitiations which are
     * documented if known. Subsequent releases of CoralUI will remove those limitations
     * bit by bit.</p>
     * <p>The following example shows two cards in grid view:</p>
     *
     <div class="grid" data-toggle="cardview">
     <div class="grid-0">
     <article class="card-default">
     <i class="select"></i>
     <i class="move"></i>
     <a href="#">
     <span class="image">
     <img class="show-grid" src="images/preview.png" alt="">
     <img class="show-list" src="images/preview-small.png" alt="">
     </span>
     <div class="label">
     <h4>A card</h4>
     <p>Description</p>
     </div>
     </a>
     </article>
     <article class="card-default">
     <i class="select"></i>
     <i class="move"></i>
     <a href="#">
     <span class="image">
     <img class="show-grid" src="images/preview.png" alt="">
     <img class="show-list" src="images/preview-small.png" alt="">
     </span>
     <div class="label">
     <h4>Another card</h4>
     <p>See shell example page for more info.</p>
     </div>
     </a>
     </article>
     </div>
     </div>
     *
     * @example
     <caption>Instantiate with Class</caption>
     // Currently unsupported.
     *
     * @example
     <caption>Instantiate with jQuery</caption>
     // Currently unsupported.
     *
     * @example
     <caption>Markup</caption>
     &lt;div class="grid" data-toggle="cardview"&gt;
     &lt;div class="grid-0"&gt;
     &lt;article class="card-default"&gt;
     &lt;i class="select"&gt;&lt;/i&gt;
     &lt;i class="move"&gt;&lt;/i&gt;
     &lt;a href="#"&gt;
     &lt;span class="image"&gt;
     &lt;img class="show-grid" src="images/preview.png" alt=""&gt;
     &lt;img class="show-list" src="images/preview-small.png" alt=""&gt;
     &lt;/span&gt;
     &lt;div class="label"&gt;
     &lt;h4&gt;A card&lt;/h4&gt;
     &lt;p&gt;Description&lt;/p&gt;
     &lt;/div&gt;
     &lt;/a&gt;
     &lt;/article&gt;
     &lt;/div&gt;
     &lt;/div&gt;
     * @example
     <caption>Defining comparators for column sorting</caption>
     //  Define a selector for the column and then a comparator to be used for sorting
     // The comparator
     var comparatorConfig = {".label .main": new CUI.CardView.DefaultComparator(".label h4", null, false),
                   ".label .published": new CUI.CardView.DefaultComparator(".label .published", "data-timestamp", true)};
     new CUI.CardView({comparators: comparatorConfig})

     * @example
     <caption>Defining comparators via data API</caption>
     &lt;!-- Page header for list view --&gt;
     &lt;header class="card-page selectable movable"&gt;
     &lt;i class="select"&gt;&lt;/i&gt;
     &lt;i class="sort"&gt;&lt;/i&gt;
     &lt;div class="label"&gt;
     &lt;div class="main" data-sort-selector=".label h4"&gt;Title&lt;/div&gt;
     &lt;div class="published" data-sort-selector=".label .published .date" data-sort-attribute="data-timestamp" data-sort-type="numeric"&gt;Published&lt;/div&gt;
     &lt;div class="modified" data-sort-selector=".label .modified .date" data-sort-attribute="data-timestamp" data-sort-type="numeric"&gt;Modified&lt;/div&gt;
     &lt;div class="links" data-sort-selector=".label .links-number" data-sort-type="numeric"&gt;&lt;i class="icon-arrowright"&gt;Links&lt;/i&gt;&lt;/div&gt;
     &lt;/div&gt;
     &lt;/header&gt;
     &lt;!--
     Sorting is started when the user clicks on the corresponding column header.

     data-sort-selector   defines which part of the item to select for sorting
     data-sort-attribute  defines which attribute of the selected item element should be user for sorting. If not given, the inner text is used.
     data-sort-type       if set to "numeric", a numerical comparison is used for sorting, an alphabetical otherwise
     --&gt;

     * @example
     <caption>Switching to grid selection mode using API</caption>
     $cardView.cardView("toggleGridSelectionMode");
     *
     * @example
     <caption>Switching to grid selection mode using CSS contract</caption>
     $cardView.toggleClass("selection-mode");
     $cardView.find("article").removeClass("selected");
     *
     * @desc Creates a new card view.
     * @constructs
     *
     * @param {Object} [options] Component options
     * @param {Object} [options.selectorConfig]
     *        The selector configuration. You can also omit configuration values: Values not given will be used from
     *        the default selector configuration.
     * @param {String} options.selectorConfig.itemSelector
     *        The selector that is used to retrieve the cards from the DOM
     * @param {String} options.selectorConfig.headerSelector
     *        The selector that is used to retrieve the header(s) in list view from the
     *        DOM
     * @param {String} options.selectorConfig.dataContainer
     *        The class of the div that is used internally for laying out the cards
     * @param {Boolean} options.selectorConfig.enableImageMultiply
     *        Flag that determines if the images of cards should use the "multiply
     *        effect" for display in selected state
     * @param {Object} options.selectorConfig.view
     *        Configures the view of the CardView
     * @param {Object} options.selectorConfig.view.selectedItem
     *        Defines what classes on what elements are used to select a card
     * @param {Object} options.selectorConfig.view.selectedItem.list
     *        Defines the selection-related config in list view
     * @param {String} options.selectorConfig.view.selectedItem.list.cls
     *        Defines the CSS class that is used to select a card in list view
     * @param {String} [options.selectorConfig.view.selectedItem.list.selector]
     *        An additioonal selector if the selection class has to be set on a child
     *        element rather than the card's parent element
     * @param {Object} options.selectorConfig.view.selectedItem.grid
     *        Defines the selection-related config in grid view
     * @param {String} options.selectorConfig.view.selectedItem.grid.cls
     *        Defines the CSS class that is used to select a card in grid view
     * @param {String} [options.selectorConfig.view.selectedItem.grid.selector]
     *        An additioonal selector if the selection class has to be set on a child
     *        element rather than the card's parent element
     * @param {Object} options.selectorConfig.view.selectedItems
     *        Defines how to determine the currently selected cards
     * @param {Object} options.selectorConfig.view.selectedItems.list
     *        Defines how to determine the currently selected cards in list view
     * @param {String} options.selectorConfig.view.selectedItems.list.selector
     *        The selector that determines the DOM elements that represent all currently
     *        selected cards
     * @param {Function} [options.selectorConfig.view.selectedItems.list.resolver]
     *        A function that is used to calculate a card's parent element from the
     *        elements that are returned from the selector that is used for determining
     *        selected cards
     * @param {Object} options.selectorConfig.view.selectedItems.grid
     *        Defines how to determine the currently selected cards in grid view
     * @param {String} options.selectorConfig.view.selectedItems.grid.selector
     *        The selector that determines the DOM elements that represent all currently
     *        selected cards
     * @param {Function} [options.selectorConfig.view.selectedItems.grid.resolver]
     *        A function that is used to calculate a card's parent element from the
     *        elements that are returned from the selector that is used for determining
     *        selected cards
     * @param {Object} options.selectorConfig.controller
     *        Configures the controller of the CardView
     * @param {Object} options.selectorConfig.controller.selectElement
     *        The selector that defines the DOM element that is used for selecting
     *        a card (= targets for the respective click/tap handlers)
     * @param {String} options.selectorConfig.controller.selectElement.list
     *        The selector that defines the event targets for selecting a card in list
     *        view
     * @param {String} [options.selectorConfig.controller.selectElement.listNavElement]
     *        An additional selector that may be used to determine the element that is
     *        used for navigating in list view if it is different from the event target
     *        defined by options.selectorConfig.controller.selectElement.grid
     * @param {String} options.selectorConfig.controller.selectElement.grid
     *        The selector that defines the event targets for selecting a card in grid
     *        view
     * @param {Object} options.selectorConfig.controller.moveHandleElement
     *        The selector that defines the DOM elements that are used for moving
     *        cards in list view (= targets for the respective mouse/touch handlers)
     * @param {String} options.selectorConfig.controller.moveHandleElement.list
     *        The selector that defines the event targets for the handles that are used
     *        to move a card in list view
     * @param {Object} options.selectorConfig.controller.targetToItems
     *        Defines the mapping from event targets to cards
     * @param {Function|String} options.selectorConfig.controller.targetToItems.list
     *        A function that takes a jQuery object that represents the event target for
     *        selecting a card in list view and that has to return the jQuery object
     *        that represents the entire card; can optionally be a selector as well
     * @param {Function|String} options.selectorConfig.controller.targetToItems.grid
     *        A function that takes a jQuery object that represents the event target for
     *        selecting a card in grid view and that has to return the jQuery object t
     *        hat represents the entire card; can optionally be a selector as well
     * @param {Function|String} options.selectorConfig.controller.targetToItems.header
     *        A function that takes a jQuery object that represents the event target for
     *        the "select all" button of a header in list view and that has to return
     *        the jQuery object that represents the respective header; can optionally
     *        be a selector as well
     * @param {Object} options.selectorConfig.controller.gridSelect
     *        Defines the selection mode in grid view
     * @param {Object} options.selectorConfig.controller.gridSelect.cls
     *        Defines the class that is used to switch to selection mode in grid view
     * @param {Object} options.selectorConfig.controller.gridSelect.selector
     *        An additional selector that is used to define the child element where the
     *        selection mode class should be applied to/read from
     * @param {Object} options.selectorConfig.controller.selectAll
     *        Defines how to select all cards in list view
     * @param {Object} options.selectorConfig.controller.selectAll.selector
     *        The selector that is used to determine all "select all" buttons in a
     *        CardView
     * @param {Object} options.selectorConfig.controller.sort
     *        Defines selectors for the column sorting mechanism.
     * @param {Object} options.selectorConfig.controller.sort.columnSelector
     *        The selector for all column objects within the header
     * @param {Object} options.gridSettings
     *        Custom options for jQuery grid layout plugin.
     * @param {Object} options.selectorConfig.controller.selectAll.cls
     *        The class that has to be applied to each card if "select all" is invoked
     * @param {Object} [options.comparators]
     *        An associative array of comparators for column sorting: Every object attribute is a CSS selector
     *        defining one column and its value has to be of type CUI.CardView.DefaultComparator (or your own derived class)
     */
    construct: function (options) {
      // Mix given selector config with defaults: Use given config and add defaults, where no option is given
      var selectorConfig = Utils.mixObjects(options.selectorConfig, DEFAULT_SELECTOR_CONFIG);
      var comparators = options.comparators || null;

      this.adapter = new DirectMarkupAdapter(selectorConfig, comparators);
      this.adapter.initialize(this.$element);
      this.layout(options.gridSettings);
    },

    /*
     * Cleans up the component by removing any internal data and listeners. The component should be
     * used anymore after calling this method.
     *
     * @instance
     */
    destroy: function () {

      // removes every registered element
      this.$element.off();

      // removes the added components
      this.$element.removeData('cardView');
      if (this.$element.data('cuigridlayout')) {
        this.$element.data('cuigridlayout').destroy();
      }

      // removes the adapter reference
      this.adapter = null;

      // removes the element reference
      delete this.$element;
    },

    /**
     * Get the underlying data model.
     * @return {*} The underlying data model
     * @private
     */
    getModel: function () {
      return this.adapter.getModel();
    },

    /**
     * Set the underlying data model.
     * @param {*} model The underlying data model
     * @private
     */
    setModel: function (model) {
      this.adapter.setModel(model);
    },

    /**
     * Check if the specified item (part of the data model) is currently selected.
     * @param {*} item The item (data mode) to check
     * @return {Boolean} True if the specified item is selected
     * @private
     */
    isSelected: function (item) {
      return this.adapter.isSelected(item);
    },

    /**
     * Get the current display mode (grid or list view).
     * @return {String} The display mode; either {@link CUI.CardView.DISPLAY_GRID} or
     *         {@link CUI.CardView.DISPLAY_LIST}
     */
    getDisplayMode: function () {
      return this.adapter.getDisplayMode();
    },

    /**
     * @return {boolean} true if this widget is currently in list mode and has a column sorting on any header applied
     */
    isColumnSorted: function () {
      return this.adapter.isColumnSorted();
    },

    /**
     * @param {boolean} sortable     Set to true if this list should be sortable by click on column
     */
    setColumnSortable: function (sortable) {
      // TODO implement
    },

    /**
     * @return {boolean} True if this list is column sortable (does not say if it is currently sorted, use isColumnSorted() for this)
     */
    isColumnSortable: function () {
      // TODO implement
    },

    /**
     * Set the display mode (grid or list view).
     * @param {String} displayMode The display mode; either
     *        {@link CUI.CardView.DISPLAY_GRID} or {@link CUI.CardView.DISPLAY_LIST}
     */
    setDisplayMode: function (displayMode) {
      this.adapter.setDisplayMode(displayMode);
    },

    /**
     * Checks if selection mode is currently active in grid view.
     * @return {Boolean} True if selection mode is active
     */
    isGridSelectionMode: function () {
      return this.adapter.isGridSelectionMode();
    },

    /**
     * Set the selection mode in grid view.
     * @param {Boolean} isSelection True to switch grid selection mode on
     */
    setGridSelectionMode: function (isSelection) {
      this.adapter.setGridSelectionMode(isSelection);
    },

    /**
     * Toggle selection mode in grid view.
     */
    toggleGridSelectionMode: function () {
      this.setGridSelectionMode(!this.isGridSelectionMode());
    },

    getSelectionModeCount: function () {
      return this.adapter.getSelectionModeCount();
    },

    setSelectionModeCount: function (modeCount) {
      this.adapter.setSelectionModeCount(modeCount);
    },

    /**
     * <p>Select the specified item.</p>
     * <p>The second parameter should be used if multiple cards are selected/deselected
     * at once. It prevents some time consuming stuff from being executed more than
     * once.</p>
     * @param {jQuery|*} item The item to select; may either be from data model or a
     *        jQuery object
     * @param {Boolean} moreSelectionChanges True if there are more selection changes
     *        following directly
     */
    select: function (item, moreSelectionChanges) {
      // TODO implement beforeselect event
      item = ensureItem(item);
      var isSelected = this.adapter.isSelected(item);
      if (!isSelected) {
        if (this.getSelectionModeCount() === SELECTION_MODE_COUNT_SINGLE &&
          this.getSelection().length > 0) {
          this.clearSelection();
        }

        this.adapter.setSelected(item, true);
        this.$element.trigger($.Event("change:selection", {
          "widget": this,
          "item": item,
          "isSelected": true,
          "moreSelectionChanges": (moreSelectionChanges === true)
        }));
      }
    },

    /**
     * <p>Deselect the specified card.</p>
     * <p>The second parameter should be used if multiple cards are selected/deselected
     * at once. It prevents some time consuming stuff from being executed more than
     * once.</p>
     * @param {jQuery|*} item The item to deselect; may either be from data model or a
     *        jQuery object
     * @param {Boolean} moreSelectionChanges True if there are more selection changes
     *        following directly
     */
    deselect: function (item, moreSelectionChanges) {
      // TODO implement beforeselect event
      item = ensureItem(item);
      var isSelected = this.adapter.isSelected(item);
      if (isSelected) {
        this.adapter.setSelected(item, false);
        this.$element.trigger($.Event("change:selection", {
          "widget": this,
          "item": item,
          "isSelected": false,
          "moreSelectionChanges": moreSelectionChanges
        }));
      }
    },

    /**
     * <p>Toggle the selection state of the specified item.</p>
     * <p>The second parameter should be used if multiple cards are selected/deselected
     * at once. It prevents some time consuming stuff from being executed more than
     * once.</p>
     * @param {jQuery|*} item The item; may be either from data model or a jQuery object
     * @param {Boolean} moreSelectionChanges True if there are more selection changes
     *        following directly
     * @return {Boolean} True if the toggle requires the originating event (if any)
     *         to be stopped and to prevent browser's default behavior
     */
    toggleSelection: function (item, moreSelectionChanges) {
      item = ensureItem(item);

      // allow to cancel & stop the event
      var beforeEvent = $.Event("beforeselect", {

        selectionCancelled: false,

        stopEvent: false,

        item: item,

        cancelSelection: function (stopEvent) {
          this.selectionCancelled = true;
          this.stopEvent = (stopEvent === true);
        }
      });
      this.$element.trigger(beforeEvent);
      if (beforeEvent.selectionCancelled) {
        return beforeEvent.stopEvent;
      }

      var isSelected = this.isSelected(item);
      if (!isSelected &&
        (this.getSelectionModeCount() === SELECTION_MODE_COUNT_SINGLE) &&
        (this.getSelection().length > 0)) {
        this.clearSelection();
      }

      this.adapter.setSelected(item, !isSelected);
      this.$element.trigger($.Event("change:selection", {
        "widget": this,
        "item": item,
        "isSelected": !isSelected,
        "moreSelectionChanges": moreSelectionChanges
      }));
      return true;
    },

    /**
     * Gets the currently selected cards.
     * @param {Boolean} useModel True if items from the data model should be retured;
     *        false, if a jQuery object should be returned instead
     * @return {Array|jQuery} The selected items
     */
    getSelection: function (useModel) {
      return this.adapter.getSelection(useModel === true);
    },

    /**
     * Clears the current selection state by deselecting all selected cards.
     */
    clearSelection: function () {
      var selection = this.getSelection(true);
      var itemCnt = selection.length;
      var finalItem = (itemCnt - 1);
      for (var i = 0; i < itemCnt; i++) {
        this.deselect(selection[i], (i < finalItem));
      }
    },

    /**
     * @private
     */
    _headerSel: function (headers, selectFn, lastValidItemFn) {
      var model = this.adapter.getModel();
      if (headers == null) {
        headers = model.getHeaders();
      }
      if (!$.isArray(headers)) {
        headers = [ headers ];
      }
      var headerCnt = headers.length;
      for (var h = 0; h < headerCnt; h++) {
        var header = headers[h];
        if (header.jquery) {
          header = model.getHeaderForEl(header);
        }
        var itemsToSelect = model.getItemsForHeader(header);
        var itemCnt = itemsToSelect.length;
        for (var i = 0; i < itemCnt; i++) {
          selectFn.call(this,
            itemsToSelect[i], !lastValidItemFn(i, itemsToSelect));
        }
      }
    },

    /**
     * <p>Selects all cards.</p>
     * <p>If the headers parameter is specified, all items that are part of one
     * of the specified headers get selected. Items that are not assigned to one of the
     * specified headers are not changed.</p>
     * @param {Array} [headers] Header filter
     */
    selectAll: function (headers) {
      if (this.getSelectionModeCount() !== SELECTION_MODE_COUNT_MULTI) return;

      var self = this;
      this._headerSel(headers, this.select, function (i, items) {
        for (++i; i < items.length; i++) {
          if (!self.isSelected(items[i])) {
            return false;
          }
        }
        return true;
      });
    },

    /**
     * <p>Deselect all cards.</p>
     * <p>If the headers parameter is specified, all items that are part of one
     * of the specified headers get deselected. Items that are not assigned to one of
     * the specified headers are not changed.</p>
     * @param {Array} [headers] Header filter
     */
    deselectAll: function (headers) {
      var self = this;
      this._headerSel(headers, this.deselect, function (i, items) {
        for (++i; i < items.length; i++) {
          if (self.isSelected(items[i])) {
            return false;
          }
        }
        return true;
      });
    },

    /**
     * @private
     */
    getHeaderSelectionState: function () {
      var model = this.getModel();
      var curHeader = null;
      var state = {
        "selected": [ ],
        "hasUnselected": false,
        "headers": [ ]
      };
      var headerCnt = model.getHeaderCount();
      var itemCnt = model.getItemCount();
      for (var i = 0; i < itemCnt; i++) {
        var item = model.getItemAt(i);
        for (var h = 0; h < headerCnt; h++) {
          var header = model.getHeaderAt(h);
          if (header.getItemRef() === item) {
            curHeader = {
              "header": header,
              "selected": [ ],
              "hasUnselected": false
            };
            state.headers.push(curHeader);
            break;
          }
        }
        if (this.isSelected(item)) {
          if (curHeader !== null) {
            curHeader.selected.push(item);
          } else {
            state.selected.push(item);
          }
        } else {
          if (curHeader !== null) {
            curHeader.hasUnselected = true;
          } else {
            state.hasUnselected = true;
          }
        }
      }
      return state;
    },

    /**
     * Create and execute a layout of the cards if in grid view.
     */
    layout: function (settings) {
      if (this.getDisplayMode() !== DISPLAY_GRID) {
        return;
      }
      if (this.$element.data('cuigridlayout')) {
        this.$element.cuigridlayout("destroy");
      }
      this.$element.cuigridlayout(settings);
    },

    /**
     * Exexute a relayout of the cards if in grid view.
     */
    relayout: function () {
      if (this.getDisplayMode() !== DISPLAY_GRID) {
        return;
      }
      this.$element.cuigridlayout("layout");
    },

    /**
     * @protected
     */
    _restore: function (restoreHeaders) {
      this.adapter._restore(restoreHeaders);
    },

    /**
     * <p>Append the specified jQuery items as cards.</p>
     * <p>Note that if you are intending to add multiple cards at once, you should
     * either create a single jQuery object that matches the cards to append or an array
     * of jQuery objects, where each array element represents a single card.</p>
     * @param {jQuery|jQuery[]} $items The jQuery item(s) to append
     */
    append: function ($items) {
      this.adapter.getModel().insertItemAt($items, null, false);
    },

    /**
     * Prepend the specified jQuery items as cards.
     * @param {jQuery} $items The jQuery item(s) to prepend
     */
    prepend: function ($items) {
      this.adapter.getModel().insertItemAt($items, 0, false);
    },

    /**
     * Remove all cards from the view.
     */
    removeAllItems: function () {
      this.adapter.removeAllItems();
      if (this.getDisplayMode() === DISPLAY_GRID) {
        this.relayout();
      }
      this.$element.trigger($.Event("change:removeAll", {
        widget: this
      }));
    }

  });

  /** Comparator class for column sorting */
  CUI.CardView.DefaultComparator = new Class(/** @lends CUI.CardView.DefaultComparator# */{
    /**
     * This comparator can select any text or attribute of a given jQuery element and compares
     * it with a second item either numerical or alpahebtical
     *
     * @param {String}  selector   A CSS selector that matches the part of the item to be compared
     * @param {String}  attribute  The attribute of the item to be compared. If not given, the inner text of the item will be used for comparison.
     * @param {String}  type  "numeric" for numeric comparison, or "string" for alphabetical comparison
     */
    construct: function (selector, attribute, type, ignoreCase) {
      this.selector = selector;
      this.attribute = attribute;
      this.ignoreCase = ignoreCase;
      this.isNumeric = (type == "numeric");
      this.reverseMultiplier = 1;
    },
    /**
     * Changes the order of the sort algorithm
     * @param {boolean} True for reverse sorting, false for normal
     */
    setReverse: function (isReverse) {
      this.reverseMultiplier = (isReverse) ? -1 : 1;
    },
    /**
     * Compares two items according to the configuration
     * @return {integer} -1, 0, 1
     */
    compare: function (item1, item2) {
      var $item1 = item1.getItemEl();
      var $item2 = item2.getItemEl();
      var $e1 = (this.selector) ? $item1.find(this.selector) : $item1;
      var $e2 = (this.selector) ? $item2.find(this.selector) : $item2;
      var t1 = "";
      var t2 = "";
      if (!this.attribute) {
        t1 = (this.ignoreCase) ? $e1.text().toLowerCase() : $e1.text();
        t2 = (this.ignoreCase) ? $e2.text().toLowerCase() : $e2.text();
      } else if (this.attribute.substr(0, 5) == "data-") {
        t1 = $e1.data(this.attribute.substr(5));
        t2 = $e2.data(this.attribute.substr(5));
      } else {
        t1 = $e1.attr(this.attribute);
        t2 = $e2.attr(this.attribute);
      }

      if (this.isNumeric) {
        t1 = t1 * 1;
        t2 = t2 * 1;
        if (isNaN(t1)) t1 = 0;
        if (isNaN(t2)) t2 = 0;
      }

      if (t1 > t2) return 1 * this.reverseMultiplier;
      if (t1 < t2) return -1 * this.reverseMultiplier;
      return 0;
    },
    /**
     * Return the compare function for use in Array.sort()
     * @return {function} The compare function (bound to this object)
     */
    getCompareFn: function () {
      return this.compare.bind(this);
    }
  });


  /**
   * Display mode: grid view; value: "grid"
   * @type {String}
   */
  CUI.CardView.DISPLAY_GRID = DISPLAY_GRID;

  /**
   * Display mode: list view; value: "list"
   * @type {String}
   */
  CUI.CardView.DISPLAY_LIST = DISPLAY_LIST;

  /**
   * Single selection mode; value: "single"
   * @type {String}
   */
  CUI.CardView.SELECTION_MODE_COUNT_SINGLE = "single";

  /**
   * Multi selection mode; value: "multiple"
   * @type {String}
   */
  CUI.CardView.SELECTION_MODE_COUNT_MULTI = "multiple";

  /**
   * Utility method to get a {@link CUI.CardView} for the specified jQuery element.
   * @param {jQuery} $el The jQuery element to get the widget for
   * @return {CUI.CardView} The widget
   */
  CUI.CardView.get = function ($el) {
    var cardView = Utils.getWidget($el);
    if (!cardView) {
      cardView = Utils.getWidget($el.cardView());
    }
    return cardView;
  };

  CUI.Widget.registry.register("cardview", CUI.CardView);

  // Data API
  if (CUI.options.dataAPI) {
    $(function () {
      var cardViews = $('body').find('[data-toggle="cardview"]');
      for (var gl = 0; gl < cardViews.length; gl++) {
        var $cardView = $(cardViews[gl]);
        if (!$cardView.data("cardview")) {
          CUI.CardView.init($cardView);
        }
      }
    });
  }

  // additional JSdoc

  /**
   * Triggered when a new card has been inserted succesfully.
   * @name CUI.CardView#change:insertitem
   * @event
   * @param {Object} evt The event
   * @param {CUI.CardView} evt.widget The widget
   * @param {*} evt.item The inserted item (data model)
   */

  /**
   * Triggered when the grid selection mode changes.
   * @name CUI.CardView#change:gridSelect
   * @event
   * @param {Object} evt The event
   * @param {CUI.CardView} evt.widget The widget
   * @param {Boolean} evt.oldValue True if grid select mode was previously active
   * @param {Boolean} evt.value True if grid select mode is now active
   */

  /**
   * Triggered when the display mode (list/grid view) changes. Display modes are
   * defined by their respective String constants, see for example
   * {@link CUI.CardView.DISPLAY_GRID}.
   * @name CUI.CardView#change:displayMode
   * @event
   * @param {Object} evt The event
   * @param {CUI.CardView} evt.widget The widget
   * @param {String} evt.oldValue The old display mode
   * @param {String} evt.value The new display mode
   */

  /**
   * Triggered when the selection changes.
   * @name CUI.CardView#change:selection
   * @event
   * @param {Object} evt The event
   * @param {CUI.CardView} evt.widget The widget
   * @param {*} evt.item The card that is (de)selected (data model)
   * @param {Boolean} evt.isSelected True if the item is now selected
   * @param {Boolean} evt.moreSelectionChanges True if there are more selection changes
   *        following (multiple single selection changes can be treated as one big
   *        selection change)
   */

  /**
   * Triggered right before the selection changes if (and only if) the selection is
   * changed using {@link CUI.CardView#toggleSelection}. The selection change can be
   * vetoed by calling cancelSelection on the Event object.
   * @name CUI.CardView#beforeselect
   * @event
   * @param {Object} evt The event
   * @param {*} evt.item The card that is will get (de)selected (data model)
   * @param {Function} evt.changeSelection This function may be called to cancel the
   *        selection; if true is passed as an argument, the originating event (if
   *        applicable; for example if the selection change is triggered by a user
   *        interaction) is cancelled as well (no event propagation; no default browser
   *        behavior)
   */

  /**
   * Triggered after an item has been moved with drag&drop to a new place in the list by the user.
   * @name CUI.CardView#item-moved
   * @event
   * @param {Object} evt          The event
   * @param {Object} evt.oldPrev  The jQuery element that was previous to the item before dragging started, may be empty or a header
   * @param {Object} evt.oldNext  The jQuery element that was next to the item before dragging started, may be empty
   * @param {Object} evt.newPrev  The jQuery element that is now previous to the item, may be empty or a header
   * @param {Object} evt.newNext  The jQuery element that is now next to the item, may be empty
   * @param {boolean} evt.hasMoved  True if the item really moved or false if it has the some position after the drag action as before.
   */

  /**
   * Triggered right before a column sort action on the list is started (when the user clicks on a column). The client side
   * sorting can be vetoed by setting preventDefault() on the event object. The event target is set to the column header the user clicked on.
   * The sortstart event is always triggered, even if the column has no client side sort configuration.
   * @name CUI.CardView#sortstart
   * @event
   * @param {Object} evt The event
   */

  /**
   * Triggered right after a sorting action on the list has been finished (when the user has clicked on a column).
   * The event target is set to the column header the user clicked on. This event is always triggered, even if the column does not have
   * a client side sort configuration.
   * @name CUI.CardView#sortend
   * @event
   * @param {Object} evt The event
   */

  /**
   * Triggered when all cards are removed.
   * @name CUI.CardView#change:removeAll
   * @event
   * @param {Object} evt The event
   * @param {CUI.CardView} evt.widget The widget
   */

}(window.jQuery));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

window.CUI = window.CUI || { };
CUI.imageeditor = CUI.imageeditor || {};
CUI.imageeditor.actions = {};
CUI.imageeditor.plugins = {};
CUI.imageeditor.ui = {};

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.I18nProvider = new Class({

    toString: 'I18nProvider',

    construct : function (translations) {
      this.translations = $.extend({}, CUI.imageeditor.I18nProvider.DEFAULT_TRANSLATIONS, translations);
    },

    /**
     * Get localized string for given key.
     *
     * @param {String} localization key
     * @return {String} localized string or key, if key is unknown
     */
    get : function (key) {
      if (this.has(key)) {
        return this.translations[key];
      }

      return key;
    },

    /**
     * Test if key is known localization key
     *
     * @param {String} localization key
     * @return {Boolean}
     */
    has : function (key) {
      return this.translations.hasOwnProperty(key);
    }
  });

  /**
   * Default translations. Change or set to override translations for all future
   * instances.
   */
  CUI.imageeditor.I18nProvider.DEFAULT_TRANSLATIONS = {
    'control.toolbar.close'  : 'Cancel',
    'control.toolbar.finish' : 'Finish',

    'crop.aspect_ratios.free_hand' : 'Free Hand',
    'crop.aspect_ratios.2_to_3'    : '2 : 3',
    'crop.aspect_ratios.3_to_5'    : '3 : 5',
    'crop.aspect_ratios.16_to_9'   : '16 : 9',
    'crop.aspect_ratios.square'    : 'Square',

    'crop.toolbar.launch'          : 'Start Crop',
    'crop.toolbar.launchwithratio' : 'Start Crop',
    'crop.toolbar.identifier'      : 'Crop',
    'crop.toolbar.unlaunch'        : 'Cancel',
    'crop.toolbar.confirm'         : 'Confirm',

    'crop.template.removecrop'     : 'Remove Crop',

    'flip.toolbar.horizontal' : 'Flip Horizontally',
    'flip.toolbar.vertical'   : 'Flip Vertically',

    'fullscreen.toolbar.fullscreen'     : 'Enter Fullscreen',
    'fullscreen.toolbar.fullscreenexit' : 'Exit Fullscreen',

    'history.toolbar.undo' : 'Undo',
    'history.toolbar.redo' : 'Redo',

    'map.template.path'         : 'Path',
    'map.template.path_picker'  : 'Path Picker',
    'map.template.alt_text'     : 'Alt Text',
    'map.template.target'       : 'Target',
    'map.template.same_tab'     : 'Same Tab',
    'map.template.new_tab'      : 'New Tab',
    'map.template.parent_frame' : 'Parent Frame',
    'map.template.top_frame'    : 'Top Frame',
    'map.template.delete'       : 'Delete',
    'map.template.unlaunch'     : 'Cancel',
    'map.template.confirm'      : 'Confirm',

    'map.toolbar.launch'    : 'Launch Map',
    'map.toolbar.rectangle' : 'Add Rectangular Map',
    'map.toolbar.circle'    : 'Add Circular Map',
    'map.toolbar.polygon'   : 'Add Polygon Map',
    'map.toolbar.unlaunch'  : 'Cancel',
    'map.toolbar.confirm'   : 'Confirm',

    'rotate.toolbar.left'  : 'Rotate Left',
    'rotate.toolbar.right' : 'Rotate Right',

    'zoom.toolbar.reset100' : 'Reset Zoom',
    'zoom.toolbar.popupslider' : 'Open Zoom Slider'
  };

}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.OptionsUtils = {

    /**
     * Load options from data attributes (asynchronously in the 'options-path' case),
     * process them and start the image editor.
     * @param {CUI.ImageEditor} imageeditor The image editor
     * @param {jQuery} $editable The editable image
     * @return {Function} callback Options-processing callback
     */
    loadOptionsAndStartEditing: function (imageeditor, $editable, callback) {
      /**
       * Finalize processing of the image editor options and start
       * @param {Object} options The options to finish processing
       */
      function optionsLoaded(opts) {
        if (typeof callback === 'function') {
          opts = callback(opts);
        }

        imageeditor.start(opts);
      }

      // Options can either be supplied directly as a JSON object in a
      // data attribute or loaded from path

      var options = {},
          optionsObj  = $editable.data('options'),
          optionsPath = $editable.data('options-path');

      if ($.isPlainObject(optionsObj)) {
        optionsLoaded(optionsObj);
      }
      else if (optionsPath) {
        $.ajax({
          'url': optionsPath,
          'success': function (data) {
            options = data;
          },
          'complete': function () {
            optionsLoaded(options);
          }
        });
      }
      else {
        optionsLoaded(options);
      }
    }
  };
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var noop = function () {};

  CUI.imageeditor.TemplateProvider = new Class({

    toString: 'TemplateProvider',

    construct : function (templates) {
      this.templates = $.extend({}, CUI.imageeditor.Templates, templates);
    },

    /**
     * Get template function for given name.
     *
     * @param {String} template name
     * @return {Function} template function or
     *                    CUI.imageeditor.TemplateProvider.NOOP if name is
     *                    unknown
     */
    get : function (name) {
      if (this.has(name)) {
        return this.templates[name];
      }

      return noop;
    },

    /**
     * Test if name is a known template.
     *
     * @param {String} template name
     * @return {Boolean}
     */
    has : function (name) {
      return this.templates.hasOwnProperty(name);
    }
  });

  CUI.imageeditor.TemplateProvider.NOOP = noop;
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.Theme
   * The theme-specific constants for the image editor component.
   * @static
   * @singleton
   * @ignore
   */
  CUI.imageeditor.Theme = {

    /**
     * CSS class for elements
     * @ignore
     */
    IMAGEEDITOR_HIDDEN_CLASS: 'u-coral-hidden',

    /**
     * CSS class that is added to disabled toolbar items
     * @ignore
     */
    TOOLBARITEM_DISABLED_CLASS: 'is-disabled',

    /**
     * CSS class that is added to selected toolbar items
     * @ignore
     */
    TOOLBARITEM_SELECTED_CLASS: 'is-selected',

    /**
     * CSS class for toolbar buttons, that change the operation mode
     * @ignore
     */
    TOOLBARITEM_MODECHANGER_CLASS: 'modechanger'

  };

}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * Manages the form and its hidden fields that represent the image transformation
   * @class CUI.imageeditor.TransformResult
   * @static
   * @private
   */
  CUI.imageeditor.TransformResult = new Class({

    toString: 'TransformResult',

    /**
     * The object containing the transformation
     */
    result: null,

    /**
     * Array used to store previous result states
     *
     * @private
     */
    history: null,

    /**
     * Array used to store result states, that where rolled back using undo
     *
     * @private
     */
    future: null,

    construct: function () {
      this.result = {};
      this.history = [];
      this.future  = [];
    },

    /**
     * <p>Registers the specified field as a transformation field.</p>
     *
     * @param {String} name The transform field name
     * @return {Boolean} true on successful registration of transform field
     */
    registerTransformField: function (name) {
      if (this.result.hasOwnProperty(name)) {
        return false;
      }

      this.result[name] = null;

      return true;
    },

    /**
     * <p>Set the transformation value of a transform form field.</p>
     *
     * @param {String} name The transform field name
     * @param {Object} val The transform field value
     * @param {Boolean} storeHistory (default: true) Should this change be
     *                         stored in history
     * @return {Boolean} true on successful setting of field value
     */
    setTransformValue: function (name, val, storeHistory) {
      if (storeHistory !== false) {
        this.storeHistory();
      }

      if (this.result.hasOwnProperty(name)) {
        this.result[name] = val;
        return true;
      }
      else {
        return false;
      }
    },

    /**
     * <p>Set the transformation value of multiple transform form fields at
     * once. This creates only one history entry.<br/>Unknow object keys are
     * silently ignored.</p>
     *
     * @param {mixed} values If Object,   then key is field name, value is field
     *                                    value
     *                       If Object[], then the value of the transformation
     *                                    field is the field name and the rest
     *                                    object is value Also see result of
     *                                    toJSON for examples.
     * @param {Boolean} storeHistory (default: true) Should this change be
     *                                               stored in history
     */
    setTransformValues : function (values, storeHistory) {
      var i, name, value;

      if (storeHistory !== false) {
        this.storeHistory();
      }

      if ($.isPlainObject(values)) {
        for (name in values) {
          if (values.hasOwnProperty(name)) {
            this.setTransformValue(name, values[name], false);
          }
        }
      }
      else if ($.isArray(values)) {
        for (i = 0; i < values.length; i++) {
          value = $.extend({}, values[i]);
          name = value.transformation;
          delete value.transformation;

          if (!$.isEmptyObject(value)) {
            this.setTransformValue(name, value, false);
          }
        }
      }
    },

    /**
     * Undo last set operation
     * @return {Boolean} true if successful, false if no previous state
     *                   available
     */
    undo : function () {
      if (this.history.length) {
        this.storeHistory();
        this.future.push(this.history.pop());

        this.setTransformValues(this.history.pop(), false);

        return true;
      }
      return false;
    },

    /**
     * Redo last undo
     * @return {Boolean} true if successful, false if no previous state
     *                   available
     */
    redo : function () {
      if (this.future.length) {
        this.storeHistory();

        this.setTransformValues(this.future.pop(), false);

        return true;
      }
      return false;
    },

    /**
     * <p>Get the transformation value of a transform form field.</p>
     * @param {String} name The transform field name
     * @return {Object} transformation value of a transform form field, which
     *                  was previously set using setTransformValue.
     *                  undefined for unknown id
     */
    getTransformValue: function (name) {
      if (this.result.hasOwnProperty(name)) {
        return this.result[name];
      }
      else {
        return undefined;
      }
    },

    /**
     * Return object representation of transform result which can be used to
     * serialize using JSON.stringify()
     * @return {Object}
     */
    toJSON : function () {
      var json = [],
          name;

      for (name in this.result) {
        if (this.result.hasOwnProperty(name) &&
            $.isPlainObject(this.result[name]) &&
            !$.isEmptyObject(this.result[name])) {

          json.push($.extend(
            true,
            {transformation : name},
            this.result[name]
          ));
        }
      }

      return json;
    },

    /**
     * Store current state in history array
     *
     * @private
     */
    storeHistory: function () {
      this.history.push($.extend(true, {}, this.result));
    }
  });
}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2013 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.UIUtils = {

    getUIContainer: function ($editable) {
      $editable = $($editable);

      if ($editable.is('.imageeditor-container')) {
        return $editable;
      }

      return $editable.parents('.imageeditor-container').first();
    },

    getToolbars: function ($editableOrContainer, tbType) {
      var $container, $toolbars;

      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      $container = $editableOrContainer.hasClass('imageeditor-container') ?
          $editableOrContainer :
          CUI.imageeditor.UIUtils.getUIContainer($editableOrContainer);

      if (!$container || !$container.length) {
        return null;
      }

      $toolbars = $container.find('div[data-type="' + tbType + '"] > div.imageeditor-toolbar');

      if (!$toolbars || !$toolbars.length) {
        return null;
      }

      return $toolbars;
    },

    getToolbarContainer: function ($container, tbType) {
      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      var $tbCont = $container.find('.imageeditor-toolbars [data-type="' + tbType + '"]');

      if ($tbCont.length) {
        return $tbCont;
      }
      return $container.find('.imageeditor-toolbars');
    },

    getItem: function (ref, tbType, $container) {
      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      return $container.find('div[data-type="' + tbType + '"] ' +
          'button[data-action="' + ref + '"]');
    },

    /**
     * <p>Determines the 'clipping parent' of the specified DOM object.</p>
     * <p>The clipping parent is a DOM object that might clip the visible area of
     * the specified DOM object by specifying a suitable 'overflow' attribute.</p>
     * @param {jQuery} $dom The jQuery-wrapped DOM object
     * @return {jQuery} The clipping parent as a jQuery object; undefined if no
     *       clipping parent exists
     */
    getClippingParent: function ($dom) {
      var $clipParent, ovf, ovfX, ovfY,
          $body = $(document.body);

      while ($dom[0] !== $body[0]) {
        ovf = $dom.css('overflow');
        ovfX = $dom.css('overflowX');
        ovfY = $dom.css('overflowY');

        if ((ovfX !== 'visible') || (ovfY !== 'visible') || (ovf !== 'visible')) {
          $clipParent = $dom;
          break;
        }
        $dom = $dom.parent();
      }
      return $clipParent;
    },

    /**
     * Is the DOM element in an iFrame?
     * @param {HTMLElement} el The element to test
     * @return {HTMLElement} the parent iFrame document for the element, null if not in an iFrame
     * @private
     */
    elementInIframe: function (el) {
      var elementDocument = $(el).prop('ownerDocument'),
          theIframe = null;

      $('iframe').each(function () {
        if (this.contentDocument === elementDocument) {
          theIframe = this;
          return;
        }
      });

      return theIframe;
    },

    handleTapOrClick: function (el, handler, options) {
      options = options || {};
      var namespace = '';
      if (!options.timeout) {
        options.timeout = 300;
      }
      if (typeof options.clickIgnoredAfterTouchTimeout === 'undefined') {
        options.clickIgnoredAfterTouchTimeout = 5000; // this needs to take delays by animations into account
      }
      if (typeof options.preventIgnoredClickEventDefault === 'undefined') {
        options.preventIgnoredClickEventDefault = true;
      }
      if (typeof options.stopIgnoredClickEventImmediatePropagation === 'undefined') {
        options.stopIgnoredClickEventImmediatePropagation = true;
      }
      if (typeof options.preventTouchendDefault === 'undefined') {
        options.preventTouchendDefault = true; // avoids sending a click event later (might even go to other element)
      }
      if (typeof options.eventNamespace !== 'undefined' && options.eventNamespace) {
        if (options.eventNamespace.indexOf('.') !== 0) {
          namespace = '.' + options.eventNamespace;
        } else {
          namespace = options.eventNamespace;
        }
      }

      var statusObject = null;
      statusObject = {
        lastTouchstartTime: 0,
        lastTouchTime: 0,
        off: function() {
          el.off('click' + namespace, statusObject.clickHandler);
          el.off('touchend' + namespace, statusObject.touchendHandler);
          el.off('touchstart' + namespace, statusObject.touchstartHandler);
        }
      };

      statusObject.outerHandler = handler;
      statusObject.clickHandler = function (e) {
        var now = new Date().getTime();
        if (options.clickIgnoredAfterTouchTimeout > (now - statusObject.lastTouchTime)) {
          if (options.preventIgnoredClickEventDefault) {
            e.preventDefault();
          }
          if (options.stopIgnoredClickEventImmediatePropagation) {
            e.stopImmediatePropagation();
          }
          return; // this should have been handled as a touch event, if preventDefault wasn't called
        }
        statusObject.outerHandler.apply((e.currentTarget || {}), [e]);
      };
      statusObject.touchstartHandler = function (e) {
        var now = new Date().getTime();
        statusObject.lastTouchstartTime = now;
        statusObject.lastTouchTime = statusObject.lastTouchstartTime;
      };
      statusObject.touchendHandler = function (e) {
        var now = new Date().getTime();
        statusObject.lastTouchTime = now;
        if (options.timeout < (now - statusObject.lastTouchstartTime)) {
          return; // held on too long - no tap any more
        }
        if (options.preventTouchendDefault) {
          e.preventDefault();
        }

        statusObject.lastTouchstartTime = 0; // allow fast tapping
        statusObject.outerHandler.apply((e.currentTarget || {}), [e]);
      };

      el.on('click' + namespace, statusObject.clickHandler);
      el.on('touchstart' + namespace, statusObject.touchstartHandler);
      el.on('touchend' + namespace, statusObject.touchendHandler);
      return statusObject;
    },

    installPinchZooming : function (target, reservedNs, currentZoomGetter, zoomSetter) {
      this.togglePinchZooming(true, target, reservedNs, currentZoomGetter, zoomSetter);
    },

    togglePinchZooming : function (enable, target, reservedNs, currentZoomGetter, zoomSetter) {
      reservedNs = reservedNs || '.imageeditorzoom';
      var START = 'gesturestart' + reservedNs,
        CHANGE = 'gesturechange' + reservedNs,
        END = 'gestureend' + reservedNs,
        MIN_UPDATE_DELAY_MS = 100;

      target.off(reservedNs);
      if (enable) {
        target.on(START, function (evt) {
          var zoomFactorAtStart = currentZoomGetter(),
            lastUpdate = 0,
            openTimeout = null;

          evt.preventDefault();
          target.off(CHANGE);
          target.on(CHANGE, function (evt) {
            var scale = evt.originalEvent.scale,
              nextUpdate = 1;
            evt.preventDefault();

            if (openTimeout) {
              clearTimeout(openTimeout);
              nextUpdate = Math.max(1, MIN_UPDATE_DELAY_MS - (new Date().getTime() - lastUpdate));
            }

            openTimeout = setTimeout(function () {
                lastUpdate = new Date().getTime();
                zoomSetter(scale * zoomFactorAtStart, 'change');
                // reset timeout only after zooming finished
                openTimeout = null;
              },
              nextUpdate
            );
          });
          target.on(END, function (evt) {
            var scale = evt.originalEvent.scale;
            evt.preventDefault();

            if (openTimeout) {
              clearTimeout(openTimeout);
            }

            target.off(CHANGE);
            target.off(END);
            zoomSetter(scale * zoomFactorAtStart, 'end');
          });
        });
      }
    },

    removePinchZooming : function (target, reservedNs) {
      this.togglePinchZooming(false, target, reservedNs);
    },

    isHavingClassOrParentHavingClass: function (el, clazz) {
      if (el) {
        if (!el.hasClass) {
          el = $(el);
        }
        if (el.hasClass(clazz)) {
          return true;
        } else if (el.length) {
          return this.isHavingClassOrParentHavingClass(el.parent(), clazz);
        }
      }
      return false;
    },

    isHavingModalParent: function (el) {
      return this.isHavingClassOrParentHavingClass(el, 'coral-Modal');
    },

    /**
     * Gets page coordinates of event, also from emulated click events (Touch event coordinates returned if available).
     * @param {Object} e the event
     * @returns {{x: (Number), y: (Number)}} Page coordinates X and Y
     */
    getEventCoordinatesPageRelative : function (e) {
      if (e.originalEvent && e.originalEvent.touches) {
        return { x : e.originalEvent.touches[0].pageX, y : e.originalEvent.touches[0].pageY };
      } else {
        return { x : e.pageX, y : e.pageY };
      }
    }

  };
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.Utils = {

    defer: function (fn, ms, scope, args) {
      var callFn = fn;
      if (scope) {
        callFn = function () {
          if (args) {
            fn.apply(scope, args);
          } else {
            fn.call(scope);
          }
        };
      } else if (args) {
        callFn = function () {
          fn.apply(window, args);
        };
      }
      return window.setTimeout(callFn, ms);
    },

    onPluginCreated: function (plugin) {
      return plugin;
    },

    applyDefaults: function (obj, defaults) {
      var k, v;

      obj = obj || {};
      defaults = defaults || {};

      if (typeof(obj) === 'object') {
        for (k in defaults) {
          if (defaults.hasOwnProperty(k)) {
            v = defaults[k];
            if (v && (typeof(v) === 'object') && !CUI.imageeditor.Utils.isArray(v)) {
              obj[k] = this.applyDefaults(obj[k], v);
            } else if (typeof(obj[k]) === 'undefined') {
              obj[k] = v;
            }
          }
        }
      }
      return obj;
    },

    isArray: function (obj) {
      return $.isArray(obj);
    },

    isString: function (obj) {
      return $.isString(obj);
    },

    endsWith: function (str, toSearch) {
      if (typeof str === 'undefined' || str === null) {
        return false;
      }
      if (toSearch  === null || typeof toSearch === 'undefined') {
        return false;
      }

      if (str.length < toSearch.length) {
        return false;
      }
      return str.substring(str.length - toSearch.length) === toSearch;
    },

    apply: function (obj, config, defaults) {
      return $.extend(obj, config, defaults);
    },

    getPagePosition: function (dom) {
      var pos = $(dom).offset();
      return [ pos.left, pos.top ];
    },

    getWidth: function (dom) {
      return $(dom).width();
    },

    getHeight: function (dom) {
      return $(dom).height();
    },

    jsonDecode: function (str) {
      return $.parseJSON(str);
    }
  };
}(jQuery, this));

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function ($, window, undefined) {
  'use strict';

  var isDimension = function (valOrObject, attrName) {
    var toCheck = valOrObject;
    if (attrName) {
      if (typeof valOrObject === 'object') {
        toCheck = valOrObject[attrName];
      } else {
        return false;
      }
    }

    if (typeof toCheck === 'number' && toCheck > 0) {
      return true;
    }

    if (typeof toCheck === 'string') {
      var floatValue = parseFloat(toCheck);
      return !isNaN(floatValue) &&
        floatValue > 0 &&
        (
          ('' + floatValue) === toCheck ||
          CUI.imageeditor.Utils.endsWith(toCheck, 'px') // % not supported currently
        );
    }
    return false;

  };

  /**
   Different sizes and translations some of which are required to display image editor,
   others for understandability and testability.

   Different scale types:
   + natural: the image file dimensions as loaded
   + display: the image as scaled for display (by abiding to fixed or min/max limit options)
   + zoomed: the image as zoomed from its scaled dimensions

   @class
   @this {CUI.imageeditor.TranslationUtil}
   @constructor
   */
  CUI.imageeditor.TranslationUtil = function (options) {
    if (typeof options !== 'object') {
      throw new Error('Sizes need constructor parameter');
    }

    this.initRotation(options);

    this.flip = options.flip || {horizontal: false, vertical: false};

    this.naturalDimensionsBeforeRotation = {
      height: options.naturalHeight,
      width: options.naturalWidth
    };

    this.naturalDimensions = this.rotateDimsIfNecessary(this.naturalDimensionsBeforeRotation);

    if (options.cropOnOriginal && options.cropOnOriginal.width && options.cropOnOriginal.height) {
      this.cropOnOriginal = {
        top: options.cropOnOriginal.top || 0,
        left: options.cropOnOriginal.left || 0,
        height: options.cropOnOriginal.height,
        width: options.cropOnOriginal.width
      };
    } else {
      this.cropOnOriginal = {
        top: 0,
        left: 0,
        height: this.naturalDimensionsBeforeRotation.height,
        width: this.naturalDimensionsBeforeRotation.width
      };
    }

    this.croppedRotatedDim = this.rotateDimsIfNecessary(this.cropOnOriginal);

    this.determineScaledDimensions(options);
  };

  CUI.imageeditor.TranslationUtil.prototype.determineScaledDimensions = function (options) {
    var fixedSizes = false,
      widthScaleFactor = 1.0,
      heightScaleFactor = 1.0,
      zoomFactor = 1.0,
      previousWidthScaleFactor,
      previousHeightScaleFactor;

    // 10.13 check for fixed size (crop would need to be scaled to fit into them)
    fixedSizes = false;
    if (isDimension(options, 'fixedWidth') ||
      isDimension(options, 'fixedHeight')) {

      fixedSizes = true;
    }

    if (fixedSizes) {
      var fixedWidth = parseInt(options.fixedWidth, 10),
        fixedHeight = parseInt(options.fixedHeight, 10);

      // support one given fixed dimension, too:
      if (isNaN(fixedWidth)) {
        widthScaleFactor = heightScaleFactor = fixedHeight / this.croppedRotatedDim.height;
      } else if (isNaN(fixedHeight)) {
        widthScaleFactor = heightScaleFactor = fixedWidth / this.croppedRotatedDim.width;
      } else {
        widthScaleFactor = fixedWidth / this.croppedRotatedDim.width;
        heightScaleFactor = fixedHeight / this.croppedRotatedDim.height;
      }
    }

    // 10.16 check for min and max forced limits violated by crop - crop would need to be scaled to fit into them if necessary
    if (!fixedSizes) { // fixedSizes overrides min/max scaling

      var minDimensions = {width: -1, height: -1},
        maxDimensions = {width: -1, height: -1};

      if (isDimension(options, 'minWidth')) {
        minDimensions.width = parseInt(options.minWidth, 10);
      }
      if (isDimension(options, 'minHeight')) {
        minDimensions.height = parseInt(options.minHeight, 10);
      }

      if (isDimension(options, 'maxWidth')) {
        maxDimensions.width = parseInt(options.maxWidth, 10);
      }
      if (isDimension(options, 'maxHeight')) {
        maxDimensions.height = parseInt(options.maxHeight, 10);
      }

      var scaleToMinBy = null;
      if (minDimensions.width > 0) {
        if (minDimensions.height > 0) {
          // both given, need to determine which is dominating
          if (minDimensions.width / minDimensions.height < this.croppedRotatedDim.width / this.croppedRotatedDim.height) {
            // height dominates minimum
            scaleToMinBy = 'height';
          } else {
            scaleToMinBy = 'width';
          }
        } else {
          scaleToMinBy = 'width';
        }
      } else if (minDimensions.height > 0) {
        scaleToMinBy = 'height';
      }

      var scaleToMaxBy = null;
      if (maxDimensions.width > 0) {
        if (maxDimensions.height > 0) {
          // determine dominating dimension
          if (maxDimensions.width / maxDimensions.height < this.croppedRotatedDim.width / this.croppedRotatedDim.height) {
            // width dominates max
            scaleToMaxBy = 'width';
          } else {
            scaleToMaxBy = 'height';
          }
        } else {
          scaleToMaxBy = 'width';
        }
      } else if (maxDimensions.height > 0) {
        scaleToMaxBy = 'height';
      }

      if (scaleToMinBy) {
        if (scaleToMinBy === 'height') {
          if (minDimensions.height > this.croppedRotatedDim.height) {
            previousHeightScaleFactor = heightScaleFactor;
            heightScaleFactor = minDimensions.height / this.croppedRotatedDim.height;
            // scale with same aspect ratio:
            widthScaleFactor = heightScaleFactor / previousHeightScaleFactor * widthScaleFactor;
          }
        } else {
          if (minDimensions.width > this.croppedRotatedDim.width) {
            previousWidthScaleFactor = widthScaleFactor;
            widthScaleFactor = minDimensions.width / this.croppedRotatedDim.width;
            heightScaleFactor = widthScaleFactor / previousWidthScaleFactor * heightScaleFactor;
          }
        }
      }

      if (scaleToMaxBy) {
        if (scaleToMaxBy === 'height') {
          if (maxDimensions.height < this.croppedRotatedDim.height) {
            previousHeightScaleFactor = heightScaleFactor;
            heightScaleFactor = maxDimensions.height / this.croppedRotatedDim.height;
            widthScaleFactor = heightScaleFactor / previousHeightScaleFactor * widthScaleFactor;
          }
        } else {
          if (maxDimensions.width < this.croppedRotatedDim.width) {
            previousWidthScaleFactor = widthScaleFactor;
            widthScaleFactor = maxDimensions.width / this.croppedRotatedDim.width;
            heightScaleFactor = widthScaleFactor / previousWidthScaleFactor * heightScaleFactor;
          }
        }
      }
    }

    this.displayDimensions = {
      height: Math.round(this.croppedRotatedDim.height * heightScaleFactor),
      width: Math.round(this.croppedRotatedDim.width * widthScaleFactor)
    };

    this.fromNaturalToDisplayScaleFactors = {
      width: widthScaleFactor,
      height: heightScaleFactor
    };

    if (options.zoomFactor) {
      zoomFactor = options.zoomFactor;
    }
    this.zoomFactor = zoomFactor;

    this.zoomedDimensions = {
      height: Math.round(this.displayDimensions.height * zoomFactor),
      width: Math.round(this.displayDimensions.width * zoomFactor)
    };

    this.fromNaturalToZoomedScaleFactors = {
      width: widthScaleFactor * zoomFactor,
      height: heightScaleFactor * zoomFactor
    };

    this.fromDisplayToZoomedScaleFactors = {
      width: zoomFactor,
      height: zoomFactor
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.initRotation = function (options) {
    var rotation = null;
    if (options.rotation) {
      var rotationTest = parseInt(options.rotation, 10);
      if (!isNaN(rotationTest)) {
        rotation = rotationTest;
      }
    }

    options.rotation = rotation;

    this.rotatedByNinetyDegrees = false;
    this.rotation = 0;
    if (options.rotation) {
      this.rotation = options.rotation;

      var rotationRest = Math.abs(options.rotation % 180);
      if (rotationRest === 90) {
        this.rotatedByNinetyDegrees = true;
      }
    }
  };

  CUI.imageeditor.TranslationUtil.prototype.getDisplayDimensions = function () {
    return this.displayDimensions;
  };

  CUI.imageeditor.TranslationUtil.prototype.getNaturalDimensions = function () {
    return this.naturalDimensions;
  };

  CUI.imageeditor.TranslationUtil.prototype.getZoomedDimensions = function () {
    return this.zoomedDimensions;
  };

  CUI.imageeditor.TranslationUtil.prototype.getZoomedDimensionsBeforeRotation = function () {
    var scaleFactors = this.getFromNaturalToZoomedScaleFactors(true),
      dims = this.getNaturalDimensionsBeforeRotation();

    return {
      height: Math.round(dims.height * scaleFactors.height),
      width: Math.round(dims.width * scaleFactors.width)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getZoomedCropBeforeRotation = function () {
    var crop = this.getCropOnOriginal(),
      scaleFactors = this.getFromNaturalToZoomedScaleFactors(true);

    return {
      top: Math.round(crop.top * scaleFactors.height),
      left: Math.round(crop.left * scaleFactors.width),
      height: Math.round(crop.height * scaleFactors.height),
      width: Math.round(crop.width * scaleFactors.width)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getNaturalDimensionsBeforeRotation = function () {
    return this.naturalDimensionsBeforeRotation;
  };

  CUI.imageeditor.TranslationUtil.prototype.adaptScaleFactorsToUnrotatedImage = function (factors) {
    if (this.rotatedByNinetyDegrees) {
      return {
        width: factors.height,
        height: factors.width
      };
    }
    return factors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromNaturalToDisplayScaleFactors = function (unrotated) {
    if (unrotated) {
      return this.adaptScaleFactorsToUnrotatedImage(this.fromNaturalToDisplayScaleFactors);
    }
    return this.fromNaturalToDisplayScaleFactors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromDisplayToNaturalScaleFactors = function (unrotated) {
    var temp = this.getFromNaturalToDisplayScaleFactors(unrotated);
    return {
      width: 1/temp.width,
      height: 1/temp.height
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromNaturalToZoomedScaleFactors = function (unrotated) {
    if (unrotated) {
      return this.adaptScaleFactorsToUnrotatedImage(this.fromNaturalToZoomedScaleFactors);
    }
    return this.fromNaturalToZoomedScaleFactors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromZoomedToNaturalScaleFactors = function (unrotated) {
    var temp = this.getFromNaturalToZoomedScaleFactors(unrotated);
    return {
      width: 1/temp.width,
      height: 1/temp.height
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromDisplayToZoomedScaleFactors = function () {
    return this.fromDisplayToZoomedScaleFactors;
  };

  CUI.imageeditor.TranslationUtil.prototype.getFromZoomedToDisplayScaleFactors = function () {
    return {
      width: 1/this.zoomFactor,
      height: 1/this.zoomFactor
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.getCropOnOriginal = function () {
    return this.cropOnOriginal;
  };

  CUI.imageeditor.TranslationUtil.prototype.getCropOnDisplayBeforeRotation = function () {
    var onOrig = this.getCropOnOriginal();
    var scaleFactors = this.getFromNaturalToDisplayScaleFactors(true);
    var retval = {
      top: onOrig.top * scaleFactors.height,
      left: onOrig.left * scaleFactors.width,
      height: onOrig.height * scaleFactors.height,
      width: onOrig.width * scaleFactors.width
    };
    retval.right = retval.left + retval.width;
    retval.bottom = retval.top + retval.height;
    return retval;
  };

  CUI.imageeditor.TranslationUtil.prototype.getCompleteImageAfterScalingDimensions = function () {
    var naturalDims = this.getNaturalDimensions();
    var scaleFactors = this.getFromNaturalToDisplayScaleFactors();
    return {
      height: naturalDims.height * scaleFactors.height,
      width: naturalDims.width * scaleFactors.width
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateToDisplay = function (w, h, unrotated) {
    var factors = this.getFromNaturalToDisplayScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateWidthToDisplay = function (w, unrotated) {
    return Math.round(w * this.getFromNaturalToDisplayScaleFactors(unrotated).width);
  };

  CUI.imageeditor.TranslationUtil.prototype.translateHeightToDisplay = function (h, unrotated) {
    return Math.round(h * this.getFromNaturalToDisplayScaleFactors(unrotated).height);
  };

  CUI.imageeditor.TranslationUtil.prototype.translateToNatural = function (w, h, unrotated) {
    var factors = this.getFromDisplayToNaturalScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateNaturalToZoomed = function (w, h, unrotated) {
    var factors = this.getFromNaturalToZoomedScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translateZoomedToNatural = function (w, h, unrotated) {
    var factors = this.getFromZoomedToNaturalScaleFactors(unrotated);
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.applyScaleFactors = function (w, h, factors) {
    return {
      w: Math.round(factors.width * w),
      h: Math.round(factors.height * h)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translatePoints = function (points, toZoomedOrToNatural) {
    var result = [], i, point;

    for (i = 0; i < points.length; i++) {
      point = points[i];
      if (toZoomedOrToNatural === 'toZoomed') {
        point = this.translateNaturalToZoomed(point.w, point.h);
      } else {
        point = this.translateZoomedToNatural(point.w, point.h);
      }
      result.push(point);
    }

    return result;
  };

  CUI.imageeditor.TranslationUtil.prototype.zoomPoints = function (points, reverse) {
    var result = [], i, point, factors;

    if (reverse) {
      factors = this.getFromZoomedToDisplayScaleFactors();
    } else {
      factors = this.getFromDisplayToZoomedScaleFactors();
    }

    for (i = 0; i < points.length; i++) {
      point = points[i];
      point = this.applyScaleFactors(point.w, point.h, factors);
      result.push(point);
    }

    return result;
  };

  CUI.imageeditor.TranslationUtil.prototype.translateWidthToNatural = function (w, unrotated) {
    return Math.round(w * 1/this.getFromNaturalToDisplayScaleFactors(unrotated).width);
  };

  CUI.imageeditor.TranslationUtil.prototype.translateHeightToNatural = function (h, unrotated) {
    return Math.round(h * 1/this.getFromNaturalToDisplayScaleFactors(unrotated).height);
  };

  CUI.imageeditor.TranslationUtil.prototype.scaleCropToNatural = function (crop, unrotated) {

    return this.applyScaleFactorsToCrop(crop, this.getFromZoomedToNaturalScaleFactors(unrotated));
  };

  CUI.imageeditor.TranslationUtil.prototype.scaleCropToZoomed = function (crop, unrotated) {

    return this.applyScaleFactorsToCrop(crop, this.getFromNaturalToZoomedScaleFactors(unrotated));
  };

  CUI.imageeditor.TranslationUtil.prototype.applyScaleFactorsToCrop = function (crop, factors) {
    if (!crop) {
      return null;
    }

    return {
      top: Math.round(crop.top * factors.height),
      left: Math.round(crop.left * factors.width),
      height: Math.round(crop.height * factors.height),
      width: Math.round(crop.width * factors.width)
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.rotateDimsIfNecessary = function (dims) {
    if (!dims) {
      return null;
    }

    return {
      height: this.rotatedByNinetyDegrees ? dims.width : dims.height,
      width: this.rotatedByNinetyDegrees ? dims.height : dims.width
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.rotateCropBy90IfNecessary = function (crop) {
    if (!crop) {
      return null;
    }

    return {
      top: this.rotatedByNinetyDegrees ? crop.left : crop.top,
      left: this.rotatedByNinetyDegrees ? crop.top : crop.left,
      height: this.rotatedByNinetyDegrees ? crop.width : crop.height,
      width: this.rotatedByNinetyDegrees ? crop.height : crop.width
    };
  };

  CUI.imageeditor.TranslationUtil.prototype.translate = function (box, zoomedOrDisplayOrNatural, result) {
    var toggle, rotation = this.rotation, flip = this.flip,
      targetDims;

    zoomedOrDisplayOrNatural = zoomedOrDisplayOrNatural || 'zoomed';
    zoomedOrDisplayOrNatural = zoomedOrDisplayOrNatural.toLowerCase();
    if (zoomedOrDisplayOrNatural === 'display') {
      targetDims = this.getDisplayDimensionsBeforeRotation();
    } else if (zoomedOrDisplayOrNatural === 'natural') {
      targetDims = this.getNaturalDimensionsBeforeRotation();
    } else {
      targetDims = this.getZoomedDimensionsBeforeRotation();
    }

    result = result || $.extend({}, box);

    rotation = rotation % 360; // [-270, 270]
    rotation = rotation + 360; // [  90, 630]
    rotation = rotation % 360; // [  90, 270]

    // change coords to point to 'new' top left
    if (box.hasOwnProperty('top') && box.hasOwnProperty('left')) {
      if (rotation % 180 === 0) {
        toggle = rotation !== 0;

        if (flip.horizontal ^ toggle) {
          result.left = targetDims.width - box.width - box.left;
        }
        else {
          result.left = box.left;
        }
        if (flip.vertical ^ toggle) {
          result.top = targetDims.height - box.height - box.top;
        }
        else {
          result.top = box.top;
        }
      }
      else {
        toggle = rotation !== 90;

        if (flip.vertical ^ toggle) {
          result.left = box.top;
        }
        else {
          result.left = targetDims.height - box.height - box.top;
        }
        if (flip.horizontal ^ toggle) {
          result.top = targetDims.width - box.width - box.left;
        }
        else {
          result.top  = box.left;
        }
      }
    }

    // switch dimensions if necessary
    if (rotation % 180 !== 0) {
      result.width = box.height;
      result.height = box.width;
    }
    else {
      result.width = box.width;
      result.height = box.height;
    }

    return result;
  };

}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Action
   * @private
   * The Action should be implemented by all imageeditor actions that cannot be handled by the
   * browser's implementation itself.
   */
  CUI.imageeditor.actions.Action = new Class({

    toString: 'Action',

    config: {},

    construct: function (editor, pluginId) {
      this._init(editor, pluginId);
    },

    _init: function (editor, actionId) {
      this.editor = editor;
      this.actionId = actionId;
    },

    notifyPluginConfig: function (config) {
      this.config = config;
    },

    isAction: function (actionStr) {
      // this method must be overridden
      return false;
    },

    // This is dead code now, but cannot remove because public API
    isUndoable: function (actionStr) {
      // this method can be overridden by actions that are actually not undoable (for
      // example undo/redo actions themselves)
      return true;
    },

    // This is dead code now, but cannot remove because public API
    requiresInitializedComponent: function (actionStr) {
      // this method can be overridden by actions that do not require an initialized
      // imageeditor component, for example for configuration, setup, etc.
      return true;
    },

    execute: function (execDef) {
      // this method must be overridden
    },

    // todo use a single parameter
    queryState: function (selectionDef, cmd) {
      return false;
    },

    toCss : function (transformResult, element, translationUtil) {
      // sub class responsibility
      return {};
    },

    /**
     * @protected
     */
    getString : function (string) {
      return this.editor.i18n.get(this.actionId + '.' + string);
    },

    /**
     * @protected
     */
    getTemplateOptions : function () {
      var self = this;

      return {
        helpers: {
          i18n : function (string) {
            return self.getString('template.' + string);
          }
        }
      };
    }
  });
}(jQuery, this));

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.ActionRegistry
   * This class is used to manage actions used in image editing. Each action has a
   * respective identifier by which it can be executed
   * @private
   */
  CUI.imageeditor.actions.ActionRegistry = (function () {

    var actionRegistry = {};

    return {

      /**
       * Registers the specified class as an image editing action.
       * @param {String} action The action identifier
       * @param {Function} cls The action class (must extend
       *      {@link CUI.rte.actions.action})
       */
      register: function (action, cls) {
        actionRegistry[action] = cls;
      },

      /**
       * <p>Creates an associative array, containing instances of all currently
       * registered actions.</p>
       * @return {Object} Associative array of instantiated actions
       */
      createRegisteredActions: function (editor) {
        var action,
            registeredActions = {};

        for (action in actionRegistry) {
          if (actionRegistry.hasOwnProperty(action)) {
            registeredActions[action] = new actionRegistry[action](editor, action);
          }
        }

        return registeredActions;
      }

    };

  })();
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Crop
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Crop = new Class({

    toString: 'Crop',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (actionStr) {
      var actionStrLC = actionStr.toLowerCase();
      return (actionStrLC === 'croplaunch') ||
           (actionStrLC === 'croplaunchwithratio') ||
           (actionStrLC === 'cropunlaunch') ||
           (actionStrLC === 'cropconfirm') ||
           (actionStrLC === 'cropremovecrop');
    },

    execute: function (execDef) {
      switch (execDef.action.toLowerCase()) {
      case 'croplaunch':
        return this.launchCrop(execDef);
      case 'croplaunchwithratio':
        return this.launchCropWithRatio(execDef);
      case 'cropunlaunch':
        return this.unlaunchCrop(execDef);
      case 'cropconfirm':
        return this.confirmCrop(execDef);
      case 'cropremovecrop':
        return this.removeCrop(execDef);
      }
    },

    launchCropWithRatio : function (execDef) {
      if (this.popover && this.popover.get('visible')) {
        this.closeRatioPopover(execDef);
      }
      else {
        this.openRatioPopover(execDef);
      }
    },

    openRatioPopover : function (execDef) {
      var clickTarget, popover;

      if (!this.clickTarget) {
        clickTarget = $('<div>', {'class': 'imageeditor-clicktarget'});

        $('.imageeditor-controls').append(clickTarget);

        clickTarget.on('click', this, this.clickTargetClicked);

        this.clickTarget = clickTarget;
      }

      if (!this.popover) {
        popover = $('<div>', {'class' : 'imageeditor-popover imageeditor-toolbar-popover coral-Popover'}).
            html(this.editor.templates.get('crop-popover')({aspectRatios: execDef.value.getAspectRatios()}, this.getTemplateOptions()));

        $('.imageeditor-controls').append(popover);

        popover.trigger('cui-contentloaded');

        popover.on('click', $.proxy(this.ratioPopoverClicked, this, execDef.value));

        this.popover = new CUI.Popover({
          element: popover,
          pointFrom: 'bottom'
        });
      }

      this.clickTarget.show();
      this.popover
        .set('pointAt', execDef.ui.find('.coral-Icon--crop:visible').closest('.coral-Button'))
        .show();
    },

    closeRatioPopover : function (execDef) {
      if (this.popover) {
        this.popover.hide();
      }

      if (this.clickTarget) {
        this.clickTarget.hide();
      }
    },

    clickTargetClicked : function (e) {
      e.stopPropagation();
      setTimeout(function () {
          e.data.closeRatioPopover();
        },
        300
      );
    },

    ratioPopoverClicked : function (plugin, e) {
      this.closeRatioPopover();

      var ratioOrRemoveTrigger = $(e.target).val();

      if (ratioOrRemoveTrigger === 'removeCrop') {
        plugin.execute('removecrop');
      } else {
        plugin.execute('launch', ratioOrRemoveTrigger);
      }
    },

    launchCrop: function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
          canvas = this.getFullCanvasCrop(translationUtil),
          zoomedCanvas = null,
          selection = this.getCurrent(execDef.result, translationUtil),
          zoomedSelection = null;

      if (execDef.mode === 'fullscreen' &&
          !(selection.top    === canvas.top &&
            selection.left   === canvas.left &&
            selection.width  === canvas.width &&
            selection.height === canvas.height)
      ) {

        // Fullscreen and has seen previous selection. Open full image with
        // previous selection preselected
        //
        // canvas == full image dimensions
        // selection == previous selection, w/ aspect ratio applied
        //
        // Remove clip from element to make everything visible
        execDef.element.css('clip', '');
      }
      else {
        // Inline mode or Fullscreen without previous crop. Open crop with
        // computed preselection based on current crop
        //
        // canvas == previous selection or full image dimensions
        // selection == a bit smaller than canvas
        canvas = selection;
        selection = this.getDefaultSelection(execDef, canvas);
      }

      zoomedCanvas = translationUtil.scaleCropToZoomed(canvas, true);
      zoomedSelection = translationUtil.scaleCropToZoomed(selection, true);

      execDef.editor.togglePinchZooming(false);

      execDef.element.imageSelect({
        classPrefix: 'imageeditor-imageselect-',
        parent : execDef.ui.find('.imageeditor-controls'),

        applyTransformations : true,
        aspectRatio: execDef.value || 0,
        canvas : {
          top:    zoomedCanvas.top,
          left:   zoomedCanvas.left,
          width:  zoomedCanvas.width,
          height: zoomedCanvas.height
        },
        selection : {
          top:    zoomedSelection.top,
          left:   zoomedSelection.left,
          width:  zoomedSelection.width,
          height: zoomedSelection.height
        }
      });
    },

    unlaunchCrop: function (execDef) {
      execDef.element.imageSelect({call: 'destroy'});
      execDef.editor.togglePinchZooming(true);
      return true;
    },

    confirmCrop: function (execDef) {
      var api = execDef.element.imageSelect({instance: true}),
          selection = api.getSelection();

      this.setCurrent(execDef.result, execDef.createTranslationUtil().scaleCropToNatural(selection, true));

      return this.unlaunchCrop(execDef);
    },

    removeCrop: function (execDef) {

      this.setCurrent(execDef.result, null);
      return true;
    },

    toCss : function (result, element, translationUtil) {
      var selection = this.getCurrent(result),
          newCenter;

      if (selection) {
        selection = translationUtil.scaleCropToZoomed(selection, true);
        newCenter = this.findCenter(selection);

        return {
          'clip'         : 'rect(' + [
            selection.top,
            selection.left + selection.width,
            selection.top + selection.height,
            selection.left
          ].join('px, ') + 'px)',
          'transform-origin' : newCenter.x + 'px ' + newCenter.y + 'px'
        };
      }
    },

    /**
     * @private
     */
    findCenter : function (selection) {
      return {
        x: selection.left + Math.round(selection.width / 2),
        y: selection.top + Math.round(selection.height / 2)
      };
    },

    setCurrent : function (result, crop) {
      var value = null;

      if (crop) {
        value = {
          top: crop.top,
          left: crop.left,
          width: crop.width,
          height: crop.height
        };
      }
      result.setTransformValue('crop', value);
    },

    getCurrent : function (result, translationUtil) {
      var config = result && result.getTransformValue('crop');

      if ($.isPlainObject(config) &&
          config.hasOwnProperty('top') &&
          config.hasOwnProperty('left') &&
          config.hasOwnProperty('width') &&
          config.hasOwnProperty('height')) {

        return {
          top    : config.top,
          left   : config.left,
          width  : config.width,
          height : config.height
        };
      }
      else {
        return this.getFullCanvasCrop(translationUtil);
      }
    },

    getFullCanvasCrop: function(translationUtil) {
      var naturalDims;

      if (translationUtil) {
        naturalDims = translationUtil.getNaturalDimensionsBeforeRotation();
        return {
          top    : 0,
          left   : 0,
          width  : naturalDims.width,
          height : naturalDims.height
        };
      }
      else {
        return;
      }
    },

    /**
     * @private
     */
    getDefaultSelection : function (execDef, selection) {
      var margin,
        translationUtil = execDef.createTranslationUtil(),
        // Crop: crop is stored on original. It is displayed in the selection plugin which is itself translated by CSS.
        // So no need to translate crop here as CSS is doing it.
        // BUT: viewport is defined on the display - so need to reverse the translations done by CSS to get it on
        // original coordinates. If this is to be done correctly for all cases 2d matrix translation needs to be introduced (future?).
        viewportCropTranslated = translationUtil.rotateCropBy90IfNecessary(translationUtil.scaleCropToNatural(execDef.viewportCrop, false)),
        cropOnOriginal = translationUtil.getCropOnOriginal(),
        fullscreenMode = execDef.mode === 'fullscreen';

      margin = {
        x : viewportCropTranslated.width * 0.1,
        y : viewportCropTranslated.height * 0.1
      };

      return {
        top    : (fullscreenMode ? viewportCropTranslated.top : cropOnOriginal.top)  + margin.y,
        left   : (fullscreenMode ? viewportCropTranslated.left : cropOnOriginal.left) + margin.x,
        // margin left and right means dims shrink by 2 times its size
        width  : viewportCropTranslated.width  - 2 * margin.x,
        height : viewportCropTranslated.height - 2 * margin.y
      };
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('crop', CUI.imageeditor.actions.Crop);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Rotate
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Rotate = new Class({

    toString: 'Rotate',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (actionStr) {
      return (actionStr === 'rotateright') || (actionStr === 'rotateleft');
    },

    execute: function (execDef) {
      var angle = CUI.imageeditor.actions.Rotate.ROTATION_ANGLE,
          current = this.getCurrent(execDef.result);

      if (execDef.action === 'rotateleft') {
        angle = -angle;
      }

      angle = current + angle;

      this.setCurrent(execDef.result, angle);

      return true;
    },

    setCurrent : function (result, angle) {
      result.setTransformValue('rotate', {angle: angle});
    },

    getCurrent : function (result) {
      var config = result.getTransformValue('rotate');

      if ($.isPlainObject(config)) {
        return config.angle || 0;
      }
      return 0;
    },

    toCss : function (result, element, translationUtil) {
      return {
        transform : 'rotate(' + this.getCurrent(result) + 'deg)'
      };
    }
  });
}(jQuery, this));

/**
 * Default rotation angle (degrees)
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.imageeditor.actions.Rotate.ROTATION_ANGLE = 90;

// register action
CUI.imageeditor.actions.ActionRegistry.register('rotate', CUI.imageeditor.actions.Rotate);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Flip
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Flip = new Class({

    toString: 'Flip',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (action) {
      return (action === 'fliphorizontal') || (action === 'flipvertical');
    },

    execute: function (execDef) {
      var current = this.getCurrent(execDef.result),
          flipAxes = (execDef.rotation % 180) !== 0,
          axis;

      switch (execDef.action) {
      case 'fliphorizontal':
        axis = flipAxes ? 'vertical' : 'horizontal';
        break;
      case 'flipvertical':
        axis = flipAxes ? 'horizontal' : 'vertical';
        break;
      default:
        return false;
      }

      current[axis] = !current[axis];
      this.setCurrent(execDef.result, current);

      return true;
    },

    setCurrent : function (result, flip) {
      result.setTransformValue('flip', flip);
    },

    getCurrent : function (result) {
      var config = result.getTransformValue('flip');

      if ($.isPlainObject(config)) {
        return {
          vertical   : !!config.vertical,
          horizontal : !!config.horizontal
        };
      }
      else {
        return {
          vertical   : false,
          horizontal : false
        };
      }
    },

    toCss : function (result, element, translationUtil) {
      var current = this.getCurrent(result);

      return {
        transform: ' scaleX(' + (current.horizontal ? '-1' : '1') + ')' +
                   ' scaleY(' + (current.vertical ? '-1' : '1') + ')'
      };
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('flip', CUI.imageeditor.actions.Flip);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var serialize = function (data, form) {
    form.find('[name]').each(function () {
      var input = $(this),
          type = input.attr('type'),
          name = input.attr('name'),
          value = input.val();

      if (type === 'radio' || type === 'checkbox') {
        if (input.prop('checked')) {
          // Checkboxes work differently, if they represent multi-select. Most
          // commonly, the values would be stored in an Array.
          data[name] = value;
        }
      }
      else {
        data[name] = value;
      }
    });
  };

  var deserialize = function (data, form) {
    form.find('[name]').each(function () {
      var input = $(this),
          type = input.attr('type'),
          name = input.attr('name'),
          // Make sure, that input.attr('name') is not undefined - otherwise it
          // would not properly overwrite a previous value
          value = data[name] || '';

      if (type === 'radio' || type === 'checkbox') {
        // Checkbox and radio buttons
        //
        // Checkboxes work differently, if they represent multi-select. Most
        // commonly, the values would be stored in an Array.
        if (input.attr('value') === value) {
          input.prop('checked', true);
        }
        else {
          input.prop('checked', false);
        }
        input.change();
      }
      else {
        // Selects, text and other inputs
        input.val(value).change();

        if (input.is('select')) {
          // Inform CUI.Select about change event.
          // TODO Remove when CUI-1612 was resolved
          var select = input.closest('.coral-Select').data('select');
          if (select) {
            select._handleNativeSelect();
          }
        }
      }
    });
  };


  /**
   * @class CUI.imageeditor.actions.Map
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Map = new Class({

    toString: 'Map',

    extend: CUI.imageeditor.actions.Action,

    MIN_SIZE : 40,

    isAction: function (actionStr) {
      return (actionStr === 'maplaunch') ||
             (actionStr === 'mapunlaunch') ||
             (actionStr === 'mapconfirm') ||
             (actionStr === 'maprectangle') ||
             (actionStr === 'mapcircle') ||
             (actionStr === 'mappolygon');
    },

    execute: function (execDef) {
      switch (execDef.action) {
      case 'maplaunch':
        return this.launchMap(execDef);
      case 'mapunlaunch':
        return this.unlaunchMap(execDef);
      case 'mapconfirm':
        return this.confirmMap(execDef);

      case 'maprectangle':
        return this.startRectangleArea(execDef);
      case 'mapcircle':
        return this.startCircleArea(execDef);
      case 'mappolygon':
        return this.startPolygonArea(execDef);
      }
    },

    launchMap: function (execDef) {
      this.isActive = true;

      execDef.editor.togglePinchZooming(false);
      this.areas = this.getCurrent(execDef.result);
      this.drawAreas(execDef);

      execDef.ui.on('click.map deselect_click.map', $.proxy(this.tryToSelectAreaOrUnselect, this, execDef));
      execDef.ui.on('second_click.map', $.proxy(this.togglePopover, this, execDef));

      this.getMapCont(execDef.element).on('update.map', $.proxy(this.closePopover,  this));
    },

    unlaunchMap: function (execDef) {
      this.isActive = false;

      this.unselectCurrentArea(execDef);

      this.areas = [];
      this.drawAreas(execDef);

      execDef.ui.off('.map');
      this.getMapCont(execDef.element).off('.map');
      execDef.editor.togglePinchZooming(true);
    },

    confirmMap : function (execDef) {
      this.unselectCurrentArea(execDef);
      this.setCurrent(execDef.result, this.areas);

      this.unlaunchMap(execDef);
    },

    startRectangleArea : function (execDef) {
      this.unselectCurrentArea(execDef);

      this.currentArea = {
        alt: '',
        href: '',
        target : '',
        selection : this.getDefaultNewSelection(execDef),
        shape: 'rect'
      };

      this.selectCurrentArea(execDef);
    },

    startCircleArea : function (execDef) {
      this.unselectCurrentArea(execDef);

      this.currentArea = {
        alt: '',
        href: '',
        target : '',
        selection : this.getDefaultNewSelection(execDef),
        shape : 'circle'
      };

      this.selectCurrentArea(execDef);
    },

    startPolygonArea : function (execDef) {
      this.unselectCurrentArea(execDef);

      this.currentArea = {
        alt: '',
        href: '',
        target : '',
        points : this.getDefaultNewPoints(execDef),
        shape : 'polygon'
      };

      this.selectCurrentArea(execDef);
    },

    getDefaultNewSelection : function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
        viewportCropTranslated = translationUtil.scaleCropToNatural(execDef.viewportCrop, true),
        margin = {
          x: viewportCropTranslated.width * 0.2,
          y: viewportCropTranslated.height * 0.2
        };

      return {
        top: viewportCropTranslated.top + margin.y,
        left: viewportCropTranslated.left + margin.x,
        width: viewportCropTranslated.width - 2 * margin.x,
        height: viewportCropTranslated.height - 2 * margin.y
      };
    },

    getDefaultNewPoints : function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
        viewportCropTranslated = translationUtil.scaleCropToNatural(execDef.viewportCrop, true),
        margin = {
          x: viewportCropTranslated.width * 0.2,
          y: viewportCropTranslated.height * 0.2
        };

      return [
        {
          w: viewportCropTranslated.left + 0.5 * (viewportCropTranslated.width),
          h: viewportCropTranslated.top + margin.y
        },
        {
          w: viewportCropTranslated.left + (viewportCropTranslated.width - margin.x),
          h: viewportCropTranslated.top + (viewportCropTranslated.height - margin.y)
        },
        {
          w: viewportCropTranslated.left + margin.x,
          h: viewportCropTranslated.top + (viewportCropTranslated.height - margin.y)
        }
      ];
    },

    getCurrent : function (result) {
      var current = result.getTransformValue('map');

      if (current && current.areas) {
        return $.map(current.areas, function (a) { return $.extend(true, {}, a); });
      }
      else {
        return [];
      }
    },

    setCurrent : function (result, areas) {
      if (areas) {
        result.setTransformValue('map', {areas : areas});
      }
      else {
        // clear value
        result.setTransformValue('map', null);
      }
    },

    getMapCont : function (element) {
      return element.parent().find('.imageeditor-controls-map-areas');
    },

    drawAreas : function (execDef) {
      var translationUtil = execDef.createTranslationUtil(),
          cont = this.getMapCont(execDef.element),
          area, node, i, canvas = translationUtil.translate(translationUtil.getZoomedCropBeforeRotation(), 'zoomed'),
          selection, points, polygonTool, polygonStyling = this.getPolygonOutlineStyling(execDef);

      cont.html('');

      if (!this.areas) {
        return;
      }

      cont.css({
        width : canvas.width,
        height: canvas.height
      })
      .position({
        of: execDef.element,
        my: 'left top',
        at: 'left+' + canvas.left + ' top+' + canvas.top,
        collision: 'none'
      });



      for (i = 0; i < this.areas.length; i++) {
        area = this.areas[i];
        if (area.shape === 'polygon') {
          node = $('<canvas/>', {
            'class': 'imageeditor-map-canvas',
            'width': canvas.width,
            'height': canvas.height
          });
          node[0].width = canvas.width;
          node[0].height = canvas.height;
          points = area.points;
          points = translationUtil.translatePoints(points, 'toZoomed');
          polygonTool = node.polygon().data('polygon');
          polygonTool.paintPolygonWithPoints(node, points, polygonStyling);
          cont.append(node);

        } else {
          node = $('<div/>', {'class': 'imageeditor-controls-map-area'});
          cont.append(node);
          selection = translationUtil.scaleCropToZoomed(area.selection);

          node.css({
            top: selection.top,
            left: selection.left,
            width: selection.width,
            height: selection.height,
            borderRadius: area.shape === 'circle' ? '50%' : undefined
          });
        }

      }
    },

    /** get polygon style details via helper ghost */
    getPolygonOutlineStyling: function (execDef) {
      var $controls = $(this.getMapCont(execDef.element).parent()),
        $polygonHelper = $controls.find('.imageeditor-imagemap-polygon-helper'),
        borderWidthCss = $polygonHelper.css('border-top-width'), borderWidth = null;

      borderWidth = $('<div/>', {width: borderWidthCss}).width(); // conversion: .width() always returns pixel value

      return {
        strokeStyle: $polygonHelper.css('border-top-color'),
        lineWidth: borderWidth
      };
    },

    isCurrentlySelectedArea: function (candidateArea) {
      return this.currentImageSelect && this.currentArea === candidateArea;
    },

    tryToSelectAreaOrUnselect : function (execDef, e) {
      if (e && $(e.target).parents('.imageeditor-popover').length) {
        return;
      }
      if (e && $(e.target).parents('.imageeditor-imagemap-holder').length) {
        return;
      }

      var matches = false,
        translationUtil = execDef.createTranslationUtil(),
        polygonHelper = $('<div/>').polygon().data('polygon'),
        coords = CUI.imageeditor.UIUtils.getEventCoordinatesPageRelative(e),
        cont = this.getMapCont(execDef.element),
        contOffset = cont.offset(),
        contRelativeCoords = {
          w: coords.x - contOffset.left,
          h: coords.y - contOffset.top
        },
        candidateArea, i, translatedSelection, translatedPoints;

      // need to prevent propagation, event might target removed element, which will trigger closing of editor
      e.preventDefault();
      e.stopPropagation();

      for (i = 0; i < this.areas.length; i++) {
        candidateArea = this.areas[i];
        matches = false;

        if (candidateArea.shape === 'polygon') {
          translatedPoints = polygonHelper.pointsToVectors(translationUtil.translatePoints(candidateArea.points, 'toZoomed'));
          matches = polygonHelper.isPointInsideOrOnEdgeOfPolygon([contRelativeCoords.w, contRelativeCoords.h], translatedPoints);
        } else {
          translatedSelection = translationUtil.scaleCropToZoomed(candidateArea.selection);
          matches = polygonHelper.isCoordsInBoundingBox(translatedSelection, contRelativeCoords.w, contRelativeCoords.h);
        }

        if (matches) {
          if (!this.isCurrentlySelectedArea(candidateArea)) {
            this.createSelectionFromArea(i, execDef);
          }
          break;
        }
      }

      if (!matches) {
        // nothing here - no selection
        this.unselectCurrentArea(execDef);
      }

    },

    createSelectionFromArea : function (i, execDef) {
      var candidateArea = this.areas[i];

      this.unselectCurrentArea(execDef);

      this.currentArea = candidateArea;

      this.areas.splice(i, 1);
      this.drawAreas(execDef);

      this.selectCurrentArea(execDef);
    },

    selectCurrentArea : function (execDef) {
      // TODO: Provide proper elements/selectors instead of global ones

      var translationUtil = execDef.createTranslationUtil(),
        options;


      if (this.currentArea.shape === 'polygon') {
        options = {
          instance: true,
          classPrefix: 'imageeditor-imagemap-',
          parent: execDef.element.parent().find('.imageeditor-controls'),
          points: translationUtil.translatePoints(this.currentArea.points, 'toZoomed')
        };
        this.currentImageSelect = this.getMapCont(execDef.element).imageSelectPolygon(options);

      } else {
        options = {
          instance: true,
          classPrefix: 'imageeditor-imagemap-',
          parent: execDef.element.parent().find('.imageeditor-controls'),
          min: this.MIN_SIZE,
          selection: translationUtil.scaleCropToZoomed(this.currentArea.selection)
        };

        switch (this.currentArea.shape) {
        case 'rect':
          options.shape = 'rectangle';
          break;
        case 'circle':
          options.shape = 'ellipse';
          options.aspectRatio = 1;
          break;
        }

        this.currentImageSelect = this.getMapCont(execDef.element).imageSelect(options);
      }
    },

    unselectCurrentArea: function (execDef) {
      if (!this.currentImageSelect) {
        return;
      }

      if (this.currentArea.shape === 'polygon') {
        this.currentArea.points = execDef.createTranslationUtil().translatePoints(this.currentImageSelect.getPoints(), 'toNatural');
      } else {
        this.currentArea.selection = execDef.createTranslationUtil().scaleCropToNatural(this.currentImageSelect.getSelection());
      }

      this.areas.push(this.currentArea);

      this.removeCurrentSelection(execDef);
    },

    removeCurrentSelection : function (execDef) {
      if (!this.currentImageSelect) {
        return;
      }
      this.currentImageSelect.destroy();
      this.currentImageSelect = null;

      this.closePopover();
      this.drawAreas(execDef);
    },

    togglePopover : function (execDef) {
      if (!this.currentImageSelect) {
        return;
      }

      if (!this.currentPopover) {
        this.createPopover(execDef);
      }

      if (this.currentPopover.get('visible')) {
        this.closePopover();
      }
      else {
        this.openPopover(execDef);
      }
    },

    createPopover : function (execDef) {
      var popover, mapPopoverContext = {}, pathInputConfigured = false,
        config = $.extend({}, CUI.imageeditor.actions.Map.DEFAULT_OPTIONS, this.config);

      config.pathbrowser = $.extend({}, CUI.imageeditor.actions.Map.DEFAULT_OPTIONS.pathbrowser, config.pathbrowser);

      if (config.pathbrowser.type) {
        if (config.pathbrowser.type === 'picker') {
          mapPopoverContext.pathbrowserPicker = true;
          pathInputConfigured = true;
        } else if (config.pathbrowser.type === 'autocomplete') {
          mapPopoverContext.pathbrowserAutocomplete = true;
          pathInputConfigured = true;
        }
      }
      if (!pathInputConfigured) {
        mapPopoverContext.noPathbrowser = true;
      } else {
        mapPopoverContext.pathbrowser = $.extend({}, config.pathbrowser);
      }

      popover = $('<div>', {'class' : 'imageeditor-popover'}).html(this.editor.templates.get('map-popover')(mapPopoverContext, this.getTemplateOptions()));

      $('.imageeditor-controls').append(popover);

      var $pathbrowserEl = $($(popover).find('.pathbrowser'));
      if ($pathbrowserEl.length) {
        $pathbrowserEl.pathBrowser(mapPopoverContext.pathbrowser);
      }

      popover.trigger('cui-contentloaded');

      this.currentPopover = new CUI.Popover({
        element: popover,
        pointFrom: 'top',
        preventAutoHide: true // to stay open when pathbrowser modal is clicked
      });
    },

    updateAndGetBoundingBoxDiv: function (execDef) {
      var boundingBox = this.currentImageSelect.getBoundingBox(),
        cont = this.getMapCont(execDef.element),
        BOUNDING_BOX_CLASS = 'imageeditor-map-polygon-bounding-box',
        boundingBoxDiv;

      boundingBoxDiv = cont.find('.' + BOUNDING_BOX_CLASS);
      if (!boundingBoxDiv.length) {
        boundingBoxDiv = $('<div/>', {
          'class': BOUNDING_BOX_CLASS
        });
        boundingBoxDiv.css({
          //display: 'none',
          position: 'absolute'
        });
        cont.append(boundingBoxDiv);
      }

      boundingBoxDiv.css({
        top: boundingBox.top,
        left: boundingBox.left,
        width: boundingBox.width,
        height: boundingBox.height
      });
      return boundingBoxDiv;
    },

    openPopover : function (execDef) {
      var pointAtTarget;
      if (!this.currentPopover || !this.currentImageSelect) {
        return;
      }

      if (this.currentArea.shape === 'polygon') {
        pointAtTarget = this.updateAndGetBoundingBoxDiv(execDef);
      } else {
        pointAtTarget = this.currentImageSelect.$selection;
      }
      this.currentPopover.
        set('pointAt', pointAtTarget).
        show();

      var toolbar = this.currentPopover.get('element'),
          area = this.currentArea;

      deserialize(area, toolbar);

      toolbar.
        on('click.map', '.imageeditor-map-delete',      $.proxy(this.removeCurrentSelection, this, execDef)).
        on('click.map', '.imageeditor-map-unlaunch',    $.proxy(this.metaDataAbort, this)).
        on('click.map', '.imageeditor-map-confirm',     $.proxy(this.metaDataConfirm, this));

    },

    closePopover : function () {
      if (!this.currentPopover) {
        return;
      }

      this.currentPopover.get('element').
        off('.map').
        find(':focus').blur();

      this.closeSelect();
      this.currentPopover.hide();
    },

    metaDataConfirm : function (e) {
      if (!this.currentPopover || !this.currentArea) {
        return;
      }

      var area = this.currentArea,
          toolbar = this.currentPopover.get('element');

      serialize(area, toolbar);

      this.closePopover();
    },

    metaDataAbort : function (e) {
      this.closePopover();
    },

    closeSelect : function () {
      var $selectList = this.currentPopover.get('element').find('.coral-SelectList');
      if ($selectList.length) {
        $selectList.data('selectList').hide();
      }
    },

    reposition : function (element) {
      // reposition inactive areas
      this.getMapCont(element).position({of: element, my: 'left top', at: 'left top', collision: 'none'});

      // reposition popover
      if (this.currentPopover && this.currentPopover.get('visible')) {
        this.currentPopover.hide().show();
      }
    },

    toCss : function (result, element, translationUtil) {
      if (this.isActive) {
        this.reposition(element);
      }
    }
  });

  CUI.imageeditor.actions.Map.DEFAULT_OPTIONS = {
    pathbrowser: {
      type: null, // 'autocomplete' or 'picker'

      /* options for autocomplete and picker: */
      rootPath: '/',
      showTitles: false,
      optionLoader: function (path) {
        return [];
      },

      /* autocomplete configuration: */
      optionLoaderRoot: null, // provide property path to array in return value of optionLoader, e.g. 'results.values',
      optionValueReader: function (object) {
        return '' + object;
      },
      optionTitleReader: function (object) {
        return '' + object;
      },

      /* picker configuration: */
      pickerSrc: '/libs/wcm/core/content/common/pathbrowser/column.html' + '/' + '?predicate=hierarchyNotFile',
      pickerTitle: 'Choose a target path',
      picketCrumbRoot: {
        title: 'Root',
        icon: 'coral-Icon-home'
      }
    }
  };

}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('map', CUI.imageeditor.actions.Map);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.History
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.History = new Class({

    toString: 'History',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (action) {
      return (action === 'undo') || (action === 'redo');
    },

    execute: function (execDef) {
      switch (execDef.action) {
      case 'undo':
        execDef.result.undo();
        break;
      case 'redo':
        execDef.result.redo();
        break;
      }
      return true;
    },

    toCss : function (result, element, translationUtil) {
      return;
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('history', CUI.imageeditor.actions.History);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.actions.Fullscreen
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Fullscreen = new Class({

    toString: 'Fullscreen',

    extend: CUI.imageeditor.actions.Action,

    isAction: function (action) {
      return (action === 'fullscreen') || (action === 'fullscreenexit');
    },

    execute: function (execDef) {
      return true;
    },

    toCss : function (result, element, translationUtil) {
      return;
    }
  });
}(jQuery, this));

// register action
CUI.imageeditor.actions.ActionRegistry.register('fullscreen', CUI.imageeditor.actions.Fullscreen);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var ZOOM_NAME = 'Zoom',
    ZOOM_ID = 'zoom',
    POPUP_SLIDER_ACTION = ZOOM_ID + 'popupslider',
    RESET_100_ACTION = ZOOM_ID + 'reset100';

  /**
   * @class CUI.imageeditor.actions.Zoom
   * @extends CUI.imageeditor.actions.Action
   * @private
   */
  CUI.imageeditor.actions.Zoom = new Class({

    toString: ZOOM_NAME,

    extend: CUI.imageeditor.actions.Action,

    isAction: function (actionStr) {
      var actionStrLC = actionStr.toLowerCase();
      return (actionStrLC === POPUP_SLIDER_ACTION) ||
           (actionStrLC === RESET_100_ACTION);
    },

    execute: function (execDef) {
      switch (execDef.action.toLowerCase()) {
      case POPUP_SLIDER_ACTION:
        return this.popupSlider(execDef);
      case RESET_100_ACTION:
        return this.reset100(execDef);
      }
    },

    popupSlider : function (execDef) {
      if (this.popover && this.popover.get('visible')) {
        this.closeSliderPopover(execDef);
      }
      else {
        this.openSliderPopover(execDef);
      }
    },

    openSliderPopover : function (execDef) {
      var clickTarget, popover;

      if (!this.clickTarget) {
        clickTarget = $('<div>', {'class': 'imageeditor-clicktarget'});

        $('.imageeditor-controls').append(clickTarget);

        clickTarget.on('click', this, this.clickTargetClicked);

        this.clickTarget = clickTarget;
      }

      if (!this.popover) {
        popover = $('<div>', {'class' : 'imageeditor-popover imageeditor-toolbar-popover coral-Popover'}).
            html(this.editor.templates.get('zoomslider-popover')(this.getZoomLimits(execDef)));

        $('.imageeditor-controls').append(popover);

        popover.trigger('cui-contentloaded');

        this.popover = new CUI.Popover({
          element: popover,
          pointFrom: 'bottom'
        });
        this.getSlider().on('change', $.proxy(this.sliderChanged, this, execDef.value));
      }

      this.clickTarget.show();

      this.getSlider().setValue(Math.round(execDef.editor.getZoomFactor() * 100));

      this.popover
        .set('pointAt', execDef.ui.find('.coral-Icon--search:visible').closest('.coral-Button'))
        .show();
    },

    getZoomLimits : function (execDef) {
      var limitsFloat = execDef.editor.getZoomLimits();
      return {
        zoomMin: Math.round(limitsFloat[0] * 100),
        zoomMax: Math.round(limitsFloat[1] * 100)
      };
    },

    getSlider : function () {
      return $(this.popover.$element.find('div.coral-Slider')).data('slider');
    },

    closeSliderPopover : function (execDef) {
      if (this.popover) {
        this.popover.hide();
      }

      if (this.clickTarget) {
        this.clickTarget.hide();
      }
    },

    clickTargetClicked : function (e) {
      e.stopPropagation();
      setTimeout(function () {
          e.data.closeSliderPopover();
        },
        300
      );
    },

    reset100 : function (execDef) {
      execDef.editor.zoom(1);
    },

    sliderChanged : function (plugin, e) {
      var sliderVal = $(e.target).val();
      plugin.editor.zoom(sliderVal * 0.01);
    },

    toCss : function (result, element, translationUtil) {
    }
  });

  // register action
  CUI.imageeditor.actions.ActionRegistry.register(ZOOM_ID, CUI.imageeditor.actions.Zoom);

}(jQuery, this));


/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Plugin
   * <p>This class works as an interface and hence must be extended by all plugin
   * implementations.</p>
   * <p>Each plugin may provide one or more 'features', that represent the actual editing
   * action and usually map 1:1 to a UI element (for example, a toolbar button).</p>
   * <p>Plugins should not be instantiated directly, but registered with
   * {@link CUI.imageeditor.plugins.PluginRegistry} for implicit instantiation.</p>
   * @constructor
   * Creates a new Plugin.
   */
  CUI.imageeditor.plugins.Plugin = new Class({

    /**
     * @return {String[]} features that are present within the plugin
     * @protected
     */
    features: null,

    /**
     * @property {String} pluginId
     * The plugin ID
     */
    pluginId: null,

    /**
     * Back reference to the image editor the plugin is used from
     * @type CUI.ImageEditor
     * @private
     */
    editor: null,

    config: null,

    construct: function (editor, pluginId) {
      this._init(editor, pluginId);
    },

    _init: function (editor, pluginId) {
      this.editor = editor;
      this.pluginId = pluginId;
    },

    notifyPluginConfig: function (config) {
      this.config = config;
    },

    getFeatures: function () {
      return this.features;
    },

    isFeatureEnabled: function (feature) {

      if ($.inArray(feature, this.getFeatures()) === -1) {
        // Feature not present in plugin's features list - therefore not available
        return false;
      }

      if (!this.config || !this.config.features) {
        // Features not configured - default => enabled
        return true;
      }

      if ($.isArray(this.config.features)) {
        // Features configured explicitly - enabled if in array
        return $.inArray(feature, this.config.features) !== -1;
      }

      if (this.config.features === '*') {
        // Wild card - all features are enabled
        return true;
      }

      if (this.config.features === '-') {
        // Dash - All features are disabled
        return false;
      }

      // Features misconfigured - default => enabled
      return true;
    },

    initializeUI: function (toolbarBuilder) {
      // must be overridden by implementing plugins to add items to toolbar
    },

    execute: function (pluginAction, value, envOptions) {
      // must be overridden by implementing plugins to handle toolbar interactions
    },

    registerTransformFields: function (transformResult) {
      // may be overridden by implementing plugins if they need to register hidden
      // transform fields to store manipulation values
      return null;
    },

    /**
     * @protected
     */
    getString : function (string) {
      return this.editor.i18n.get(this.pluginId + '.' + string);
    },

    /**
     * @protected
     */
    getTooltip: function (action) {
      return this.getString('toolbar.' + action);
    }
  });
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.rte.plugins.PluginRegistry
   * This class is used to manage plugins available for rich text editing. Each plugin has a
   * respective identifier by which it can be referenced.
   * @private
   * @since 5.3
   */
  CUI.imageeditor.plugins.PluginRegistry = (function () {

    var pluginRegistry = { };

    return {

      /**
       * Registers the specified class as an image editing plugin.
       * @param {String} pluginId The plugin ID
       * @param {Function} cls The plugin class (must implement
       *      {@link CUI.rte.plugins.Plugin})
       */
      register: function (pluginId, cls) {
        pluginRegistry[pluginId] = cls;
      },

      /**
       * <p>Creates an associative array, containing instances of all currently registered
       * plugins.</p>
       * @return {Object} Instantiated plugins
       */
      createRegisteredPlugins: function (editor) {
        var registeredPlugins = {},
            pluginId, plugin;

        for (pluginId in pluginRegistry) {
          if (pluginRegistry.hasOwnProperty(pluginId)) {
            plugin = new pluginRegistry[pluginId](editor, pluginId);
            plugin = CUI.imageeditor.Utils.onPluginCreated(plugin);
            registeredPlugins[pluginId] = plugin;
          }
        }
        return registeredPlugins;
      }
    };
  })();
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Rotate
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image rotation as a plugin.</p>
   * <p>The plugin ID is '<b>rotate</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>rotate left</b> - adds a button to rotate image left</li>
   *   <li><b>rotate right</b> - adds a button to rotate image right</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Crop = new Class({

    toString: 'Crop',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['launch', 'launchwithratio', 'unlaunch', 'confirm'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('launch')) {
        item = toolbarBuilder.createItem('launch', this.getTooltip('launch'), this);
        toolbarBuilder.registerItem(item, 'crop');
      }

      if (this.isFeatureEnabled('launchwithratio')) {
        item = toolbarBuilder.createItem('launchwithratio', this.getTooltip('launchwithratio'), this);
        toolbarBuilder.registerItem(item, 'crop');
      }

      item = toolbarBuilder.createItem('identifier', this.getTooltip('identifier'), this);
      toolbarBuilder.registerItem(item, 'crop', CUI.imageeditor.Theme.TOOLBARITEM_SELECTED_CLASS);

      if (this.isFeatureEnabled('unlaunch')) {
        item = toolbarBuilder.createItem('unlaunch', this.getTooltip('unlaunch'), this);
        toolbarBuilder.registerItem(item, 'close');
      }

      if (this.isFeatureEnabled('confirm')) {
        item = toolbarBuilder.createItem('confirm', this.getTooltip('confirm'), this);
        toolbarBuilder.registerItem(item, 'check');
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'launch') {
        $.each(this.editor.toolbars, function (index, value) {
          value.switchToolbar(CUI.imageeditor.plugins.Crop.TOOLBAR_ID);
        });

        this.editor.relayAction('croplaunch', value);
      }
      if (pluginCommand === 'launchwithratio') {
        this.editor.relayAction('croplaunchwithratio', this);
      }
      if (pluginCommand === 'unlaunch') {
        $.each(this.editor.toolbars, function (index, value) {
          this.switchToPrimaryToolbar();
        });

        this.editor.relayAction('cropunlaunch', value);
      }
      if (pluginCommand === 'confirm') {
        $.each(this.editor.toolbars, function (index, value) {
          this.switchToPrimaryToolbar();
        });

        this.editor.relayAction('cropconfirm', value);
      }
      if (pluginCommand === 'removecrop') {

        this.editor.relayAction('cropremovecrop', value);
      }
    },

    getAspectRatios : function () {
      if ($.isPlainObject(this.config) && $.isArray(this.config.aspectRatios)) {
        // Use config, if available
        return this.config.aspectRatios;
      }

      // Else use default
      var self = this,
          ratios = CUI.imageeditor.plugins.Crop.ASPECT_RATIOS;

      return $.map(ratios, function (e) {
        return {
          ratio : e.ratio,
          name  : self.getString('aspect_ratios.' + e.name)
        };
      });
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('crop');
    }
  });
}(jQuery, this));

/**
 * Id of crop replacement toolbar
 * @static
 * @final
 * @type String
 * @private
 */
CUI.imageeditor.plugins.Crop.TOOLBAR_ID = 'crop';

CUI.imageeditor.plugins.Crop.ASPECT_RATIOS = [
  {name: 'free_hand', ratio: 0},
  {name: '2_to_3', ratio: 0.67},
  {name: '3_to_5', ratio: 0.6},
  {name: '16_to_9', ratio: 0.5625},
  {name: 'square', ratio: 1}
];

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('crop', CUI.imageeditor.plugins.Crop);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Rotate
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image rotation as a plugin.</p>
   * <p>The plugin ID is '<b>rotate</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>rotate left</b> - adds a button to rotate image left</li>
   *   <li><b>rotate right</b> - adds a button to rotate image right</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Rotate = new Class({

    toString: 'Rotate',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['left', 'right'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('left')) {
        item = toolbarBuilder.createItem('left', this.getTooltip('left'), this);
        toolbarBuilder.registerItem(item, 'rotateLeft');
      }
      if (this.isFeatureEnabled('right')) {
        item = toolbarBuilder.createItem('right', this.getTooltip('right'), this);
        toolbarBuilder.registerItem(item, 'rotateRight');
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'right') {
        this.editor.relayAction('rotateright', value);
      }
      if (pluginCommand === 'left') {
        this.editor.relayAction('rotateleft', value);
      }
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('rotate');
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('rotate', CUI.imageeditor.plugins.Rotate);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Rotate
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image rotation as a plugin.</p>
   * <p>The plugin ID is '<b>rotate</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>rotate left</b> - adds a button to rotate image left</li>
   *   <li><b>rotate right</b> - adds a button to rotate image right</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Flip = new Class({

    toString: 'Flip',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['horizontal', 'vertical'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('horizontal')) {
        item = toolbarBuilder.createItem('horizontal', this.getTooltip('horizontal'), this);
        toolbarBuilder.registerItem(item, 'reflectHorizontal');
      }
      if (this.isFeatureEnabled('vertical')) {
        item = toolbarBuilder.createItem('vertical', this.getTooltip('vertical'), this);
        toolbarBuilder.registerItem(item, 'reflectVertical');
      }
    },

    execute: function (pluginCommand, value) {
      switch (pluginCommand) {
      case 'horizontal':
        this.editor.relayAction('fliphorizontal', value);
        break;
      case 'vertical':
        this.editor.relayAction('flipvertical', value);
        break;
      }
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('flip');
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('flip', CUI.imageeditor.plugins.Flip);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Map
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements image map support.</p>
   * <p>The plugin ID is '<b>map</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>launch</b> - launches the map toolbar</li>
   *   <li><b>unlaunch</b> - unlaunches the map toolbar, reopening the default one</li>
   *   <li><b>confirm</b> - stores changes, unlaunches the map toolbar, reopening the default one</li>
   *   <li><b>rectangle</b> - inits adding a rectangular map</li>
   *   <li><b>circle</b> - inits adding a cicular/ellipsoid map</li>
   *   <li><b>polygon</b> - inits adding a polygon-shaped map</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Map = new Class({

    toString: 'Map',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['launch', 'unlaunch', 'confirm', 'rectangle', 'circle', 'polygon'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('launch')) {
        item = toolbarBuilder.createItem('launch', this.getTooltip('launch'), this);
        toolbarBuilder.registerItem(item, 'imageMap');
      }

      if (this.isFeatureEnabled('rectangle')) {
        item = toolbarBuilder.createItem('rectangle', this.getTooltip('rectangle'), this);
        toolbarBuilder.registerItem(item, 'imageMapRectangle');
      }
      if (this.isFeatureEnabled('circle')) {
        item = toolbarBuilder.createItem('circle', this.getTooltip('circle'), this);
        toolbarBuilder.registerItem(item, 'imageMapCircle');
      }
      if (this.isFeatureEnabled('polygon')) {
        item = toolbarBuilder.createItem('polygon', this.getTooltip('polygon'), this);
        toolbarBuilder.registerItem(item, 'imageMapPolygon');
      }

      if (this.isFeatureEnabled('unlaunch')) {
        item = toolbarBuilder.createItem('unlaunch', this.getTooltip('unlaunch'), this);
        toolbarBuilder.registerItem(item, 'close');
      }
      if (this.isFeatureEnabled('confirm')) {
        item = toolbarBuilder.createItem('confirm', this.getTooltip('confirm'), this);
        toolbarBuilder.registerItem(item, 'check');
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'launch') {
        $.each(this.editor.toolbars, function (index, value) {
          value.switchToolbar(CUI.imageeditor.plugins.Map.TOOLBAR_ID);
        });

        this.editor.relayAction('maplaunch', value);
      }
      else if (pluginCommand === 'unlaunch' || pluginCommand === 'confirm') {
        $.each(this.editor.toolbars, function (index, value) {
          this.switchToPrimaryToolbar();
        });

        this.editor.relayAction('map' + pluginCommand, value);
      }
      else if (pluginCommand === 'rectangle') {
        this.editor.relayAction('maprectangle', value);
      }
      else if (pluginCommand === 'circle') {
        this.editor.relayAction('mapcircle', value);
      }
      else if (pluginCommand === 'polygon') {
        this.editor.relayAction('mappolygon', value);
      }
    },

    registerTransformFields: function (transformResult) {
      transformResult.registerTransformField('map', []);
    }
  });
}(jQuery, this));

/**
 * Id of crop replacement toolbar
 * @static
 * @final
 * @type String
 * @private
 */
CUI.imageeditor.plugins.Map.TOOLBAR_ID = 'map';

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('map', CUI.imageeditor.plugins.Map);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Control
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements some control functionality as a plugin.</p>
   * <p>The plugin ID is '<b>control</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>finish</b> - adds a button that dispatches a 'finish' event - confirms editing</li>
   *   <li><b>close</b> - adds a button that dispatches a 'close' event - aborts editing</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Control = new Class({

    toString: 'Control',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['close', 'finish'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('close')) {
        item = toolbarBuilder.createItem('close', this.getTooltip('close'), this);
        toolbarBuilder.registerItem(item, 'close', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }

      if (this.isFeatureEnabled('finish')) {
        item = toolbarBuilder.createItem('finish', this.getTooltip('finish'), this);
        toolbarBuilder.registerItem(item, 'check', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }
    },

    execute: function (cmd, value, env) {
      if (cmd === 'close') {
        this.editor.cancel();
      }
      else if (cmd === 'finish') {
        this.editor.finish();
      }
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('control', CUI.imageeditor.plugins.Control);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.Fullscreen
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements fullscreen support.</p>
   * <p>The plugin ID is '<b>fullscreen</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>fullscreen</b> - launches full screen editing mode</li>
   *   <li><b>fullscreenexit</b> - exit full screen editing mode</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Fullscreen = new Class({

    toString: 'Fullscreen',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['fullscreen', 'fullscreenexit'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('fullscreen')) {
        item = toolbarBuilder.createItem('fullscreen', this.getTooltip('fullscreen'), this);
        toolbarBuilder.registerItem(item, 'fullScreen', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }
      if (this.isFeatureEnabled('fullscreenexit')) {
        item = toolbarBuilder.createItem('fullscreenexit', this.getTooltip('fullscreenexit'), this);
        toolbarBuilder.registerItem(item, 'fullScreenExit', CUI.imageeditor.Theme.TOOLBARITEM_MODECHANGER_CLASS);
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'fullscreen') {
        this.editor.switchToFullscreen();
      }
      else if (pluginCommand === 'fullscreenexit') {
        this.editor.switchToInline();
      }
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('fullscreen', CUI.imageeditor.plugins.Fullscreen);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.plugins.History
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements history support.</p>
   * <p>The plugin ID is '<b>history</b>'.</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>undo</b> - reverts the previous applied transformation</li>
   *   <li><b>redo</b> - reverts the last undo</li>
   * </ul>
   */
  CUI.imageeditor.plugins.History = new Class({

    toString: 'History',

    extend: CUI.imageeditor.plugins.Plugin,

    features: ['undo', 'redo'],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled('undo')) {
        item = toolbarBuilder.createItem('undo', this.getTooltip('undo'), this);
        this.notifyToolbarDecorator(item);

        toolbarBuilder.registerItem(item, 'undo', CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS);
      }
      if (this.isFeatureEnabled('redo')) {
        item = toolbarBuilder.createItem('redo', this.getTooltip('redo'), this);
        this.notifyToolbarDecorator(item);

        toolbarBuilder.registerItem(item, 'redo', CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS);
      }

      this.transformResultDecorator();
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === 'undo') {
        this.editor.relayAction('undo', value);
      }
      if (pluginCommand === 'redo') {
        this.editor.relayAction('redo', value);
      }
    },

    transformResultDecorator: function () {
      var self = this,
        transformResultFn = CUI.imageeditor.TransformResult.prototype.setTransformValue;

      if (this.isFeatureEnabled('undo') || this.isFeatureEnabled('redo')) {
        CUI.imageeditor.TransformResult.prototype.setTransformValue = function () {
          var i;

          transformResultFn.apply(this, arguments);

          for (i = self._observeHistory['undo'].length - 1; i >= 0; i--) {
            self._observeHistory['undo'][i].toggleClass(
              CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS,
              !this.history.length
            );
          }

          for (i = self._observeHistory['redo'].length - 1; i >= 0; i--) {
            self._observeHistory['redo'][i].toggleClass(
              CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS,
              !this.future.length
            );
          }

        };
      }
    },

    notifyToolbarDecorator: function (item) {
      var notifyToolbarFn = item.notifyToolbar,
        self = this;

      // create internal storage
      this._observeHistory = this._observeHistory || {};
      this._observeHistory[item.id] = this._observeHistory[item.id] || [];

      item.notifyToolbar = function () {
        notifyToolbarFn.apply(this, arguments);

        self._observeHistory[item.id].push(this.$ui);
      };

      return item;
    }
  });
}(jQuery, this));

// register plugin
CUI.imageeditor.plugins.PluginRegistry.register('history', CUI.imageeditor.plugins.History);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  var ZOOM_ID = 'zoom',
    POPUP_SLIDER = 'popupslider',
    POPUP_SLIDER_BUTTON_ICON = 'search',
    RESET_100 = 'reset100',
    RESET_100_BUTTON_ICON = 'compare';

  /**
   * @class CUI.imageeditor.plugins.Zoom
   * @extends CUI.imageeditor.plugins.Plugin
   * <p>This class implements zoom tools manipulating the zoomFactor option of the editor.</p>
   * <p>The plugin ID is "<b>zoom</b>".</p>
   * <p><b>Features</b></p>
   * <ul>
   *   <li><b>popupslider</b> - adds a slider to zoom from 10 - 300 %</li>
   *   <li><b>reset100</b> - adds a button to reset to 100% zoom (WYSIWYG)</li>
   * </ul>
   */
  CUI.imageeditor.plugins.Zoom = new Class({

    toString: 'Zoom',

    extend: CUI.imageeditor.plugins.Plugin,

    features: [POPUP_SLIDER, RESET_100],

    initializeUI: function (toolbarBuilder) {
      var item;

      if (this.isFeatureEnabled(POPUP_SLIDER)) {
        item = toolbarBuilder.createItem(POPUP_SLIDER, this.getTooltip(POPUP_SLIDER), this);
        toolbarBuilder.registerItem(item, POPUP_SLIDER_BUTTON_ICON);
      }

      if (this.isFeatureEnabled(RESET_100)) {
        item = toolbarBuilder.createItem(RESET_100, this.getTooltip(RESET_100), this);
        toolbarBuilder.registerItem(item, RESET_100_BUTTON_ICON);
      }
    },

    execute: function (pluginCommand, value) {
      if (pluginCommand === POPUP_SLIDER) {
        this.editor.relayAction(ZOOM_ID + POPUP_SLIDER, this);
      }
      if (pluginCommand === RESET_100) {
        this.editor.relayAction(ZOOM_ID + RESET_100, this);
      }

    },

    registerTransformFields: function (transformResult) {
    }
  });

  /**
   * Id of zoom replacement toolbar
   * @static
   * @final
   * @type String
   * @private
   */
  CUI.imageeditor.plugins.Zoom.TOOLBAR_ID = ZOOM_ID;


  // register plugin
  CUI.imageeditor.plugins.PluginRegistry.register(ZOOM_ID, CUI.imageeditor.plugins.Zoom);

}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  /**
   * @class CUI.imageeditor.ui.ToolbarBuilder
   * @private
   * <p>This class is used to build toolbars from plugins.</p>
   * <p>Each toolbar consists of several groups of toolbar items.
   * Each group has a sorting index to determine its position
   * relative to other groups. Each toolbar item has a sorting index to determine its position
   * relative to other icons of the same group.</p>
   * @constructor
   * Creates a new ToolbarBuilder
   */
  CUI.imageeditor.ui.ToolbarBuilder = new Class({

    toString: 'ToolbarBuilder',

    /**
     * @private
     */
    groups: null,

    $editable: null,

    construct: function (options) {
      this.registeredItems = {};
      this.templates = options.templates;
    },

    /**
     * Create a new toolbar item
     * @param {String} id ID of the toolbar item
     * @param {String} title Title/Tooltip to be used for the toolbar item
     * @param {CUI.imageeditor.plugins.Plugin} plugin The plugin the toolbar item belongs to
     * @return {CUI.imageeditor.ui.ToolbarItem} The toolbar item
     */
    createItem: function (id, title, plugin) {
      return new CUI.imageeditor.ui.ToolbarItem(id, title, plugin);
    },

    /**
     * Registers toolbar item in the correct group at the correct position.
     * @param {String} groupId ID of the group the item belongs to
     * @param {Number} groupSort Group sorting index
     * @param {CUI.imageeditor.ui.ToolbarItem} item Toolbar item to add
     * @param {Number} itemSort Item sorting index
     */
    registerItem : function (item, iconClass, additionalClasses) {
      item = $.extend({}, item, {
        icon : iconClass,
        addClasses : additionalClasses
      });

      this.registeredItems[item.action] = item;
    },

    /**
     * Create the abstracted toolbar
     * @return {CUI.imageeditor.ui.Toolbar} The toolbar
     * @ignore
     */
    createToolbar: function (options, toolbarType) {
      var toolbar,
          $editable = options.$editable,
          $toolbars,
          uiOptions = this.getUIOptions(options, toolbarType),
          i;

      if (!toolbarType) { throw new Error('ArgumentError - missing toolbar type'); }
      if (!uiOptions) { return null; }

      // Get the toolbars for this toolbar type
      $toolbars = CUI.imageeditor.UIUtils.getToolbars($editable, toolbarType);

      // Build toolbar if it doesn't exist
      if (!$toolbars || $toolbars.length === 0) {
        this._buildToolbar($editable, uiOptions, toolbarType);
      }

      // Use the newly created toolbar
      toolbar = new CUI.imageeditor.ui.Toolbar($editable, toolbarType);

      // Allow elements to notify toolbar
      for (i in this.registeredItems) {
        if (this.registeredItems.hasOwnProperty(i)) {
          this.registeredItems[i].notifyToolbar(toolbar);
        }
      }

      return toolbar;
    },



    /**
     * Build the $toolbar and append it to the $ui
     * @param {jQuery} $editable The jQuery editable (canvas) element
     * @param {Object} items Toolbar items
     * @param {Object} options All widget options
     * @private
     */
    _buildToolbar: function ($editable, uiOptions, toolbarType) {
      var toolbarTpl = this.templates.get('toolbar'),
          itemTemplate = this.templates.get('toolbar-item'),
          replacementToolbars = [];

      // Get the item options definitions
      replacementToolbars = [];

      // Build replacement toolbars
      var replacementToolbarDefs = uiOptions.replacementToolbars,
          ref, items;

      for (ref in replacementToolbarDefs) {
        if (replacementToolbarDefs.hasOwnProperty(ref)) {
          items = replacementToolbarDefs[ref];

          // Support for
          //   replacementToolbars : {
          //      crop: ['crop#identifier', ...],
          //      map:  ['map#rectangle', ...]
          //   }
          // as well as
          //   replacementToolbars : {
          //      crop: {
          //        ref : 'crop',
          //        items: ['crop#identifier', ...]
          //      },
          //      map: {
          //        ref: 'map',
          //        items: ['map#rectangle', ...]
          //      }
          //   }
          replacementToolbars.push(toolbarTpl({
            'ref': items.ref || ref,
            'toolbarItems': this.getToolbarItemHTML(items.items || items, itemTemplate)
          }));
        }
      }


      // Build the toolbar-collection
      var $toolbar = $(this.templates.get('toolbars')({
        'type': toolbarType,
        'toolbar': toolbarTpl({
          'ref': 'primary',
          'toolbarItems': this.getToolbarItemHTML(uiOptions.toolbar, itemTemplate)
        }),
        'replacementToolbars': replacementToolbars
      }));

      // Select the toolbar container to append to
      var $ui = CUI.imageeditor.UIUtils.getUIContainer($editable);
      var $toolbarContainer = CUI.imageeditor.UIUtils.getToolbarContainer($ui, toolbarType);

      $($toolbarContainer).append($toolbar);
    },


    /**
     * @private
     */
    // todo - this is the wrong place for this - should be part of a general options/config object + accessor/getter
    getUIOptions: function (options, tbType) {
      if (options && options.ui) {
        return options.ui[tbType];
      } else {
        return CUI.imageeditor.ui.DEFAULT_OPTIONS[tbType];
      }
    },

    /**
     * @private
     */
    getToolbarItemHTML : function (toolbarItemConfig, itemTemplate) {
      var i, items, item, toolbarLayout;

      if ($.isArray(toolbarItemConfig)) {
        if (!$.isArray(toolbarItemConfig[0])) {
          // plain config - everthing should be placed on the left-hand side
          toolbarLayout = {
            left: toolbarItemConfig,
            right: []
          };
        } else {
          // old style array of arrays:
          toolbarLayout = {
            left: toolbarItemConfig[0],
            right: toolbarItemConfig.length > 1 ? toolbarItemConfig[1] : []
          };
        }
      } else {
        toolbarLayout = {
          left: toolbarItemConfig.left ? toolbarItemConfig.left : [],
          right: toolbarItemConfig.right ? toolbarItemConfig.right : []
        };
        if (!$.isArray(toolbarItemConfig.left) || !$.isArray(toolbarItemConfig.right)) {
          throw new Error('Argument error: Expecting object {left:[], right:[]}');
        }
      }

      items = {left: [], right: []};
      for (i = 0; i < toolbarLayout.left.length; i++) {
        item = this.registeredItems[toolbarLayout.left[i]];
        if (item) {
          items.left.push($.trim(itemTemplate(item)));
        }
      }
      for (i = 0; i < toolbarLayout.right.length; i++) {
        item = this.registeredItems[toolbarLayout.right[i]];
        if (item) {
          items.right.push($.trim(itemTemplate(item)));
        }
      }

      return items;
    }
  });
}(jQuery, this));

CUI.imageeditor.ui.DEFAULT_OPTIONS = {
  'inline': {
    'toolbar': [
      'crop#launch',
      'rotate#left',
      'rotate#right',
      'flip#vertical',
      'flip#horizontal',
      'history#undo',
      'history#redo',
      'fullscreen#fullscreen',
      'control#close'
    ],
    'replacementToolbars': {
      'crop': [
        'crop#identifier',
        'crop#unlaunch',
        'crop#confirm'
      ]
    }
  },
  'fullscreen': {
    'toolbar': {
      'left': [
        'crop#launchwithratio',
        'rotate#left',
        'rotate#right',
        'flip#vertical',
        'flip#horizontal',
        'map#launch',
        'zoom#reset100',
        'zoom#popupslider'
      ],
      'right': [
        'history#undo',
        'history#redo',
        'fullscreen#fullscreenexit'
      ]
    },
    'replacementToolbars': {
      'crop': {
        'left': [
          'crop#identifier'
        ],
        'right': [
          'crop#unlaunch',
          'crop#confirm'
        ]
      },
      'map': {
        'left': [
          'map#rectangle',
          'map#circle',
          'map#polygon'
        ],
        'right': [
          'map#unlaunch',
          'map#confirm'
        ]
      }
    }
  }
};

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2013 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.ui.Toolbar = new Class({

    toString: 'Toolbar',

    $ui: null,

    $editable: null,

    $container: null,

    $toolbars: null,

    construct: function ($editable, tbType) {
      if (!tbType) { throw new Error('ArgumentError - missing toolbar type'); }

      this.tbType = tbType;
      this.$editable = $editable;
      this.$ui = CUI.imageeditor.UIUtils.getUIContainer(this.$editable);
      this.$container = CUI.imageeditor.UIUtils.getToolbarContainer(this.$ui, tbType);
      this.$toolbars = CUI.imageeditor.UIUtils.getToolbars(this.$editable, this.tbType);
      this.autoSetToolbarWidths();
      this.switchToPrimaryToolbar();
    },

    autoSetToolbarWidths: function () {
      var self = this;

      this.$toolbars.each(function () {
        var tbId = $(this).data('id');

        if (tbId !== undefined) {
          self.autoSetToolbarWidth(tbId);
        }
      });
    },

    autoSetToolbarWidth: function (tbId) {
      this.showToolbar(tbId);
      this.setToolbarWidth(tbId, this.calcToolbarWidth(tbId));
      this.hideToolbar(tbId);
    },

    setToolbarWidth: function (tbID, width) {
      var $tb = this.getToolbar(tbID);

      if ($tb !== null) {
        $tb.width(width);
      }
    },

    calcToolbarWidth: function (tbId) {
      var $tb = this.getToolbar(tbId),
          width = 0;

      $tb.children().each(function () {
        width += $(this).outerWidth(true);
      });

      return width;
    },

    show: function () {
      this.$container.addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
    },

    hide: function () {
      this.$container.addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
    },

    isHidden: function () {
      return (this.$container.hasClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS));
    },

    getContainer: function () {
      return this.$container;
    },

    getToolbar: function (tbId) {
      var tb = null;

      this.$toolbars.each(function () {
        if ($(this).data('id') === tbId) {
          tb = $(this);
          return;
        }
      });
      return tb;
    },

    getToolbars: function () {
      return this.$toolbars;
    },

    switchToPrimaryToolbar: function () {
      this.switchToolbar(CUI.imageeditor.ui.Toolbar.PRIMARY_TOOLBAR_ID);
    },

    switchToolbar: function (tbId) {
      this.hideToolbars();
      this.showToolbar(tbId);
    },

    showToolbar: function (tbId) {
      var tb = this.getToolbar(tbId);

      if (tb !== null) {
        $(tb).removeClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
      }
    },

    hideToolbar: function (tbId) {
      var tb = this.getToolbar(tbId);

      if (tb !== null) {
        $(tb).addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
      }
    },

    hideToolbars: function () {
      this.$toolbars.each(function () {
        $(this).addClass(CUI.imageeditor.Theme.IMAGEEDITOR_HIDDEN_CLASS);
      });
    },

    startEditing: function () {
      this.show();
    },

    finishEditing: function () {
      this.hide();
    }
  });
}(jQuery, this));

/**
 * Id of the primary toolbar
 * @static
 * @final
 * @type String
 * @private
 */
CUI.imageeditor.ui.Toolbar.PRIMARY_TOOLBAR_ID = 'primary';

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, undefined) {
  'use strict';

  CUI.imageeditor.ui.ToolbarItem = new Class({

    toString: 'ToolbarItem',

    $ui: null,

    id: null,

    plugin: null,

    title: null,

    toolbar: null,

    construct: function (id, title, plugin) {
      this._init.apply(this, arguments);
    },

    _init: function (id, title, plugin) {
      this.id = id;
      this.title = title;
      this.plugin = plugin;
      this.action = this.plugin.pluginId + '#' + this.id;
    },

    /**
     * Add this toolbar element to the toolbar
     * @param {CUI.imageeditor.ui.Toolbar} The toolbar
     * @ignore
     */
    notifyToolbar: function (toolbar) {
      var self = this, $cont = null;

      this.toolbar = toolbar;
      $cont = $(toolbar.getContainer());
      this.$ui = $cont.find('button[data-action="' + this.action + '"]');
      this.tapOrClickHandler = CUI.imageeditor.UIUtils.handleTapOrClick(this.$ui, function (e) {
        e.stopImmediatePropagation();
        if (!self.$ui.hasClass(CUI.imageeditor.Theme.TOOLBARITEM_DISABLED_CLASS)) {
          self.plugin.execute(self.id);
        }
        this.blur();
      },
      {
        eventNamespace: 'imageeditor-handler'
      });
    },

    createToolbarDef: function () {
      return {
        'id': this.id,
        'element': this
      };
    },

    destroy: function () {
      if (this.tapOrClickHandler) {
        this.tapOrClickHandler.off();
      }
    }
  });
}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2015 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* jshint eqeqeq: true, immed: true, latedef: true, newcap: true, noarg: true,
          sub: true, undef: true, boss: true, eqnull: true, browser: true,
          smarttabs: true */
/* global jQuery */
jQuery.fn.polygon = (function ($) {
    'use strict';

    var isN = function (n) {
        return !isNaN(n);
    };

    var Polygon = function ($element, options) {
        this.$element = $element;

        this.loadOpts(options);
    };

    Polygon.prototype.defaults = {
        points: []
    };

    Polygon.prototype.loadOpts = function (options) {
        this.options = $.extend({}, this.defaults, options);

      if (this.options.points) {
        this.points = this.readPoints(this.options.points);
      }
    };

    Polygon.prototype.readPoints = function (rawPoints) {
      var result = [], i, point, parsed;

      if (rawPoints && rawPoints.length) {
        for (i = 0; i < rawPoints.length; i++) {
          point = rawPoints[i];
          if (isN(point.w) && isN(point.h)) {
            parsed = {
              w: parseInt(point.w, 10),
              h: parseInt(point.h, 10)
            };
            result.push(parsed);
          }
        }
      }
      return result;
    };

    Polygon.prototype.clearCanvas = function (optionalCanvas) {
      var canvas = this.getCanvas(optionalCanvas),
        drawCtxt = this.get2dContext(optionalCanvas);

      drawCtxt.clearRect(0, 0, canvas.width, canvas.height);
    };

    Polygon.prototype.get2dContext = function (optional$Canvas) {
      return this.getCanvas(optional$Canvas).getContext('2d');
    };

    Polygon.prototype.getCanvas = function (optional$Canvas) {
      var canvas = this.$element;

      if (optional$Canvas) {
        canvas = optional$Canvas;
      }

      return canvas.length ? canvas[0] : canvas;
    };

    Polygon.prototype.paintPolygon = function (options) {
      this.paintPolygonWithPoints(null, null, options);
    };

    Polygon.prototype.paintPolygonWithPoints = function (canvas, points, options) {
      canvas = this.getCanvas(canvas);
      var drawCtxt = this.get2dContext(canvas),
        paintedOne = false, point, i;

      points = points || this.points;

      options = $.extend({
        strokeStyle: '#000',
        fillStyle: null,
        lineWidth: 1,
        lineJoin: 'round'
      }, options);

      if (points && points.length) {
        drawCtxt.beginPath();
        point = points[0];
        drawCtxt.moveTo(point.w, point.h);
        paintedOne = true;

        for (i = 1; i < points.length; i++) {
          point = points[i];
          drawCtxt.lineTo(point.w, point.h);
        }
        drawCtxt.closePath();
      }
      if (paintedOne) {
        if (options.strokeStyle) {
          drawCtxt.lineWidth = options.lineWidth;
          drawCtxt.strokeStyle = options.strokeStyle;
          drawCtxt.lineJoin = options.lineJoin;
          drawCtxt.stroke();
        }
        if (options.fillStyle) {
          drawCtxt.fillStyle = options.fillStyle;
          drawCtxt.fill();
        }
      }
    };

    Polygon.prototype.getPoints = function () {
        return this.points.slice();
    };

    Polygon.prototype.setPoints = function (points) {
      this.points = points;
    };

    /**
     * Checks if point is inside or on the boundary of the bounding box.
     * @param optionalPointsOrRect either use these or create bb from points of this polygon
     * @param w to check
     * @param h to check
     * @returns {boolean} result
     */
    Polygon.prototype.isCoordsInBoundingBox = function (optionalPointsOrRect, w, h) {
      var boundingBox = null;

      if (optionalPointsOrRect && typeof(optionalPointsOrRect.left) !== 'undefined') {
        boundingBox = optionalPointsOrRect;
      } else {
        boundingBox = this.getBoundingBox(optionalPointsOrRect);
      }

      return w >= boundingBox.left && w <= (boundingBox.left + boundingBox.width) &&
        h >= boundingBox.top && h <= (boundingBox.top + boundingBox.height);
    };

    Polygon.prototype.getBoundingBox = function (optionalPoints) {
      var points = optionalPoints || this.points,
        boundingBox = {
          top: Number.MAX_VALUE,
          bottom: Number.MIN_VALUE,
          left: Number.MAX_VALUE,
          right: Number.MIN_VALUE
        }, i, point;

      if (!points || points.length < 1) {
        throw new Error('Cannot define bounding box if there are no points, handle this case differently');
      }

      for (i = 0; i < points.length; i++) {
        point = points[i];
        if (point.w < boundingBox.left) {
          boundingBox.left = point.w;
        }
        if (point.w > boundingBox.right) {
          boundingBox.right = point.w;
        }

        if (point.h < boundingBox.top) {
          boundingBox.top = point.h;
        }
        if (point.h > boundingBox.bottom) {
          boundingBox.bottom = point.h;
        }
      }

      boundingBox.width = boundingBox.right - boundingBox.left;
      boundingBox.height = boundingBox.bottom - boundingBox.top;

      return boundingBox;
    };

  /**
   * Builds on the fact that to be inside of a polygon a line cutting parallel to
   * the x axis from -inf to the point must intersect polygon an uneven num.
   *
   * Stability: Limited to components of vectors >-60,000,000 and <60,000,000. Multiplies vector components and
   * adds the results, so stability is rapidly lost for vectors whose components become too big.
   *
   * @param pointVector
   * @param polygonPointsAsVectors
   * @returns {boolean}
   */
    Polygon.prototype.isPointInsideOrOnEdgeOfPolygon = function (pointVector, polygonPointsAsVectors) {
      var currSegment, intersectionCount, intersectionResult, prevPoint, i,
        testLineSegment = [[-60000000, pointVector[1]], pointVector]; // stability lost if components of vectors become too large

      if (!polygonPointsAsVectors || polygonPointsAsVectors.length < 3) {
        return false;
      }

      intersectionCount = 0;
      prevPoint = polygonPointsAsVectors[polygonPointsAsVectors.length -1];
      for (i = 0; i < polygonPointsAsVectors.length; i++) {
        currSegment = [prevPoint, polygonPointsAsVectors[i]];
        if (this.isPointOnLineSegment(pointVector, currSegment[0], currSegment[1])) {
          return true; // otherwise result will be inside hits only
        }

        intersectionResult = this.intersectSegments(testLineSegment, currSegment);
        if (intersectionResult != null) {
          intersectionCount++;
        }
        prevPoint = polygonPointsAsVectors[i];
      }

      return intersectionCount > 0 && intersectionCount % 2 === 1;
    };

    /**
     *
     * @param segmentAVectors segment defined by two edge vertexes
     * @param segmentBVectors segment defined by two edge vertexes
     * @return null if no intersection, segment if segments share a part or are equal else the intersection point as vector
     */
    Polygon.prototype.intersectSegments = function (segmentAVectors, segmentBVectors) {
      var a = segmentAVectors[0], b = segmentAVectors[1], c = segmentBVectors[0], d = segmentBVectors[1],
        intersection = this.intersectLines(segmentAVectors, segmentBVectors);

      if (intersection == null) {
        return null;
      }

      if (intersection === true) {
        if (this.isWithin(c, a, d)) {
          if (this.isWithin(c, b, d)) {
            return [a, b];
          } else {
            if (this.isWithin(a, c, b)) {
              return [a, c];
            } else {
              return [a, d];
            }
          }
        } else if (this.isWithin(c, b, d)) {
          if (this.isWithin(a, c, b)) {
            return [b, c];
          } else {
            return [b, d];
          }
        } else if (this.isWithin(a, c, b)) {
          if (this.isWithin(a, d, b)) {
            return [c, d];
          } else {
            if (this.isWithin(c, a, d)) {
              return [c, a];
            } else {
              return [c, b];
            }
          }
        } else if (this.isWithin(a, d, b)) {
          if (this.isWithin(c, a, d)) {
            return [a, d];
          } else {
            return [b, d];
          }
        } else {
          return null;
        }

      } else {
        if (this.isPointOnLineSegment(intersection, segmentAVectors[0], segmentAVectors[1]) &&
          this.isPointOnLineSegment(intersection, segmentBVectors[0], segmentBVectors[1])) {

          return intersection;
        }
        return null;
      }
    };

    /**
     *
     * @param lineA line composed of two point vectors on the line
     * @param lineB line composed of two point vectors on the line
     * @return null if no intersection, true if same line (parallel lines) else the intersection point as vector
     */
    Polygon.prototype.intersectLines = function (lineAVectors, lineBVectors) {
      if (lineAVectors.length !== 2 || lineBVectors.length !== 2) {
        throw new Error("Arguments invalid: Please pass 2 arrays of two vectors each");
      }
      var a = lineAVectors[0], b = lineAVectors[1],
        c = lineBVectors[0], d = lineBVectors[1],
        v = [b[0]-a[0], b[1]-a[1]], // v = b - a
        w = [d[0]-c[0], d[1]-c[1]], // w = d - c
        x2, // c + x2 * w = t1;
        dividend, divisor,
        t1, t2,
        vIsZero = this.vectorsEqual(v, [0, 0]),
        wIsZero = this.vectorsEqual(w, [0, 0]);

      // check for point cases (no line passed, just two equal vectors: point)
      if (vIsZero) {
        if (wIsZero) {
          if (this.vectorsEqual(a, c)) {
            return a;
          } else {
            return null;
          }
        } else {
          if (this.isThreePointsOnOneLine(c, d, a)) {
            return a;
          } else {
            return null;
          }
        }
      }
      if (wIsZero) {
        if (this.isThreePointsOnOneLine(a, b, c)) {
          return c;
        } else {
          return null;
        }
      }

      if ((v[0] === 0 && w[0] === 0) ||
        (v[1] === 0 && w[1] === 0) ||
        this.floatsEqual(v[0] / w[0], v[1] / w[1])) {

        // lines parallel
        if (this.isThreePointsOnOneLine(a, b, c)) {
          return true;
        } else {
          return null;
        }
      }

      dividend = v[0]*(a[1] - c[1]) + v[1]*(c[0] - a[0]);
      divisor = v[0] * w[1] - v[1] * w[0];
      x2 = dividend / divisor;

      t1 = c[0] + x2*w[0];
      t2 = c[1] + x2*w[1];

      return [t1, t2];
    };

    /**
     * Points are vectors here: array with 2 entries.
     *
     * @param point to check for nearness to segments
     * @param lineSegments array of two-point arrays. Segments are given by their ending points
     */
    Polygon.prototype.filterLineSegmentsNextToPointAndSortByDistance = function (point, lineSegments) {
      var result = [], i, current, projection, orthoProjectingVector;

      for (i = 0; i < lineSegments.length; i++) {
        current = lineSegments[i];
        projection = this.projectPointOntoLine(point, current[0], current[1]);
        if (this.isPointOnLineSegment(projection, current[0], current[1])) {
          orthoProjectingVector = [projection[0] - point[0], projection[1] - point[1]];
          result.push({
            line: current,
            projection: projection,
            distance: this.vectorNorm(orthoProjectingVector)
          });
        }
      }

      result.sort(function (a, b) { return a.distance - b.distance; });
      return result;
    };

    /**
     * Points are vectors here: array with 2 entries.
     *
     * @param p point to project
     * @param l1 point on line defined by l1 and l2. If l1 == l2 vector from p to l1 is returned
     * @param l2 see l1
     * @return the vector from p to X, point on line (defined by l1,l2), or vector from p to l1 if l1 == l2.
     *  Do p + returnedVector to get the projection point on line (defined by l1,l2)
     */
    Polygon.prototype.projectPointOntoLine = function (p, l1, l2) {
      var lineSlope, // slope of line through l1 and l2
        o, // vector orthogonal to lineSlope
        x; // stretch factor for slope vector, which when added to l1 points to the searched projection point on line

      if (l1[0] === l2[0] && l1[1] === l2[1]) {
        // special case, no line, only point given. Project to point ; )
        return [
          l1[0] - p[0],
          l1[1] - p[1]
        ];
      }

      lineSlope = [l1[0]-l2[0], l1[1]-l2[1]];
      if (lineSlope[1] === 0) {
        o = [0.0, 1.0];
      } else {
        o = [1.0, (-1.0 * (lineSlope[0] / lineSlope[1]))];
      }

      x = ( o[1]*( l1[0] - p[0] ) + o[0]*( p[1] - l1[1] ) ) / //
          ( o[0]*lineSlope[1] - o[1]*lineSlope[0] );

      return [
        l1[0] + x*lineSlope[0],
        l1[1] + x*lineSlope[1]
      ];
    };

    Polygon.prototype.isPointOnLineSegment = function (p, l1, l2) {
      if (this.isThreePointsOnOneLine(p, l1, l2)) {
        if (l1[0] !== l2[0]) {
          return this.isWithin(l1[0], p[0], l2[0]);
        } else {
          return this.isWithin(l1[1], p[1], l2[1]);
        }
      }
      return false;
    };

    /**
     * Implementation is using multiplication, so stability is lost for big inputs (vectors with a component >60,000,000).
     */
    Polygon.prototype.isThreePointsOnOneLine = function (p1, p2, p3) {
      return this.floatsEqual((p2[0] - p1[0]) * (p3[1] - p1[1]), (p3[0] - p1[0]) * (p2[1] - p1[1]));
    };

    Polygon.prototype.isWithin = function (side1, middle, side2) {
      return (side1 <= middle) && (middle <= side2) ||
        (side2 <= middle) && (middle <= side1);
    };

    Polygon.prototype.floatsEqual = function (a, b, relativeError) {
      if (typeof(relativeError) === 'undefined') {
        relativeError = 0.000000001;
      }
      if (a === b) {
        return true;
      }
      return Math.abs((a - b) / b) <= relativeError;
    };

    Polygon.prototype.vectorNorm = function (vector) {
      return Math.sqrt(this.dotProduct(vector, vector));
    };

    /**
     * Also called scalar product.
     */
    Polygon.prototype.dotProduct = function (a, b) {
      var sum = 0, i;
      if (a.length !== b.length) {
        throw new Exception('a and b have differing length');
      }

      for (i = 0; i < a.length; i++) {
        sum = sum + a[i] * b[i];
      }
      return sum;
    };

    Polygon.prototype.pointsToVectors = function (p) {
      var resultArr, i;
      if (typeof(p) === 'object') {
        if (typeof(p.length) !== 'undefined') {
          resultArr = [];
          for (i = 0; i < p.length; i++) {
            resultArr.push(this.pointsToVectors(p[i]));
          }
          return resultArr;
        }
        if (typeof(p.w) !== 'undefined') {
          return [p.w, p.h];
        } else {
          return [p.x, p.y];
        }
      }
      return;
    };

    Polygon.prototype.vectorsEqual = function (a, b) {
      var i;
      if (a.length !== b.length) {
        return false;
      }

      for (i = 0; i < a.length; i++) {
        if (!this.floatsEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    };

    Polygon.prototype.pointsToLineSegmentsWithVectors = function (points) {
      var i, vectors = this.pointsToVectors(points),
        result = [], singleLine;

      if ((!vectors) || vectors.length < 2) {
        return [];
      }

      if (vectors.length === 2) {
        result.push([vectors[0], vectors[1]]);
        return result;
      }

      for (i = 1; i < vectors.length; i++) {
        result.push([vectors[i-1], vectors[i]]);
      }
      result.push([ vectors[vectors.length-1], vectors[0] ]);
      return result;
    };

    var ctor = function (options) {
        options = options || {};
        this.each(function () {
            var el = $(this), instance = el.data('polygon');

            if (options.call) {
                if (instance) {
                    instance[options.call].call(instance, options);
                }
            }
            else if (!instance) {
                instance = new Polygon(el, options);
                el.data('polygon', instance);
            }
            else {
                instance.loadOpts(options);
            }
        });

        if (options && options.instance) {
            return this.eq(0).data('polygon');
        }
        else {
            return this;
        }
    };

    return ctor;
})(jQuery);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* jshint eqeqeq: true, immed: true, latedef: true, newcap: true, noarg: true,
          sub: true, undef: true, boss: true, eqnull: true, browser: true,
          smarttabs: true */
/* global jQuery */
jQuery.fn.imageSelect = (function ($) {
    'use strict';

    var EVENT = {
        NAMESPACE : '.imageSelect'
    };

    // Events that are consumed
    EVENT.CLICK  = 'click'              + EVENT.NAMESPACE;
    EVENT.RESIZE = 'resize'             + EVENT.NAMESPACE;

    EVENT.MOUSEDOWN = 'touchstart'  + EVENT.NAMESPACE + ' ' +
                      'mousedown'   + EVENT.NAMESPACE;
    EVENT.MOUSEUP   = 'touchend'    + EVENT.NAMESPACE + ' ' +
                      'touchcancel' + EVENT.NAMESPACE + ' ' +
                      'mouseup'     + EVENT.NAMESPACE;
    EVENT.MOUSEMOVE = 'touchmove'   + EVENT.NAMESPACE + ' ' +
                      'mousemove'   + EVENT.NAMESPACE;

    // Events that are emitted
    EVENT.OPEN   = 'open';
    EVENT.CLOSE  = 'close';
    EVENT.UPDATE = 'update';
    EVENT.SECOND_CLICK = 'second_click';



    var SELECTION_BORDER = 2, // see CSS rule .image-select-selection
        UPDATE_INTERVAL = 50,
        SUPPORTED_SHAPES = ['rectangle', 'ellipse'];


    var isN = function (n) {
        return !isNaN(n);
    };

    var preventDefaultAndPropagation = function (e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
    };

    /**
     * Gets page coordinates of event. Touch event coordinates returned if available.
     * @param {Object} e the event
     * @returns {{x: (Number), y: (Number)}} Page coordinates X and Y
     * @private
     */
    var _getEventCoordinates = function (e) {
        if (e.originalEvent.touches) {
            return { x : e.originalEvent.touches[0].pageX, y : e.originalEvent.touches[0].pageY };
        }
        else {
            return { x : e.pageX, y : e.pageY };
        }
    };

    var moveSelectionIntoCanvas = function (selection, canvas, min, aspectRatio) {
        // Reduce dimension to be smaller or equal to canvas dimensions
        selection.width  = Math.min(canvas.width, selection.width);
        selection.height = Math.min(canvas.height, selection.height);

        if (typeof(min) !== 'undefined') {
          selection.width = Math.max(min.width, selection.width);
          selection.height = Math.max(min.height, selection.height);
        }

        // Fix aspect ratio
        if (typeof(aspectRatio) !== 'undefined' && aspectRatio !== 0) {
            if (selection.height > Math.round(selection.width * aspectRatio)) {
                selection.height = Math.floor(selection.width * aspectRatio);
            }
            else {
                selection.width = Math.floor(selection.height / aspectRatio);
            }
        }

        // Move selection away from edge, until it is inside canvas
        selection.left = Math.max(canvas.left, selection.left);
        selection.left = Math.min(canvas.left + canvas.width - selection.width,
                                  selection.left);
        selection.top = Math.max(canvas.top, selection.top);
        selection.top = Math.min(canvas.top + canvas.height - selection.height,
                                 selection.top);

        return selection;
    };

    // matrix may contain scientific floats on chrome, which chrome doesn't accept, example: 'matrix(6.12323399573677e-17, 1, -1, 6.12323399573677e-17, 0, 0)'
    var MATRIX   = /matrix\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 6 numbers
        MATRIX3D = /matrix3d\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 16 numbers
        i = function (s) {
          var number = parseFloat(s);
          if (isNaN(number)) {
            throw new Error('Number is not a float');
          }
          return Math.round(number);
        };

    var get2by2MatrixFromElement = function (element) {
        var matrixStr = $(element).css('transform'),
            match;

        try {
          match = matrixStr.match(MATRIX);
          if (match) {
              /**
               * TODO: Find out why this is not the way, I would expect it to be.
               *
               * Based on documentation and my understanding, the matrix should be
               *
               *     i(match[1]) i(match[3])
               *     i(match[2]) i(match[4])
               *
               * This would also be similar to the 3d version below.
               *
               * BUT, it does not yield the expected results. Instead the
               * following one works just as desired. Therefore I am using that
               * one -- although I do not know why.
               */
              return [
                  [i(match[1]), i(match[2])],
                  [i(match[3]), i(match[4])]
              ];
          }

          match = matrixStr.match(MATRIX3D);
          if (match) {
              return [
                  [i(match[1]), i(match[5])],
                  [i(match[2]), i(match[6])]
              ];
          }
          else if (matrixStr === 'none') {
              return [
                  [1, 0],
                  [0, 1]
              ];
          }
        } catch (e) {
          // logged below
        }

        if (window.console && window.console.log) {
            window.console.log('ImageEditor: Could not parse matrix string', matrixStr);
        }

        return [
            [1, 0],
            [0, 1]
        ];
    };
    var applyMatrixToCoordinates = function (matrix, point) {
        if (matrix.length !== 2 ||
            matrix[0].length !== 2 ||
            matrix[1].length !== 2) {
            throw new Error('Expecting 2x2 matrix');
        }
        if (point.x === undefined || point.y === undefined) {
            throw new Error('Expecting point to be object like {x: 0, y: 0}');
        }

        return $.extend({}, point, {
            x : point.x * matrix[0][0] + point.y * matrix[0][1],
            y : point.x * matrix[1][0] + point.y * matrix[1][1]
        });
    };
    // chrome returns currently (v38) scientific notation for very small numbers, but doesn't accept it. So nullify this.
    var normalizeMatrixForChrome = function (matrixStr) {
      try {
        var outerMatch = matrixStr.match(/matrix\(([^)]+)\)/);
        if (outerMatch) {
          var inner = outerMatch[1];
          var numbers = inner.split(/, ?/);
          var normalizedNumbers = [];
          for (var i = 0; i < numbers.length; i++) {
            var current = numbers[i];
            if (current.indexOf('e') > -1 || current.indexOf('E') > -1) {
              var parsed = parseFloat(current);
              if (isNaN(parsed)) {
                throw new Error('Not a number: \'' + current + '\'');
              }

              normalizedNumbers.push('' + parsed.toFixed(19)); // toFixed limited to 20

            } else {
              normalizedNumbers.push(current);
            }
          }
          return 'matrix(' + normalizedNumbers.join(', ') + ')';
        }

      } catch (e) {
        // ignored
      }

      return matrixStr;
    };


    var ImageSelection = function ($element, options) {
        this.$element = $element;

        this.open(options);
    };

    ImageSelection.prototype.defaults = {
        classPrefix : 'image-select-', // {String} The prefix for css classes applied to UI elements.
        parent      : null,            // {Mixed} parent element to append UI controls to. jQuery Object, selector or HTMLElement. Otherwise, adds controls after element.
        min         : 40,              // {Number} Minimum width/height of selection
        selection   : null             // {Object} Set an initial selection area and shape.
    };

    ImageSelection.prototype.init = function (options) {
        this.options = $.extend({}, this.defaults, options);

        this.matrix = get2by2MatrixFromElement(this.$element);

        this.canvas = this.options.canvas || this.canvas || {
            top    : 0,
            left   : 0,
            width  : this.$element.width(),
            height : this.$element.height()
        };

        this.readSelectionFromOptions();
        this.readAspectRatioFromOptions();

        moveSelectionIntoCanvas(this.selection, this.canvas, this.min, this.aspectRatio);
    };

    ImageSelection.prototype.readSelectionFromOptions = function () {
        if ($.inArray(this.options.shape, SUPPORTED_SHAPES) === -1) {
            this.shape = SUPPORTED_SHAPES[0];
        }
        else {
            this.shape = this.options.shape;
        }

        var sel = this.options.selection;

        if (sel && isN(sel.top) && isN(sel.height) && isN(sel.left) && isN(sel.width)) {
            this.selection = {
                top    : parseInt(sel.top, 10),
                left   : parseInt(sel.left, 10),
                width  : parseInt(sel.width, 10),
                height : parseInt(sel.height, 10)
            };
        }
        else {
            this.selection = this.selection || {
                top    : this.canvas.top  + 50,
                left   : this.canvas.left + 50,
                width  : this.canvas.width  - 100,
                height : this.canvas.height - 100
            };
        }
    };

    ImageSelection.prototype.readAspectRatioFromOptions = function () {
        var MIN_SIZE = this.options.min;

        if (this.options.aspectRatio) {
            this.aspectRatio = parseFloat(this.options.aspectRatio);
        }
        if (!this.aspectRatio) { // includes NaN and undefined, also 0, but who cares
            this.aspectRatio = 0;
        }
        this.fixedAspectRatio = (this.aspectRatio !== 0);

        if (this.fixedAspectRatio) {
            if (this.aspectRatio > 1) {
                this.min = {
                    width : MIN_SIZE,
                    height: MIN_SIZE * this.aspectRatio
                };
            }
            else {
                this.min = {
                    width : MIN_SIZE / this.aspectRatio,
                    height: MIN_SIZE
                };
            }
        }
        else {
            this.min = {
                width : MIN_SIZE,
                height: MIN_SIZE
            };
        }
    };

    ImageSelection.prototype.cssClass = function (name) {
        return this.options.classPrefix + name;
    };

    ImageSelection.prototype.createDiv = function (name) {
        return $('<div>').addClass(this.cssClass(name));
    };

    ImageSelection.prototype.buildUI = function () {
        this.$holder = this.createDiv('holder').css({
            width  : this.$element.width(),
            height : this.$element.height()
        }).addClass(this.cssClass(this.shape));

        this.$backdrop = this.createDiv('backdrop').css({
            width  : this.canvas.width,
            height : this.canvas.height,
            top    : this.canvas.top,
            left   : this.canvas.left
        });
        this.$holder.append(this.$backdrop);


        this.$selection = this.createDiv('selection');
        this.$holder.append(this.$selection);

        this.handleDragging(this.$selection, this.handleCenter);


        if (this.shape === 'rectangle') {
            // Add Guidelines
            var verticalGuideline = this.createDiv('guideline').
                    addClass(this.cssClass('guideline-vertical'));
            this.$selection.append(verticalGuideline);

            var horizontalGuideline = this.createDiv('guideline').
                    addClass(this.cssClass('guideline-horizontal'));
            this.$selection.append(horizontalGuideline);

            if (!this.fixedAspectRatio) {
                this.createHandle({top : '0',    left : '50%' }, this.handleTop);
                this.createHandle({top : '50%',  left : '100%'}, this.handleRight);
                this.createHandle({top : '100%', left : '50%' }, this.handleBottom);
                this.createHandle({top : '50%',  left : '0'   }, this.handleLeft);
            }
            this.createHandle({top : '0',    left : '100%'}, this.handleTopRight);
            this.createHandle({top : '100%', left : '100%'}, this.handleBottomRight);
            this.createHandle({top : '100%', left : '0'   }, this.handleBottomLeft);
            this.createHandle({top : '0',    left : '0'   }, this.handleTopLeft);
        }
        else if (this.shape === 'ellipse') {
            this.createHandle({top : '86%', left : '86%'}, this.handleBottomRight);
        }

        this.updateUI(false);

        if (this.options.parent) {
            $(this.options.parent).append(this.$holder);
        }
        else {
            this.$element.after(this.$holder);
        }

        this.repositionUI();
        if (this.options.applyTransformations) {
            this.applyTransformationsToUI();
        }

        this.$element.trigger(EVENT.OPEN, this);

        this.$backdrop.on(EVENT.CLICK, preventDefaultAndPropagation);
        this.$selection.on(EVENT.CLICK, this, preventDefaultAndPropagation);
        $(window).on(EVENT.RESIZE, this, this.repositionUI);
    };

    ImageSelection.prototype.repositionUI = function (e) {
        var self = e ? e.data : this;

        self.$holder.position({of: self.$element, at: 'center', my: 'center'});
    };

    ImageSelection.prototype.applyTransformationsToUI = function (e) {
        var normalizedTransform = normalizeMatrixForChrome(this.$element.css('transform'));
        this.$holder.css({
            'transform'         : normalizedTransform,
            '-webkit-transform' : normalizedTransform
        });

        // Apply margin to position correctly on rotated images
        if (applyMatrixToCoordinates(this.matrix, {x: 1, y: 0}).x === 0) {

            var diff = (this.$element.width() - this.$element.height()) / 2;

            this.$holder.css({
                'margin-top'    : + diff,
                'margin-right'  : - diff,
                'margin-bottom' : + diff,
                'margin-left'   : - diff
            });
        }
    };

    ImageSelection.prototype.ensureSelectionIsInReasonableBounds = function (selection) {
        selection.width  = Math.max(this.min.width, selection.width);
        selection.width  = Math.min(this.canvas.width, selection.width);

        selection.height = Math.max(this.min.height, selection.height);
        selection.height = Math.min(this.canvas.height, selection.height);

        selection.top    = Math.max(this.canvas.top, selection.top);
        selection.top    = Math.min((this.canvas.top + this.canvas.height) - selection.height, selection.top);

        selection.left   = Math.max(this.canvas.left, selection.left);
        selection.left   = Math.min((this.canvas.left + this.canvas.width) - selection.width, selection.left);
    };

    ImageSelection.prototype.enforceAspectRatio = function (selection, fixer) {
        if (!this.fixedAspectRatio) {
            return selection;
        }

        if (selection.height > Math.round(selection.width * this.aspectRatio)) {
            selection.height = Math.floor(selection.width * this.aspectRatio);
        }
        else {
            selection.width = Math.floor(selection.height / this.aspectRatio);
        }

        if (fixer) {
            fixer.call(this);
        }

        return selection;
    };

    ImageSelection.prototype.updateUI = function (notify) {
        if (
                this.previousSelection &&
                this.previousSelection.top    === this.selection.top &&
                this.previousSelection.left   === this.selection.left &&
                this.previousSelection.width  === this.selection.width &&
                this.previousSelection.height === this.selection.height
            ) {
            // Avoid repositioning if nothing happened
            return;
        }

        if (this.$backdrop) {
            this.$backdrop.css({
                'border-top-width'    : this.selection.top - this.canvas.top,
                'border-right-width'  : (this.canvas.left + this.canvas.width) - (this.selection.left + this.selection.width),
                'border-bottom-width' : (this.canvas.top + this.canvas.height) - (this.selection.top + this.selection.height),
                'border-left-width'   : this.selection.left - this.canvas.left
            });
        }

        if (this.$selection) {
            this.$selection.css({
                'top'    : this.selection.top  - SELECTION_BORDER + 'px',
                'left'   : this.selection.left - SELECTION_BORDER + 'px',
                'width'  : this.selection.width + 'px',
                'height' : this.selection.height + 'px'
            });
        }

        this.previousSelection = $.extend({}, this.selection);

        if (notify !== false) {
            // Notify consumers about our updated selection
            this.$element.trigger(EVENT.UPDATE, this.getSelection());
        }
    };

    ImageSelection.prototype.createHandle = function (css, handler) {
        var handle = this.createDiv('handle').css(css);

        this.$selection.append(handle);
        this.handleDragging(handle, handler);
    };

    ImageSelection.prototype.handleDragging = function (element, handler) {
        var self = this;

        element.on(EVENT.MOUSEDOWN, function (e) {
            if (e.which !== 1 /* LEFT CLICK */ && e.which !== 0 /* TOUCH */) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();

            var memo = {},
                baseEventCoords = _getEventCoordinates(e),
                baseSelection = $.extend({}, self.selection);

            $('body')
                .on(EVENT.MOUSEMOVE, function (e) {
                    // prevent default - mainly to avoid scroll, which would happen
                    // on touch devices
                    e.preventDefault();

                    var currEventCoords = _getEventCoordinates(e);

                    memo.x = currEventCoords.x - baseEventCoords.x;
                    memo.y = currEventCoords.y - baseEventCoords.y;

                    // Use timeout to avoid too many UI updates
                    if (!memo.timeout) {
                        memo.timeout = setTimeout(function () {
                            delete memo.timeout;
                            memo.moved = true;
                            self.handleDrag(
                                applyMatrixToCoordinates(self.matrix, memo),
                                baseSelection,
                                handler);
                        }, UPDATE_INTERVAL);
                    }
                })
                .one(EVENT.MOUSEUP, function () {
                    $(this).off(EVENT.MOUSEMOVE)
                      // .one only to show intention. That alone doesn't work on touch devices because touch
                      // and mouse events are triggered and one will only delete one of them, leading to more than one execution.
                      // (mind that EVENT.MOUSEUP references more than one event. See definition).
                      .off(EVENT.MOUSEUP);

                    self.showAllHandles();

                    if (!memo.moved) {
                        self.$element.trigger(EVENT.SECOND_CLICK, self);
                    }
                });

            self.hideOtherHandles(element);
        });
    };

    ImageSelection.prototype.hideOtherHandles = function (handle) {
        this.$selection.find('.' + this.cssClass('handle')).
                        not(handle).addClass(this.cssClass('handle-other'));

        handle.addClass(this.cssClass('handle-selected'));
    };

    ImageSelection.prototype.showAllHandles = function () {
        this.$selection.find('.' + this.cssClass('handle')).
                        removeClass(this.cssClass('handle-other')).
                        removeClass(this.cssClass('handle-selected'));
    };


    ImageSelection.prototype.handleDrag = function (change, baseSelection, handler) {
        var selection = handler.call(this, change, baseSelection);

        if (selection) {
            // update selection
            this.selection.top    = Math.round(selection.top);
            this.selection.left   = Math.round(selection.left);
            this.selection.width  = Math.round(selection.width);
            this.selection.height = Math.round(selection.height);

            this.updateUI();
        }
    };

    ImageSelection.prototype.handleTop = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // move upper bar, change height, keep lower bar
        selection.top = selection.top + change.y;
        selection.top = Math.max(this.canvas.top, selection.top);
        selection.top = Math.min(baseSelection.top + baseSelection.height - this.min.height, selection.top);

        selection.height = baseSelection.top + selection.height - selection.top;

        return selection;
    };

    ImageSelection.prototype.handleTopRight = function (change, baseSelection) {
        var selection = this.handleTop(change, this.handleRight(change, baseSelection));

        this.enforceAspectRatio(selection, function () {
            selection.top = baseSelection.top - (selection.height - baseSelection.height);
        });

        return selection;
    };

    ImageSelection.prototype.handleRight = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // keep upper bar, change width, change lower bar
        selection.width = selection.width + change.x;
        selection.width = Math.max(this.min.width, selection.width);
        selection.width = Math.min((this.canvas.left + this.canvas.width) - baseSelection.left, selection.width);

        return selection;
    };

    ImageSelection.prototype.handleBottomRight = function (change, baseSelection) {
        var selection = this.handleBottom(change, this.handleRight(change, baseSelection));

        this.enforceAspectRatio(selection);

        return selection;
    };

    ImageSelection.prototype.handleBottom = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // keep upper bar, change height, change lower bar
        selection.height = selection.height + change.y;
        selection.height = Math.max(this.min.height, selection.height);
        selection.height = Math.min((this.canvas.top + this.canvas.height) - baseSelection.top, selection.height);

        return selection;
    };

    ImageSelection.prototype.handleBottomLeft = function (change, baseSelection) {
        var selection = this.handleBottom(change, this.handleLeft(change, baseSelection));

        this.enforceAspectRatio(selection, function () {
            selection.left = baseSelection.left - (selection.width - baseSelection.width);
        });

        return selection;
    };

    ImageSelection.prototype.handleLeft = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // move upper bar, change width, keep lower bar
        selection.left = selection.left + change.x;
        selection.left = Math.max(this.canvas.left, selection.left);
        selection.left = Math.min(baseSelection.left + baseSelection.width - this.min.width, selection.left);

        selection.width = baseSelection.left + selection.width - selection.left;

        return selection;
    };

    ImageSelection.prototype.handleTopLeft = function (change, baseSelection) {
        var selection = this.handleTop(change, this.handleLeft(change, baseSelection));

        this.enforceAspectRatio(selection, function () {
            selection.left = baseSelection.left - (selection.width - baseSelection.width);
            selection.top = baseSelection.top - (selection.height - baseSelection.height);
        });

        return selection;
    };

    ImageSelection.prototype.handleCenter = function (change, baseSelection) {
        var selection = $.extend({}, baseSelection);

        // move upper bar, keep height, move lower bar
        selection.top = selection.top + change.y;
        selection.top = Math.max(this.canvas.top, selection.top);
        selection.top = Math.min((this.canvas.top + this.canvas.height) - baseSelection.height, selection.top);

        // move upper bar, keep width, move lower bar
        selection.left = selection.left + change.x;
        selection.left = Math.max(this.canvas.left, selection.left);
        selection.left = Math.min((this.canvas.left + this.canvas.width) - baseSelection.width, selection.left);

        return selection;
    };


    ImageSelection.prototype.destroyUI = function () {
        $(window).off(EVENT.RESIZE);

        if (this.$holder !== undefined) {
            this.$holder.off(EVENT.CLICK);
            this.$holder.remove();
        }

        delete this.$holder;
        delete this.$backdrop;
        delete this.$selection;
        delete this.previousSelection;
    };

    ImageSelection.prototype.open = function (options) {
        options = options || {};

        if (this.opened) {
            this.destroyUI();
        }

        this.init(options);
        this.buildUI();

        this.opened = true;
    };

    // Hide/Close the plugin, but keep it available for future use
    ImageSelection.prototype.close = function () {
        if (this.opened) {
            this.destroyUI();
            this.opened = false;
            this.$element.trigger(EVENT.CLOSE, this);
        }
    };

    // Permanentely remove the plugin
    ImageSelection.prototype.destroy = function () {
        this.close();
        this.$element.data('image-select', null);
    };

    ImageSelection.prototype.getSelection = function () {
        return {
            // corner coordinates
            top         : this.selection.top,
            left        : this.selection.left,

            // dimensions
            width       : this.selection.width,
            height      : this.selection.height
        };
    };

    var ctor = function (options) {
        options = options || {};
        this.each(function () {
            var el = $(this), instance = el.data('image-select');

            if (options.call) {
                if (instance) {
                    instance[options.call].call(instance, options);
                }
            }
            else if (!instance) {
                instance = new ImageSelection(el, options);
                el.data('image-select', instance);
            }
            else {
                instance.open(options);
            }
        });

        if (options && options.instance) {
            return this.eq(0).data('image-select');
        }
        else {
            return this;
        }
    };

    ctor.moveSelectionIntoCanvas = moveSelectionIntoCanvas;

    return ctor;
})(jQuery);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* jshint eqeqeq: true, immed: true, latedef: true, newcap: true, noarg: true,
          sub: true, undef: true, boss: true, eqnull: true, browser: true,
          smarttabs: true */
/* global jQuery */
jQuery.fn.imageSelectPolygon = (function ($) {
    'use strict';

    var EVENT = {
        NAMESPACE : '.imageSelect'
    };

    // Events that are consumed
    EVENT.CLICK  = 'click'              + EVENT.NAMESPACE;
    EVENT.RESIZE = 'resize'             + EVENT.NAMESPACE;

    EVENT.MOUSEDOWN = 'touchstart'  + EVENT.NAMESPACE + ' ' +
                      'mousedown'   + EVENT.NAMESPACE;
    EVENT.MOUSEUP   = 'touchend'    + EVENT.NAMESPACE + ' ' +
                      'touchcancel' + EVENT.NAMESPACE + ' ' +
                      'mouseup'     + EVENT.NAMESPACE;
    EVENT.MOUSEMOVE = 'touchmove'   + EVENT.NAMESPACE + ' ' +
                      'mousemove'   + EVENT.NAMESPACE;

    // Events that are emitted
    EVENT.OPEN   = 'open';
    EVENT.CLOSE  = 'close';
    EVENT.UPDATE = 'update';
    EVENT.SECOND_CLICK = 'second_click';
    EVENT.DESELECT_CLICK = 'deselect_click';

    var IGNORE_EMULATED_CLICKS_TIME_MS = 20;

    var SELECTION_BORDER = 2, // see CSS rule .image-select-selection
        UPDATE_INTERVAL = 50,
        SUPPORTED_SHAPES = ['polygon'];


    var isN = function (n) {
        return !isNaN(n);
    };

    var preventDefaultAndPropagation = function (e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
    };

    /**
     * Gets page coordinates of event. Touch event coordinates returned if available.
     * @param {Object} e the event
     * @returns {{x: (Number), y: (Number)}} Page coordinates X and Y
     * @private
     */
    var _getEventCoordinates = function (e) {
        if (e.originalEvent.touches) {
            return { x : e.originalEvent.touches[0].pageX, y : e.originalEvent.touches[0].pageY };
        }
        else {
            return { x : e.pageX, y : e.pageY };
        }
    };

    /**
     * Copied from jquery-image-select.js - to make this independent of the other.
     */
    var moveSelectionIntoCanvas = function (selection, canvas, min, aspectRatio) {
        // Reduce dimension to be smaller or equal to canvas dimensions
        selection.width  = Math.min(canvas.width, selection.width);
        selection.height = Math.min(canvas.height, selection.height);

        if (typeof(min) !== 'undefined') {
          selection.width = Math.max(min.width, selection.width);
          selection.height = Math.max(min.height, selection.height);
        }

        // Fix aspect ratio
        if (typeof(aspectRatio) !== 'undefined' && aspectRatio !== 0) {
            if (selection.height > Math.round(selection.width * aspectRatio)) {
                selection.height = Math.floor(selection.width * aspectRatio);
            }
            else {
                selection.width = Math.floor(selection.height / aspectRatio);
            }
        }

        // Move selection away from edge, until it is inside canvas
        selection.left = Math.max(canvas.left, selection.left);
        selection.left = Math.min(canvas.left + canvas.width - selection.width,
                                  selection.left);
        selection.top = Math.max(canvas.top, selection.top);
        selection.top = Math.min(canvas.top + canvas.height - selection.height,
                                 selection.top);

        return selection;
    };

    // matrix may contain scientific floats on chrome, which chrome doesn't accept, example: 'matrix(6.12323399573677e-17, 1, -1, 6.12323399573677e-17, 0, 0)'
    var MATRIX   = /matrix\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 6 numbers
        MATRIX3D = /matrix3d\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\)/, // 16 numbers
        i = function (s) {
          var number = parseFloat(s);
          if (isNaN(number)) {
            throw new Error('Number is not a float');
          }
          return Math.round(number);
        };

    var get2by2MatrixFromElement = function (element) {
        var matrixStr = $(element).css('transform'),
            match;

        try {
          match = matrixStr.match(MATRIX);
          if (match) {
              /**
               * TODO: Find out why this is not the way, I would expect it to be.
               *
               * Based on documentation and my understanding, the matrix should be
               *
               *     i(match[1]) i(match[3])
               *     i(match[2]) i(match[4])
               *
               * This would also be similar to the 3d version below.
               *
               * BUT, it does not yield the expected results. Instead the
               * following one works just as desired. Therefore I am using that
               * one -- although I do not know why.
               */
              return [
                  [i(match[1]), i(match[2])],
                  [i(match[3]), i(match[4])]
              ];
          }

          match = matrixStr.match(MATRIX3D);
          if (match) {
              return [
                  [i(match[1]), i(match[5])],
                  [i(match[2]), i(match[6])]
              ];
          }
          else if (matrixStr === 'none') {
              return [
                  [1, 0],
                  [0, 1]
              ];
          }
        } catch (e) {
          // logged below
        }

        if (window.console && window.console.log) {
            window.console.log('ImageEditor: Could not parse matrix string', matrixStr);
        }

        return [
            [1, 0],
            [0, 1]
        ];
    };
    var applyMatrixToCoordinates = function (matrix, point) {
        if (matrix.length !== 2 ||
            matrix[0].length !== 2 ||
            matrix[1].length !== 2) {
            throw new Error('Expecting 2x2 matrix');
        }
        if (point.x === undefined || point.y === undefined) {
            throw new Error('Expecting point to be object like {x: 0, y: 0}');
        }

        return $.extend({}, point, {
            x : point.x * matrix[0][0] + point.y * matrix[0][1],
            y : point.x * matrix[1][0] + point.y * matrix[1][1]
        });
    };
    // chrome returns currently (v38) scientific notation for very small numbers, but doesn't accept it. So nullify this.
    var normalizeMatrixForChrome = function (matrixStr) {
      try {
        var outerMatch = matrixStr.match(/matrix\(([^)]+)\)/);
        if (outerMatch) {
          var inner = outerMatch[1];
          var numbers = inner.split(/, ?/);
          var normalizedNumbers = [];
          for (var i = 0; i < numbers.length; i++) {
            var current = numbers[i];
            if (current.indexOf('e') > -1 || current.indexOf('E') > -1) {
              var parsed = parseFloat(current);
              if (isNaN(parsed)) {
                throw new Error('Not a number: \'' + current + '\'');
              }

              normalizedNumbers.push('' + parsed.toFixed(19)); // toFixed limited to 20

            } else {
              normalizedNumbers.push(current);
            }
          }
          return 'matrix(' + normalizedNumbers.join(', ') + ')';
        }

      } catch (e) {
        // ignored
      }

      return matrixStr;
    };


    var ImageSelection = function ($element, options) {
        this.$element = $element;

        this.open(options);
    };

    ImageSelection.prototype.defaults = {
        classPrefix : 'image-select-', // {String} The prefix for css classes applied to UI elements.
        parent      : null,            // {Mixed} parent element to append UI controls to. jQuery Object, selector or HTMLElement. Otherwise, adds controls after element.
        min         : 40,              // {Number} Minimum width/height of selection
        points      : []               // {Array} of {w:int, h:int} for the polygon
    };

    ImageSelection.prototype.init = function (options) {
        this._ignoreHolderClickUntil = null;
        this.distanceFromLineForAddPointDetection = 10;
        this.options = $.extend({}, this.defaults, options);

        this.matrix = get2by2MatrixFromElement(this.$element);

        this.canvas = this.options.canvas || this.canvas || {
            top    : 0,
            left   : 0,
            width  : this.$element.width(),
            height : this.$element.height()
        };

        this.readSelectionFromOptions();

    };

    ImageSelection.prototype.readSelectionFromOptions = function () {
        if ($.inArray(this.options.shape, SUPPORTED_SHAPES) === -1) {
            this.shape = SUPPORTED_SHAPES[0];
        }
        else {
            this.shape = this.options.shape;
        }

        var points = this.readPoints(this.options.points);

        if (points && points.length) {
            this.points = points;
        }
        else {
            this.points = this.points || [
              {
                w: this.canvas.left + Math.round(this.canvas.width*0.5),
                h: this.canvas.top + Math.round(this.canvas.height*1.0/3)
              },
              {
                w: this.canvas.left + Math.round(this.canvas.width*2.0/3),
                h: this.canvas.top + Math.round(this.canvas.height*2.0/3)
              },
              {
                w: this.canvas.left + Math.round(this.canvas.width*1.0/3),
                h: this.canvas.top + Math.round(this.canvas.height*2.0/3)
              }
            ];
        }
    };

    ImageSelection.prototype.readPoints = function (rawPoints) {
      var result = [], i, point, parsed;

      if (rawPoints && rawPoints.length) {
        for (i = 0; i < rawPoints.length; i++) {
          point = rawPoints[i];
          if (isN(point.w) && isN(point.h)) {
            parsed = {
              w: parseInt(point.w, 10),
              h: parseInt(point.h, 10)
            };
            result.push(parsed);
          }
        }
      }
      return result;
    };

    ImageSelection.prototype.cssClass = function (name) {
        return this.options.classPrefix + name;
    };

    ImageSelection.prototype.createDiv = function (name) {
        return $('<div>').addClass(this.cssClass(name));
    };

    ImageSelection.prototype.buildUI = function () {
        var self = this,
          helperGhost = this.createDiv('polygon-helper').css({
          });

        this.$holder = this.createDiv('holder').css({
            width  : this.$element.width(),
            height : this.$element.height()
        }).addClass(this.cssClass(this.shape));

        // ghost used to get certain css values/colors used during canvas painting
        this.$holder.append(helperGhost);

        this.$drawCanvas = $('<canvas/>').css({
            width  : this.canvas.width + 'px',
            height : this.canvas.height + 'px',
            top    : this.canvas.top,
            left   : this.canvas.left
        });
        this.$drawCanvas[0].height = this.canvas.height;
        this.$drawCanvas[0].width = this.canvas.width;
        this.$holder.append(this.$drawCanvas);
        this.polygonTool = this.$drawCanvas.polygon().data('polygon');


        this.movePolygonIntoCanvas();
        this.updateUI(false);

        if (this.options.parent) {
            $(this.options.parent).append(this.$holder);
        }
        else {
            this.$element.after(this.$holder);
        }

        // install listeners after attachment to DOM
        this.handleDragging(this.$drawCanvas, function (change, basePoints) {
          self.updatePoints(change, basePoints);
        });

        this.$holder.on('click', function (e) {
          if (self._ignoreHolderClickUntil && new Date().getTime() <= self._ignoreHolderClickUntil) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            self._ignoreHolderClickUntil = null;
          }
        });

        this.repositionUI();
        if (this.options.applyTransformations) {
            this.applyTransformationsToUI();
        }

        this.$element.trigger(EVENT.OPEN, this);

        $(window).on(EVENT.RESIZE, this, this.repositionUI);
    };

    ImageSelection.prototype.repositionUI = function (e) {
        var self = e ? e.data : this;

        self.$holder.position({of: self.$element, at: 'center', my: 'center'});
    };

    ImageSelection.prototype.applyTransformationsToUI = function (e) {
        var normalizedTransform = normalizeMatrixForChrome(this.$element.css('transform'));
        this.$holder.css({
            'transform'         : normalizedTransform,
            '-webkit-transform' : normalizedTransform
        });

        // Apply margin to position correctly on rotated images
        if (applyMatrixToCoordinates(this.matrix, {x: 1, y: 0}).x === 0) {

            var diff = (this.$element.width() - this.$element.height()) / 2;

            this.$holder.css({
                'margin-top'    : + diff,
                'margin-right'  : - diff,
                'margin-bottom' : + diff,
                'margin-left'   : - diff
            });
        }
    };

    ImageSelection.prototype.ensureSelectionIsInReasonableBounds = function (selection) {
        selection.width  = Math.max(this.min.width, selection.width);
        selection.width  = Math.min(this.canvas.width, selection.width);

        selection.height = Math.max(this.min.height, selection.height);
        selection.height = Math.min(this.canvas.height, selection.height);

        selection.top    = Math.max(this.canvas.top, selection.top);
        selection.top    = Math.min((this.canvas.top + this.canvas.height) - selection.height, selection.top);

        selection.left   = Math.max(this.canvas.left, selection.left);
        selection.left   = Math.min((this.canvas.left + this.canvas.width) - selection.width, selection.left);
    };

    ImageSelection.prototype.updateUI = function (notify) {
      if (!this.$holder) {
        // happens on IE9, ui already gone
        return;
      }
      var self = this, i, notifyCopy = notify,
        $polygonHelper = this.$holder.find('.' + this.cssClass('polygon-helper')),
        borderWidthCss = $polygonHelper.css('border-top-width'), borderWidth = null;
      // TODO update the other parts of the UI (before backdrop border was resized here)

      borderWidth = $('<div/>', {width: borderWidthCss}).width(); // conversion: .width() always returns pixel value

      var polygonOptions = {
        strokeStyle: $polygonHelper.css('border-top-color'),
        fillStyle: $polygonHelper.css('background-color'),
        lineWidth: borderWidth
      };

      if (borderWidth == null || borderWidth < 1) {
        // need a re-update, elements not yet styled, so attach them safely to DOM first
        notify = false;
        setTimeout(function () {
          self.updateUI(notifyCopy);
        }, 10);
      }

      this.polygonTool.clearCanvas();
      this.polygonTool.paintPolygonWithPoints(this.$drawCanvas, this.points, polygonOptions);

      // only repaint handles if necessary - important to allow dragging to work
      if (this.points.length !== this.getAllHandles().length) {
        this.removeAllHandles();
        if (this.points && this.points.length) {
          for (i = 0; i < this.points.length; i++) {
            this.createHandle(i);
          }
        }
      }

      if (notify !== false) {
          // Notify consumers about our updated selection
          // FIXME send complete shape selection with getSelection()
          this.$element.trigger(EVENT.UPDATE, this.points);
      }
    };

    ImageSelection.prototype.createHandle = function (pointIndex) {
        var handle, self = this,
          originalPoint = this.points[pointIndex];

        handle = this.createDiv('handle').css({top: originalPoint.h, left: originalPoint.w});

        this.$holder.append(handle);
        this.handleDragging(handle, function (change, basePoints) {
          self.updatePoint(change, basePoints, pointIndex);
        });
    };

    ImageSelection.prototype.removeAllHandles = function () {
        this.getAllHandles().remove();
    };

    ImageSelection.prototype.getAllHandles = function () {
      return this.$holder.find('.' + this.cssClass('handle'));
    };

    ImageSelection.prototype.isHandleOrHasHandleParent = function (el) {
      var cssClass = this.cssClass('handle'),
        $el = $(el);
      return $el.hasClass(cssClass) ||
        $el.parents('.' + cssClass).length > 0;
    };

    ImageSelection.prototype.handleDragging = function (element, handler) {
        var self = this;

        element.on(EVENT.MOUSEDOWN, function (e) {
            if (e.which !== 1 /* LEFT CLICK */ && e.which !== 0 /* TOUCH */) {
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            var memo = {},
                baseEventCoords = _getEventCoordinates(e),
                basePoints = self.points.slice(),
                isStartedOnHandle = self.isHandleOrHasHandleParent(e.target),
                isStartedOnPolygon = self.isPageCoordsOnPolygon(baseEventCoords);

            if (isStartedOnHandle || isStartedOnPolygon) {
              $('body')
                .on(EVENT.MOUSEMOVE, function (e) {
                    // prevent default - mainly to avoid scroll, which would happen
                    // on touch devices
                    e.preventDefault();

                    var currEventCoords = _getEventCoordinates(e);

                    memo.x = currEventCoords.x - baseEventCoords.x;
                    memo.y = currEventCoords.y - baseEventCoords.y;

                    // Use timeout to avoid too many UI updates
                    if (!memo.timeout) {
                        memo.timeout = setTimeout(function () {
                            delete memo.timeout;
                            memo.moved = true;
                            self.handleDrag(
                                applyMatrixToCoordinates(self.matrix, memo),
                                basePoints,
                                handler);
                        }, UPDATE_INTERVAL);
                    }
                });
            }
            $('body')
                .one(EVENT.MOUSEUP, function (e) {
                    var closestLineSegmentResult;
                    $(this).off(EVENT.MOUSEMOVE)
                      // .one only to show intention. That alone doesn't work on touch devices because touch
                      // and mouse events are triggered and one will only delete one of them, leading to more than one execution.
                      // (mind that EVENT.MOUSEUP references more than one event. See definition).
                      .off(EVENT.MOUSEUP);

                    // ios has no pageX/Y on touchend
                    if (typeof(e.pageX) === 'undefined') {
                      e.pageX = baseEventCoords.x;
                      e.pageY = baseEventCoords.y;
                    }

                    self.showAllHandles();

                    if (!memo.moved) {
                      if (isStartedOnHandle) {
                        self.$element.trigger(EVENT.SECOND_CLICK, self);
                      } else {
                        closestLineSegmentResult = self.getClosestLineSegmentResult(self.pageToRelative(e.pageX, e.pageY));
                        if (closestLineSegmentResult && closestLineSegmentResult.distance < self.distanceFromLineForAddPointDetection) {
                          self.addPoint(closestLineSegmentResult.projection, closestLineSegmentResult.line);
                          self.updateUI();
                        } else {
                          if (isStartedOnPolygon) {
                            self.$element.trigger(EVENT.SECOND_CLICK, self);
                          } else {
                            self.$element.trigger($.Event(EVENT.DESELECT_CLICK, {
                              originalEvent: e,
                              pageX: e.pageX,
                              pageY: e.pageY
                            }));
                          }
                        }
                      }
                    }

                    // cannot prevent generation/emulation of click event (on chrome, safari), so:
                    self._ignoreHolderClickUntil = new Date().getTime() + IGNORE_EMULATED_CLICKS_TIME_MS;
                });

            self.hideOtherHandles(element);
        });
    };

    ImageSelection.prototype.hideOtherHandles = function (handle) {
        this.$holder.find('.' + this.cssClass('handle')).
                        not(handle).addClass(this.cssClass('handle-other'));

        handle.addClass(this.cssClass('handle-selected'));
    };

    ImageSelection.prototype.showAllHandles = function () {
        this.$holder.find('.' + this.cssClass('handle')).
                        removeClass(this.cssClass('handle-other')).
                        removeClass(this.cssClass('handle-selected'));
    };

    ImageSelection.prototype.handleDrag = function (change, basePoints, handler) {
        handler.call(this, change, basePoints);

        this.updateUI();
    };

    ImageSelection.prototype.pageToRelative = function (pageX, pageY) {
      var holderOffset = this.$holder.offset();

      return {
        w: pageX - holderOffset.left,
          h: pageY - holderOffset.top
      };
    };

    ImageSelection.prototype.vectorToPoint = function (pointAsVector) {
      return {
        w: pointAsVector[0],
        h: pointAsVector[1]
      };
    };

    ImageSelection.prototype.addPoint = function (pointAsVector, lineSegmentAsVectors) {
      var i, current, newPointPosition = null, next, previous,
        vectors = this.polygonTool.pointsToVectors(this.points),
        newPoint = this.vectorToPoint(pointAsVector) ;

      if (this.points.length < 2) {
        this.points.push(newPoint);
        return;
      }
      if (!lineSegmentAsVectors) {
        this.points.push(newPoint);
        return;
      }

      for (i = 0; i < vectors.length; i++) {
        current = vectors[i];
        if (this.polygonTool.vectorsEqual(current, lineSegmentAsVectors[0])) {

          // now it's either previous or next
          if (i === vectors.length - 1) {
            next = 0;
          } else {
            next = i + 1;
          }
          if (this.polygonTool.vectorsEqual(vectors[next], lineSegmentAsVectors[1])) {
            newPointPosition = next;
            break;
          }

          if (i === 0) {
            previous = vectors.length - 1;
          } else {
            previous = i - 1;
          }
          if (this.polygonTool.vectorsEqual(vectors[previous], lineSegmentAsVectors[1])) {
            newPointPosition = previous;
            break;
          }
        }
      }

      if (newPointPosition == null) {
        this.points.push(newPoint);
      } else {
        this.points.splice(next, 0, newPoint);
      }
    };

    ImageSelection.prototype.updatePoints = function (change, basePoints) {
      var i;
      for (i = 0; i<basePoints.length; i++) {
        this.updatePoint(change, basePoints, i);
      }
    };

    ImageSelection.prototype.updatePoint = function (change, basePoints, pointIndex) {
      var canvasPos = this.$drawCanvas.position(), point = basePoints[pointIndex],
        handle;

      if (point) {
        point = {
          w: Math.round(point.w + change.x),
          h: Math.round(point.h + change.y)
        };
        point.h = Math.max(canvasPos.top, point.h);
        point.h = Math.min(canvasPos.top + this.$drawCanvas.height(), point.h);
        point.w = Math.max(canvasPos.left, point.w);
        point.w = Math.min(canvasPos.left + this.$drawCanvas.width(), point.w);
        this.points[pointIndex] = point;

        handle = $(this.getAllHandles()[pointIndex]);
        handle.css({top: point.h, left: point.w});
      }
      return point;
    };

    ImageSelection.prototype.destroyUI = function () {
        $(window).off(EVENT.RESIZE);

        if (this.$holder !== undefined) {
            this.$holder.off(EVENT.CLICK);
            this.$holder.remove();
        }

        delete this.$holder;
        delete this.$drawCanvas;
        delete this.$selection;
    };

    ImageSelection.prototype.open = function (options) {
        options = options || {};

        if (this.opened) {
            this.destroyUI();
        }

        this.init(options);
        this.buildUI();

        this.opened = true;
    };

    // Hide/Close the plugin, but keep it available for future use
    ImageSelection.prototype.close = function () {
        if (this.opened) {
            this.destroyUI();
            this.opened = false;
            this.$element.trigger(EVENT.CLOSE, this);
        }
    };

    // Permanentely remove the plugin
    ImageSelection.prototype.destroy = function () {
        this.close();
        this.$element.data('image-select', null);
    };

    ImageSelection.prototype.getPoints = function () {
        return this.points.slice();
    };

    ImageSelection.prototype.getClosestLineSegmentResult = function (p) {
      var pAsVector = this.polygonTool.pointsToVectors(p),
        sortedSegments = this.polygonTool.filterLineSegmentsNextToPointAndSortByDistance(pAsVector,
        this.polygonTool.pointsToLineSegmentsWithVectors(this.points));

      if (sortedSegments.length) {
        return sortedSegments[0];
      }
      return null;
    };

    ImageSelection.prototype.isPageCoordsOnPolygon = function (point) {
      var holderRelativeCoords;
      if (typeof(point.x) !== 'undefined') {
        point = {
          w: point.x,
          h: point.y
        };
      }

      holderRelativeCoords = this.pageToRelative(point.w, point.h);

      return this.polygonTool.isPointInsideOrOnEdgeOfPolygon([holderRelativeCoords.w, holderRelativeCoords.h],
        this.polygonTool.pointsToVectors(this.points));
    };

    ImageSelection.prototype.getBoundingBox = function () {
      return this.polygonTool.getBoundingBox(this.points);
    };

    /**
     * Goal is to strive to keep the form of the polygon intact.
     * @returns {*}
     */
    ImageSelection.prototype.movePolygonIntoCanvas = function () {
      var boundingBox = this.polygonTool.getBoundingBox(this.points),
        movedBoundingBox = moveSelectionIntoCanvas($.extend({}, boundingBox), this.canvas),
        moveOffset = {
          left: movedBoundingBox.left - boundingBox.left,
          top: movedBoundingBox.top - boundingBox.top
        },
        scaleFactors = {
          width: movedBoundingBox.width/boundingBox.width,
          height: movedBoundingBox.height/boundingBox.height
        },
        i, point;

      for (i = 0; i < this.points.length; i++) {
        point = this.points[i];
        // Move polygon into canvas
        point.w = point.w + moveOffset.left;
        point.h = point.h + moveOffset.top;

        // scale it to fit
        point.w = movedBoundingBox.left + (point.w - movedBoundingBox.left)*scaleFactors.width;
        point.h = movedBoundingBox.top + (point.h - movedBoundingBox.top)*scaleFactors.height
      }

    };

    var ctor = function (options) {
        options = options || {};
        this.each(function () {
            var el = $(this), instance = el.data('image-select');

            if (options.call) {
                if (instance) {
                    instance[options.call].call(instance, options);
                }
            }
            else if (!instance) {
                instance = new ImageSelection(el, options);
                el.data('image-select', instance);
            }
            else {
                instance.open(options);
            }
        });

        if (options && options.instance) {
            return this.eq(0).data('image-select');
        }
        else {
            return this;
        }
    };

    return ctor;
})(jQuery);

/*

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

// lib/handlebars/browser-prefix.js
var Handlebars = {};

(function(Handlebars, undefined) {
;
// lib/handlebars/base.js

Handlebars.VERSION = "1.0.0";
Handlebars.COMPILER_REVISION = 4;

Handlebars.REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};

Handlebars.helpers  = {};
Handlebars.partials = {};

var toString = Object.prototype.toString,
    functionType = '[object Function]',
    objectType = '[object Object]';

Handlebars.registerHelper = function(name, fn, inverse) {
  if (toString.call(name) === objectType) {
    if (inverse || fn) { throw new Handlebars.Exception('Arg not supported with multiple helpers'); }
    Handlebars.Utils.extend(this.helpers, name);
  } else {
    if (inverse) { fn.not = inverse; }
    this.helpers[name] = fn;
  }
};

Handlebars.registerPartial = function(name, str) {
  if (toString.call(name) === objectType) {
    Handlebars.Utils.extend(this.partials,  name);
  } else {
    this.partials[name] = str;
  }
};

Handlebars.registerHelper('helperMissing', function(arg) {
  if(arguments.length === 2) {
    return undefined;
  } else {
    throw new Error("Missing helper: '" + arg + "'");
  }
});

Handlebars.registerHelper('blockHelperMissing', function(context, options) {
  var inverse = options.inverse || function() {}, fn = options.fn;

  var type = toString.call(context);

  if(type === functionType) { context = context.call(this); }

  if(context === true) {
    return fn(this);
  } else if(context === false || context == null) {
    return inverse(this);
  } else if(type === "[object Array]") {
    if(context.length > 0) {
      return Handlebars.helpers.each(context, options);
    } else {
      return inverse(this);
    }
  } else {
    return fn(context);
  }
});

Handlebars.K = function() {};

Handlebars.createFrame = Object.create || function(object) {
  Handlebars.K.prototype = object;
  var obj = new Handlebars.K();
  Handlebars.K.prototype = null;
  return obj;
};

Handlebars.logger = {
  DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, level: 3,

  methodMap: {0: 'debug', 1: 'info', 2: 'warn', 3: 'error'},

  // can be overridden in the host environment
  log: function(level, obj) {
    if (Handlebars.logger.level <= level) {
      var method = Handlebars.logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};

Handlebars.log = function(level, obj) { Handlebars.logger.log(level, obj); };

Handlebars.registerHelper('each', function(context, options) {
  var fn = options.fn, inverse = options.inverse;
  var i = 0, ret = "", data;

  var type = toString.call(context);
  if(type === functionType) { context = context.call(this); }

  if (options.data) {
    data = Handlebars.createFrame(options.data);
  }

  if(context && typeof context === 'object') {
    if(context instanceof Array){
      for(var j = context.length; i<j; i++) {
        if (data) { data.index = i; }
        ret = ret + fn(context[i], { data: data });
      }
    } else {
      for(var key in context) {
        if(context.hasOwnProperty(key)) {
          if(data) { data.key = key; }
          ret = ret + fn(context[key], {data: data});
          i++;
        }
      }
    }
  }

  if(i === 0){
    ret = inverse(this);
  }

  return ret;
});

Handlebars.registerHelper('if', function(conditional, options) {
  var type = toString.call(conditional);
  if(type === functionType) { conditional = conditional.call(this); }

  if(!conditional || Handlebars.Utils.isEmpty(conditional)) {
    return options.inverse(this);
  } else {
    return options.fn(this);
  }
});

Handlebars.registerHelper('unless', function(conditional, options) {
  return Handlebars.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn});
});

Handlebars.registerHelper('with', function(context, options) {
  var type = toString.call(context);
  if(type === functionType) { context = context.call(this); }

  if (!Handlebars.Utils.isEmpty(context)) return options.fn(context);
});

Handlebars.registerHelper('log', function(context, options) {
  var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
  Handlebars.log(level, context);
});
;
// lib/handlebars/compiler/parser.js
/* Jison generated parser */
var handlebars = (function(){
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"root":3,"program":4,"EOF":5,"simpleInverse":6,"statements":7,"statement":8,"openInverse":9,"closeBlock":10,"openBlock":11,"mustache":12,"partial":13,"CONTENT":14,"COMMENT":15,"OPEN_BLOCK":16,"inMustache":17,"CLOSE":18,"OPEN_INVERSE":19,"OPEN_ENDBLOCK":20,"path":21,"OPEN":22,"OPEN_UNESCAPED":23,"CLOSE_UNESCAPED":24,"OPEN_PARTIAL":25,"partialName":26,"params":27,"hash":28,"dataName":29,"param":30,"STRING":31,"INTEGER":32,"BOOLEAN":33,"hashSegments":34,"hashSegment":35,"ID":36,"EQUALS":37,"DATA":38,"pathSegments":39,"SEP":40,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",14:"CONTENT",15:"COMMENT",16:"OPEN_BLOCK",18:"CLOSE",19:"OPEN_INVERSE",20:"OPEN_ENDBLOCK",22:"OPEN",23:"OPEN_UNESCAPED",24:"CLOSE_UNESCAPED",25:"OPEN_PARTIAL",31:"STRING",32:"INTEGER",33:"BOOLEAN",36:"ID",37:"EQUALS",38:"DATA",40:"SEP"},
productions_: [0,[3,2],[4,2],[4,3],[4,2],[4,1],[4,1],[4,0],[7,1],[7,2],[8,3],[8,3],[8,1],[8,1],[8,1],[8,1],[11,3],[9,3],[10,3],[12,3],[12,3],[13,3],[13,4],[6,2],[17,3],[17,2],[17,2],[17,1],[17,1],[27,2],[27,1],[30,1],[30,1],[30,1],[30,1],[30,1],[28,1],[34,2],[34,1],[35,3],[35,3],[35,3],[35,3],[35,3],[26,1],[26,1],[26,1],[29,2],[21,1],[39,3],[39,1]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1: return $$[$0-1];
break;
case 2: this.$ = new yy.ProgramNode([], $$[$0]);
break;
case 3: this.$ = new yy.ProgramNode($$[$0-2], $$[$0]);
break;
case 4: this.$ = new yy.ProgramNode($$[$0-1], []);
break;
case 5: this.$ = new yy.ProgramNode($$[$0]);
break;
case 6: this.$ = new yy.ProgramNode([], []);
break;
case 7: this.$ = new yy.ProgramNode([]);
break;
case 8: this.$ = [$$[$0]];
break;
case 9: $$[$0-1].push($$[$0]); this.$ = $$[$0-1];
break;
case 10: this.$ = new yy.BlockNode($$[$0-2], $$[$0-1].inverse, $$[$0-1], $$[$0]);
break;
case 11: this.$ = new yy.BlockNode($$[$0-2], $$[$0-1], $$[$0-1].inverse, $$[$0]);
break;
case 12: this.$ = $$[$0];
break;
case 13: this.$ = $$[$0];
break;
case 14: this.$ = new yy.ContentNode($$[$0]);
break;
case 15: this.$ = new yy.CommentNode($$[$0]);
break;
case 16: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]);
break;
case 17: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]);
break;
case 18: this.$ = $$[$0-1];
break;
case 19:
    // Parsing out the '&' escape token at this level saves ~500 bytes after min due to the removal of one parser node.
    this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1], $$[$0-2][2] === '&');

break;
case 20: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1], true);
break;
case 21: this.$ = new yy.PartialNode($$[$0-1]);
break;
case 22: this.$ = new yy.PartialNode($$[$0-2], $$[$0-1]);
break;
case 23:
break;
case 24: this.$ = [[$$[$0-2]].concat($$[$0-1]), $$[$0]];
break;
case 25: this.$ = [[$$[$0-1]].concat($$[$0]), null];
break;
case 26: this.$ = [[$$[$0-1]], $$[$0]];
break;
case 27: this.$ = [[$$[$0]], null];
break;
case 28: this.$ = [[$$[$0]], null];
break;
case 29: $$[$0-1].push($$[$0]); this.$ = $$[$0-1];
break;
case 30: this.$ = [$$[$0]];
break;
case 31: this.$ = $$[$0];
break;
case 32: this.$ = new yy.StringNode($$[$0]);
break;
case 33: this.$ = new yy.IntegerNode($$[$0]);
break;
case 34: this.$ = new yy.BooleanNode($$[$0]);
break;
case 35: this.$ = $$[$0];
break;
case 36: this.$ = new yy.HashNode($$[$0]);
break;
case 37: $$[$0-1].push($$[$0]); this.$ = $$[$0-1];
break;
case 38: this.$ = [$$[$0]];
break;
case 39: this.$ = [$$[$0-2], $$[$0]];
break;
case 40: this.$ = [$$[$0-2], new yy.StringNode($$[$0])];
break;
case 41: this.$ = [$$[$0-2], new yy.IntegerNode($$[$0])];
break;
case 42: this.$ = [$$[$0-2], new yy.BooleanNode($$[$0])];
break;
case 43: this.$ = [$$[$0-2], $$[$0]];
break;
case 44: this.$ = new yy.PartialNameNode($$[$0]);
break;
case 45: this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0]));
break;
case 46: this.$ = new yy.PartialNameNode(new yy.IntegerNode($$[$0]));
break;
case 47: this.$ = new yy.DataNode($$[$0]);
break;
case 48: this.$ = new yy.IdNode($$[$0]);
break;
case 49: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2];
break;
case 50: this.$ = [{part: $$[$0]}];
break;
}
},
table: [{3:1,4:2,5:[2,7],6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],22:[1,14],23:[1,15],25:[1,16]},{1:[3]},{5:[1,17]},{5:[2,6],7:18,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,6],22:[1,14],23:[1,15],25:[1,16]},{5:[2,5],6:20,8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,5],22:[1,14],23:[1,15],25:[1,16]},{17:23,18:[1,22],21:24,29:25,36:[1,28],38:[1,27],39:26},{5:[2,8],14:[2,8],15:[2,8],16:[2,8],19:[2,8],20:[2,8],22:[2,8],23:[2,8],25:[2,8]},{4:29,6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,7],22:[1,14],23:[1,15],25:[1,16]},{4:30,6:3,7:4,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,5],20:[2,7],22:[1,14],23:[1,15],25:[1,16]},{5:[2,12],14:[2,12],15:[2,12],16:[2,12],19:[2,12],20:[2,12],22:[2,12],23:[2,12],25:[2,12]},{5:[2,13],14:[2,13],15:[2,13],16:[2,13],19:[2,13],20:[2,13],22:[2,13],23:[2,13],25:[2,13]},{5:[2,14],14:[2,14],15:[2,14],16:[2,14],19:[2,14],20:[2,14],22:[2,14],23:[2,14],25:[2,14]},{5:[2,15],14:[2,15],15:[2,15],16:[2,15],19:[2,15],20:[2,15],22:[2,15],23:[2,15],25:[2,15]},{17:31,21:24,29:25,36:[1,28],38:[1,27],39:26},{17:32,21:24,29:25,36:[1,28],38:[1,27],39:26},{17:33,21:24,29:25,36:[1,28],38:[1,27],39:26},{21:35,26:34,31:[1,36],32:[1,37],36:[1,28],39:26},{1:[2,1]},{5:[2,2],8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,2],22:[1,14],23:[1,15],25:[1,16]},{17:23,21:24,29:25,36:[1,28],38:[1,27],39:26},{5:[2,4],7:38,8:6,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,4],22:[1,14],23:[1,15],25:[1,16]},{5:[2,9],14:[2,9],15:[2,9],16:[2,9],19:[2,9],20:[2,9],22:[2,9],23:[2,9],25:[2,9]},{5:[2,23],14:[2,23],15:[2,23],16:[2,23],19:[2,23],20:[2,23],22:[2,23],23:[2,23],25:[2,23]},{18:[1,39]},{18:[2,27],21:44,24:[2,27],27:40,28:41,29:48,30:42,31:[1,45],32:[1,46],33:[1,47],34:43,35:49,36:[1,50],38:[1,27],39:26},{18:[2,28],24:[2,28]},{18:[2,48],24:[2,48],31:[2,48],32:[2,48],33:[2,48],36:[2,48],38:[2,48],40:[1,51]},{21:52,36:[1,28],39:26},{18:[2,50],24:[2,50],31:[2,50],32:[2,50],33:[2,50],36:[2,50],38:[2,50],40:[2,50]},{10:53,20:[1,54]},{10:55,20:[1,54]},{18:[1,56]},{18:[1,57]},{24:[1,58]},{18:[1,59],21:60,36:[1,28],39:26},{18:[2,44],36:[2,44]},{18:[2,45],36:[2,45]},{18:[2,46],36:[2,46]},{5:[2,3],8:21,9:7,11:8,12:9,13:10,14:[1,11],15:[1,12],16:[1,13],19:[1,19],20:[2,3],22:[1,14],23:[1,15],25:[1,16]},{14:[2,17],15:[2,17],16:[2,17],19:[2,17],20:[2,17],22:[2,17],23:[2,17],25:[2,17]},{18:[2,25],21:44,24:[2,25],28:61,29:48,30:62,31:[1,45],32:[1,46],33:[1,47],34:43,35:49,36:[1,50],38:[1,27],39:26},{18:[2,26],24:[2,26]},{18:[2,30],24:[2,30],31:[2,30],32:[2,30],33:[2,30],36:[2,30],38:[2,30]},{18:[2,36],24:[2,36],35:63,36:[1,64]},{18:[2,31],24:[2,31],31:[2,31],32:[2,31],33:[2,31],36:[2,31],38:[2,31]},{18:[2,32],24:[2,32],31:[2,32],32:[2,32],33:[2,32],36:[2,32],38:[2,32]},{18:[2,33],24:[2,33],31:[2,33],32:[2,33],33:[2,33],36:[2,33],38:[2,33]},{18:[2,34],24:[2,34],31:[2,34],32:[2,34],33:[2,34],36:[2,34],38:[2,34]},{18:[2,35],24:[2,35],31:[2,35],32:[2,35],33:[2,35],36:[2,35],38:[2,35]},{18:[2,38],24:[2,38],36:[2,38]},{18:[2,50],24:[2,50],31:[2,50],32:[2,50],33:[2,50],36:[2,50],37:[1,65],38:[2,50],40:[2,50]},{36:[1,66]},{18:[2,47],24:[2,47],31:[2,47],32:[2,47],33:[2,47],36:[2,47],38:[2,47]},{5:[2,10],14:[2,10],15:[2,10],16:[2,10],19:[2,10],20:[2,10],22:[2,10],23:[2,10],25:[2,10]},{21:67,36:[1,28],39:26},{5:[2,11],14:[2,11],15:[2,11],16:[2,11],19:[2,11],20:[2,11],22:[2,11],23:[2,11],25:[2,11]},{14:[2,16],15:[2,16],16:[2,16],19:[2,16],20:[2,16],22:[2,16],23:[2,16],25:[2,16]},{5:[2,19],14:[2,19],15:[2,19],16:[2,19],19:[2,19],20:[2,19],22:[2,19],23:[2,19],25:[2,19]},{5:[2,20],14:[2,20],15:[2,20],16:[2,20],19:[2,20],20:[2,20],22:[2,20],23:[2,20],25:[2,20]},{5:[2,21],14:[2,21],15:[2,21],16:[2,21],19:[2,21],20:[2,21],22:[2,21],23:[2,21],25:[2,21]},{18:[1,68]},{18:[2,24],24:[2,24]},{18:[2,29],24:[2,29],31:[2,29],32:[2,29],33:[2,29],36:[2,29],38:[2,29]},{18:[2,37],24:[2,37],36:[2,37]},{37:[1,65]},{21:69,29:73,31:[1,70],32:[1,71],33:[1,72],36:[1,28],38:[1,27],39:26},{18:[2,49],24:[2,49],31:[2,49],32:[2,49],33:[2,49],36:[2,49],38:[2,49],40:[2,49]},{18:[1,74]},{5:[2,22],14:[2,22],15:[2,22],16:[2,22],19:[2,22],20:[2,22],22:[2,22],23:[2,22],25:[2,22]},{18:[2,39],24:[2,39],36:[2,39]},{18:[2,40],24:[2,40],36:[2,40]},{18:[2,41],24:[2,41],36:[2,41]},{18:[2,42],24:[2,42],36:[2,42]},{18:[2,43],24:[2,43],36:[2,43]},{5:[2,18],14:[2,18],15:[2,18],16:[2,18],19:[2,18],20:[2,18],22:[2,18],23:[2,18],25:[2,18]}],
defaultActions: {17:[2,1]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    this.yy.parser = this;
    if (typeof this.lexer.yylloc == "undefined")
        this.lexer.yylloc = {};
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);
    var ranges = this.lexer.options && this.lexer.options.ranges;
    if (typeof this.yy.parseError === "function")
        this.parseError = this.yy.parseError;
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    function lex() {
        var token;
        token = self.lexer.lex() || 1;
        if (typeof token !== "number") {
            token = self.symbols_[token] || token;
        }
        return token;
    }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            if (!recovering) {
                expected = [];
                for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                        expected.push("'" + this.terminals_[p] + "'");
                    }
                if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
            }
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                    recovering--;
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
            if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
            if (typeof r !== "undefined") {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}
};
/* Jison generated lexer */
var lexer = (function(){
var lexer = ({EOF:1,
parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },
setInput:function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
        if (this.options.ranges) this.yylloc.range = [0,0];
        this.offset = 0;
        return this;
    },
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) this.yylloc.range[1]++;

        this._input = this._input.slice(1);
        return ch;
    },
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length-1);
        this.matched = this.matched.substr(0, this.matched.length-1);

        if (lines.length-1) this.yylineno -= lines.length-1;
        var r = this.yylloc.range;

        this.yylloc = {first_line: this.yylloc.first_line,
          last_line: this.yylineno+1,
          first_column: this.yylloc.first_column,
          last_column: lines ?
              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
              this.yylloc.first_column - len
          };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        return this;
    },
more:function () {
        this._more = true;
        return this;
    },
less:function (n) {
        this.unput(this.match.slice(n));
    },
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
    },
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c+"^";
    },
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
            match,
            tempMatch,
            index,
            col,
            lines;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i=0;i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (!this.options.flex) break;
            }
        }
        if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) this.yylineno += lines.length;
            this.yylloc = {first_line: this.yylloc.last_line,
                           last_line: this.yylineno+1,
                           first_column: this.yylloc.last_column,
                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
            if (this.done && this._input) this.done = false;
            if (token) return token;
            else return;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                    {text: "", token: null, line: this.yylineno});
        }
    },
lex:function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
            return r;
        } else {
            return this.lex();
        }
    },
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },
popState:function popState() {
        return this.conditionStack.pop();
    },
_currentRules:function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
    },
topState:function () {
        return this.conditionStack[this.conditionStack.length-2];
    },
pushState:function begin(condition) {
        this.begin(condition);
    }});
lexer.options = {};
lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START
switch($avoiding_name_collisions) {
case 0: yy_.yytext = "\\"; return 14;
break;
case 1:
                                   if(yy_.yytext.slice(-1) !== "\\") this.begin("mu");
                                   if(yy_.yytext.slice(-1) === "\\") yy_.yytext = yy_.yytext.substr(0,yy_.yyleng-1), this.begin("emu");
                                   if(yy_.yytext) return 14;

break;
case 2: return 14;
break;
case 3:
                                   if(yy_.yytext.slice(-1) !== "\\") this.popState();
                                   if(yy_.yytext.slice(-1) === "\\") yy_.yytext = yy_.yytext.substr(0,yy_.yyleng-1);
                                   return 14;

break;
case 4: yy_.yytext = yy_.yytext.substr(0, yy_.yyleng-4); this.popState(); return 15;
break;
case 5: return 25;
break;
case 6: return 16;
break;
case 7: return 20;
break;
case 8: return 19;
break;
case 9: return 19;
break;
case 10: return 23;
break;
case 11: return 22;
break;
case 12: this.popState(); this.begin('com');
break;
case 13: yy_.yytext = yy_.yytext.substr(3,yy_.yyleng-5); this.popState(); return 15;
break;
case 14: return 22;
break;
case 15: return 37;
break;
case 16: return 36;
break;
case 17: return 36;
break;
case 18: return 40;
break;
case 19: /*ignore whitespace*/
break;
case 20: this.popState(); return 24;
break;
case 21: this.popState(); return 18;
break;
case 22: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\\"/g,'"'); return 31;
break;
case 23: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\\'/g,"'"); return 31;
break;
case 24: return 38;
break;
case 25: return 33;
break;
case 26: return 33;
break;
case 27: return 32;
break;
case 28: return 36;
break;
case 29: yy_.yytext = yy_.yytext.substr(1, yy_.yyleng-2); return 36;
break;
case 30: return 'INVALID';
break;
case 31: return 5;
break;
}
};
lexer.rules = [/^(?:\\\\(?=(\{\{)))/,/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|$)))/,/^(?:[\s\S]*?--\}\})/,/^(?:\{\{>)/,/^(?:\{\{#)/,/^(?:\{\{\/)/,/^(?:\{\{\^)/,/^(?:\{\{\s*else\b)/,/^(?:\{\{\{)/,/^(?:\{\{&)/,/^(?:\{\{!--)/,/^(?:\{\{![\s\S]*?\}\})/,/^(?:\{\{)/,/^(?:=)/,/^(?:\.(?=[}\/ ]))/,/^(?:\.\.)/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}\}\})/,/^(?:\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=[}\s]))/,/^(?:false(?=[}\s]))/,/^(?:-?[0-9]+(?=[}\s]))/,/^(?:[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.]))/,/^(?:\[[^\]]*\])/,/^(?:.)/,/^(?:$)/];
lexer.conditions = {"mu":{"rules":[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31],"inclusive":false},"emu":{"rules":[3],"inclusive":false},"com":{"rules":[4],"inclusive":false},"INITIAL":{"rules":[0,1,2,31],"inclusive":true}};
return lexer;})()
parser.lexer = lexer;
function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();;
// lib/handlebars/compiler/base.js

Handlebars.Parser = handlebars;

Handlebars.parse = function(input) {

  // Just return if an already-compile AST was passed in.
  if(input.constructor === Handlebars.AST.ProgramNode) { return input; }

  Handlebars.Parser.yy = Handlebars.AST;
  return Handlebars.Parser.parse(input);
};
;
// lib/handlebars/compiler/ast.js
Handlebars.AST = {};

Handlebars.AST.ProgramNode = function(statements, inverse) {
  this.type = "program";
  this.statements = statements;
  if(inverse) { this.inverse = new Handlebars.AST.ProgramNode(inverse); }
};

Handlebars.AST.MustacheNode = function(rawParams, hash, unescaped) {
  this.type = "mustache";
  this.escaped = !unescaped;
  this.hash = hash;

  var id = this.id = rawParams[0];
  var params = this.params = rawParams.slice(1);

  // a mustache is an eligible helper if:
  // * its id is simple (a single part, not `this` or `..`)
  var eligibleHelper = this.eligibleHelper = id.isSimple;

  // a mustache is definitely a helper if:
  // * it is an eligible helper, and
  // * it has at least one parameter or hash segment
  this.isHelper = eligibleHelper && (params.length || hash);

  // if a mustache is an eligible helper but not a definite
  // helper, it is ambiguous, and will be resolved in a later
  // pass or at runtime.
};

Handlebars.AST.PartialNode = function(partialName, context) {
  this.type         = "partial";
  this.partialName  = partialName;
  this.context      = context;
};

Handlebars.AST.BlockNode = function(mustache, program, inverse, close) {
  var verifyMatch = function(open, close) {
    if(open.original !== close.original) {
      throw new Handlebars.Exception(open.original + " doesn't match " + close.original);
    }
  };

  verifyMatch(mustache.id, close);
  this.type = "block";
  this.mustache = mustache;
  this.program  = program;
  this.inverse  = inverse;

  if (this.inverse && !this.program) {
    this.isInverse = true;
  }
};

Handlebars.AST.ContentNode = function(string) {
  this.type = "content";
  this.string = string;
};

Handlebars.AST.HashNode = function(pairs) {
  this.type = "hash";
  this.pairs = pairs;
};

Handlebars.AST.IdNode = function(parts) {
  this.type = "ID";

  var original = "",
      dig = [],
      depth = 0;

  for(var i=0,l=parts.length; i<l; i++) {
    var part = parts[i].part;
    original += (parts[i].separator || '') + part;

    if (part === ".." || part === "." || part === "this") {
      if (dig.length > 0) { throw new Handlebars.Exception("Invalid path: " + original); }
      else if (part === "..") { depth++; }
      else { this.isScoped = true; }
    }
    else { dig.push(part); }
  }

  this.original = original;
  this.parts    = dig;
  this.string   = dig.join('.');
  this.depth    = depth;

  // an ID is simple if it only has one part, and that part is not
  // `..` or `this`.
  this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

  this.stringModeValue = this.string;
};

Handlebars.AST.PartialNameNode = function(name) {
  this.type = "PARTIAL_NAME";
  this.name = name.original;
};

Handlebars.AST.DataNode = function(id) {
  this.type = "DATA";
  this.id = id;
};

Handlebars.AST.StringNode = function(string) {
  this.type = "STRING";
  this.original =
    this.string =
    this.stringModeValue = string;
};

Handlebars.AST.IntegerNode = function(integer) {
  this.type = "INTEGER";
  this.original =
    this.integer = integer;
  this.stringModeValue = Number(integer);
};

Handlebars.AST.BooleanNode = function(bool) {
  this.type = "BOOLEAN";
  this.bool = bool;
  this.stringModeValue = bool === "true";
};

Handlebars.AST.CommentNode = function(comment) {
  this.type = "comment";
  this.comment = comment;
};
;
// lib/handlebars/utils.js

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

Handlebars.Exception = function(message) {
  var tmp = Error.prototype.constructor.apply(this, arguments);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }
};
Handlebars.Exception.prototype = new Error();

// Build out our basic SafeString type
Handlebars.SafeString = function(string) {
  this.string = string;
};
Handlebars.SafeString.prototype.toString = function() {
  return this.string.toString();
};

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

var escapeChar = function(chr) {
  return escape[chr] || "&amp;";
};

Handlebars.Utils = {
  extend: function(obj, value) {
    for(var key in value) {
      if(value.hasOwnProperty(key)) {
        obj[key] = value[key];
      }
    }
  },

  escapeExpression: function(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof Handlebars.SafeString) {
      return string.toString();
    } else if (string == null || string === false) {
      return "";
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = string.toString();

    if(!possible.test(string)) { return string; }
    return string.replace(badChars, escapeChar);
  },

  isEmpty: function(value) {
    if (!value && value !== 0) {
      return true;
    } else if(toString.call(value) === "[object Array]" && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }
};
;
// lib/handlebars/compiler/compiler.js

/*jshint eqnull:true*/
var Compiler = Handlebars.Compiler = function() {};
var JavaScriptCompiler = Handlebars.JavaScriptCompiler = function() {};

// the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.

Compiler.prototype = {
  compiler: Compiler,

  disassemble: function() {
    var opcodes = this.opcodes, opcode, out = [], params, param;

    for (var i=0, l=opcodes.length; i<l; i++) {
      opcode = opcodes[i];

      if (opcode.opcode === 'DECLARE') {
        out.push("DECLARE " + opcode.name + "=" + opcode.value);
      } else {
        params = [];
        for (var j=0; j<opcode.args.length; j++) {
          param = opcode.args[j];
          if (typeof param === "string") {
            param = "\"" + param.replace("\n", "\\n") + "\"";
          }
          params.push(param);
        }
        out.push(opcode.opcode + " " + params.join(" "));
      }
    }

    return out.join("\n");
  },
  equals: function(other) {
    var len = this.opcodes.length;
    if (other.opcodes.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      var opcode = this.opcodes[i],
          otherOpcode = other.opcodes[i];
      if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {
        return false;
      }
      for (var j = 0; j < opcode.args.length; j++) {
        if (opcode.args[j] !== otherOpcode.args[j]) {
          return false;
        }
      }
    }

    len = this.children.length;
    if (other.children.length !== len) {
      return false;
    }
    for (i = 0; i < len; i++) {
      if (!this.children[i].equals(other.children[i])) {
        return false;
      }
    }

    return true;
  },

  guid: 0,

  compile: function(program, options) {
    this.children = [];
    this.depths = {list: []};
    this.options = options;

    // These changes will propagate to the other compiler components
    var knownHelpers = this.options.knownHelpers;
    this.options.knownHelpers = {
      'helperMissing': true,
      'blockHelperMissing': true,
      'each': true,
      'if': true,
      'unless': true,
      'with': true,
      'log': true
    };
    if (knownHelpers) {
      for (var name in knownHelpers) {
        this.options.knownHelpers[name] = knownHelpers[name];
      }
    }

    return this.program(program);
  },

  accept: function(node) {
    return this[node.type](node);
  },

  program: function(program) {
    var statements = program.statements, statement;
    this.opcodes = [];

    for(var i=0, l=statements.length; i<l; i++) {
      statement = statements[i];
      this[statement.type](statement);
    }
    this.isSimple = l === 1;

    this.depths.list = this.depths.list.sort(function(a, b) {
      return a - b;
    });

    return this;
  },

  compileProgram: function(program) {
    var result = new this.compiler().compile(program, this.options);
    var guid = this.guid++, depth;

    this.usePartial = this.usePartial || result.usePartial;

    this.children[guid] = result;

    for(var i=0, l=result.depths.list.length; i<l; i++) {
      depth = result.depths.list[i];

      if(depth < 2) { continue; }
      else { this.addDepth(depth - 1); }
    }

    return guid;
  },

  block: function(block) {
    var mustache = block.mustache,
        program = block.program,
        inverse = block.inverse;

    if (program) {
      program = this.compileProgram(program);
    }

    if (inverse) {
      inverse = this.compileProgram(inverse);
    }

    var type = this.classifyMustache(mustache);

    if (type === "helper") {
      this.helperMustache(mustache, program, inverse);
    } else if (type === "simple") {
      this.simpleMustache(mustache);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('blockValue');
    } else {
      this.ambiguousMustache(mustache, program, inverse);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('ambiguousBlockValue');
    }

    this.opcode('append');
  },

  hash: function(hash) {
    var pairs = hash.pairs, pair, val;

    this.opcode('pushHash');

    for(var i=0, l=pairs.length; i<l; i++) {
      pair = pairs[i];
      val  = pair[1];

      if (this.options.stringParams) {
        if(val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode('getContext', val.depth || 0);
        this.opcode('pushStringParam', val.stringModeValue, val.type);
      } else {
        this.accept(val);
      }

      this.opcode('assignToHash', pair[0]);
    }
    this.opcode('popHash');
  },

  partial: function(partial) {
    var partialName = partial.partialName;
    this.usePartial = true;

    if(partial.context) {
      this.ID(partial.context);
    } else {
      this.opcode('push', 'depth0');
    }

    this.opcode('invokePartial', partialName.name);
    this.opcode('append');
  },

  content: function(content) {
    this.opcode('appendContent', content.string);
  },

  mustache: function(mustache) {
    var options = this.options;
    var type = this.classifyMustache(mustache);

    if (type === "simple") {
      this.simpleMustache(mustache);
    } else if (type === "helper") {
      this.helperMustache(mustache);
    } else {
      this.ambiguousMustache(mustache);
    }

    if(mustache.escaped && !options.noEscape) {
      this.opcode('appendEscaped');
    } else {
      this.opcode('append');
    }
  },

  ambiguousMustache: function(mustache, program, inverse) {
    var id = mustache.id,
        name = id.parts[0],
        isBlock = program != null || inverse != null;

    this.opcode('getContext', id.depth);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    this.opcode('invokeAmbiguous', name, isBlock);
  },

  simpleMustache: function(mustache) {
    var id = mustache.id;

    if (id.type === 'DATA') {
      this.DATA(id);
    } else if (id.parts.length) {
      this.ID(id);
    } else {
      // Simplified ID for `this`
      this.addDepth(id.depth);
      this.opcode('getContext', id.depth);
      this.opcode('pushContext');
    }

    this.opcode('resolvePossibleLambda');
  },

  helperMustache: function(mustache, program, inverse) {
    var params = this.setupFullMustacheParams(mustache, program, inverse),
        name = mustache.id.parts[0];

    if (this.options.knownHelpers[name]) {
      this.opcode('invokeKnownHelper', params.length, name);
    } else if (this.options.knownHelpersOnly) {
      throw new Error("You specified knownHelpersOnly, but used the unknown helper " + name);
    } else {
      this.opcode('invokeHelper', params.length, name);
    }
  },

  ID: function(id) {
    this.addDepth(id.depth);
    this.opcode('getContext', id.depth);

    var name = id.parts[0];
    if (!name) {
      this.opcode('pushContext');
    } else {
      this.opcode('lookupOnContext', id.parts[0]);
    }

    for(var i=1, l=id.parts.length; i<l; i++) {
      this.opcode('lookup', id.parts[i]);
    }
  },

  DATA: function(data) {
    this.options.data = true;
    if (data.id.isScoped || data.id.depth) {
      throw new Handlebars.Exception('Scoped data references are not supported: ' + data.original);
    }

    this.opcode('lookupData');
    var parts = data.id.parts;
    for(var i=0, l=parts.length; i<l; i++) {
      this.opcode('lookup', parts[i]);
    }
  },

  STRING: function(string) {
    this.opcode('pushString', string.string);
  },

  INTEGER: function(integer) {
    this.opcode('pushLiteral', integer.integer);
  },

  BOOLEAN: function(bool) {
    this.opcode('pushLiteral', bool.bool);
  },

  comment: function() {},

  // HELPERS
  opcode: function(name) {
    this.opcodes.push({ opcode: name, args: [].slice.call(arguments, 1) });
  },

  declare: function(name, value) {
    this.opcodes.push({ opcode: 'DECLARE', name: name, value: value });
  },

  addDepth: function(depth) {
    if(isNaN(depth)) { throw new Error("EWOT"); }
    if(depth === 0) { return; }

    if(!this.depths[depth]) {
      this.depths[depth] = true;
      this.depths.list.push(depth);
    }
  },

  classifyMustache: function(mustache) {
    var isHelper   = mustache.isHelper;
    var isEligible = mustache.eligibleHelper;
    var options    = this.options;

    // if ambiguous, we can possibly resolve the ambiguity now
    if (isEligible && !isHelper) {
      var name = mustache.id.parts[0];

      if (options.knownHelpers[name]) {
        isHelper = true;
      } else if (options.knownHelpersOnly) {
        isEligible = false;
      }
    }

    if (isHelper) { return "helper"; }
    else if (isEligible) { return "ambiguous"; }
    else { return "simple"; }
  },

  pushParams: function(params) {
    var i = params.length, param;

    while(i--) {
      param = params[i];

      if(this.options.stringParams) {
        if(param.depth) {
          this.addDepth(param.depth);
        }

        this.opcode('getContext', param.depth || 0);
        this.opcode('pushStringParam', param.stringModeValue, param.type);
      } else {
        this[param.type](param);
      }
    }
  },

  setupMustacheParams: function(mustache) {
    var params = mustache.params;
    this.pushParams(params);

    if(mustache.hash) {
      this.hash(mustache.hash);
    } else {
      this.opcode('emptyHash');
    }

    return params;
  },

  // this will replace setupMustacheParams when we're done
  setupFullMustacheParams: function(mustache, program, inverse) {
    var params = mustache.params;
    this.pushParams(params);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    if(mustache.hash) {
      this.hash(mustache.hash);
    } else {
      this.opcode('emptyHash');
    }

    return params;
  }
};

var Literal = function(value) {
  this.value = value;
};

JavaScriptCompiler.prototype = {
  // PUBLIC API: You can override these methods in a subclass to provide
  // alternative compiled forms for name lookup and buffering semantics
  nameLookup: function(parent, name /* , type*/) {
    if (/^[0-9]+$/.test(name)) {
      return parent + "[" + name + "]";
    } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
      return parent + "." + name;
    }
    else {
      return parent + "['" + name + "']";
    }
  },

  appendToBuffer: function(string) {
    if (this.environment.isSimple) {
      return "return " + string + ";";
    } else {
      return {
        appendToBuffer: true,
        content: string,
        toString: function() { return "buffer += " + string + ";"; }
      };
    }
  },

  initializeBuffer: function() {
    return this.quotedString("");
  },

  namespace: "Handlebars",
  // END PUBLIC API

  compile: function(environment, options, context, asObject) {
    this.environment = environment;
    this.options = options || {};

    Handlebars.log(Handlebars.logger.DEBUG, this.environment.disassemble() + "\n\n");

    this.name = this.environment.name;
    this.isChild = !!context;
    this.context = context || {
      programs: [],
      environments: [],
      aliases: { }
    };

    this.preamble();

    this.stackSlot = 0;
    this.stackVars = [];
    this.registers = { list: [] };
    this.compileStack = [];
    this.inlineStack = [];

    this.compileChildren(environment, options);

    var opcodes = environment.opcodes, opcode;

    this.i = 0;

    for(l=opcodes.length; this.i<l; this.i++) {
      opcode = opcodes[this.i];

      if(opcode.opcode === 'DECLARE') {
        this[opcode.name] = opcode.value;
      } else {
        this[opcode.opcode].apply(this, opcode.args);
      }
    }

    return this.createFunctionContext(asObject);
  },

  nextOpcode: function() {
    var opcodes = this.environment.opcodes;
    return opcodes[this.i + 1];
  },

  eat: function() {
    this.i = this.i + 1;
  },

  preamble: function() {
    var out = [];

    if (!this.isChild) {
      var namespace = this.namespace;

      var copies = "helpers = this.merge(helpers, " + namespace + ".helpers);";
      if (this.environment.usePartial) { copies = copies + " partials = this.merge(partials, " + namespace + ".partials);"; }
      if (this.options.data) { copies = copies + " data = data || {};"; }
      out.push(copies);
    } else {
      out.push('');
    }

    if (!this.environment.isSimple) {
      out.push(", buffer = " + this.initializeBuffer());
    } else {
      out.push("");
    }

    // track the last context pushed into place to allow skipping the
    // getContext opcode when it would be a noop
    this.lastContext = 0;
    this.source = out;
  },

  createFunctionContext: function(asObject) {
    var locals = this.stackVars.concat(this.registers.list);

    if(locals.length > 0) {
      this.source[1] = this.source[1] + ", " + locals.join(", ");
    }

    // Generate minimizer alias mappings
    if (!this.isChild) {
      for (var alias in this.context.aliases) {
        if (this.context.aliases.hasOwnProperty(alias)) {
          this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];
        }
      }
    }

    if (this.source[1]) {
      this.source[1] = "var " + this.source[1].substring(2) + ";";
    }

    // Merge children
    if (!this.isChild) {
      this.source[1] += '\n' + this.context.programs.join('\n') + '\n';
    }

    if (!this.environment.isSimple) {
      this.source.push("return buffer;");
    }

    var params = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"];

    for(var i=0, l=this.environment.depths.list.length; i<l; i++) {
      params.push("depth" + this.environment.depths.list[i]);
    }

    // Perform a second pass over the output to merge content when possible
    var source = this.mergeSource();

    if (!this.isChild) {
      var revision = Handlebars.COMPILER_REVISION,
          versions = Handlebars.REVISION_CHANGES[revision];
      source = "this.compilerInfo = ["+revision+",'"+versions+"'];\n"+source;
    }

    if (asObject) {
      params.push(source);

      return Function.apply(this, params);
    } else {
      var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\n  ' + source + '}';
      Handlebars.log(Handlebars.logger.DEBUG, functionSource + "\n\n");
      return functionSource;
    }
  },
  mergeSource: function() {
    // WARN: We are not handling the case where buffer is still populated as the source should
    // not have buffer append operations as their final action.
    var source = '',
        buffer;
    for (var i = 0, len = this.source.length; i < len; i++) {
      var line = this.source[i];
      if (line.appendToBuffer) {
        if (buffer) {
          buffer = buffer + '\n    + ' + line.content;
        } else {
          buffer = line.content;
        }
      } else {
        if (buffer) {
          source += 'buffer += ' + buffer + ';\n  ';
          buffer = undefined;
        }
        source += line + '\n  ';
      }
    }
    return source;
  },

  // [blockValue]
  //
  // On stack, before: hash, inverse, program, value
  // On stack, after: return value of blockHelperMissing
  //
  // The purpose of this opcode is to take a block of the form
  // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and
  // replace it on the stack with the result of properly
  // invoking blockHelperMissing.
  blockValue: function() {
    this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

    var params = ["depth0"];
    this.setupParams(0, params);

    this.replaceStack(function(current) {
      params.splice(1, 0, current);
      return "blockHelperMissing.call(" + params.join(", ") + ")";
    });
  },

  // [ambiguousBlockValue]
  //
  // On stack, before: hash, inverse, program, value
  // Compiler value, before: lastHelper=value of last found helper, if any
  // On stack, after, if no lastHelper: same as [blockValue]
  // On stack, after, if lastHelper: value
  ambiguousBlockValue: function() {
    this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

    var params = ["depth0"];
    this.setupParams(0, params);

    var current = this.topStack();
    params.splice(1, 0, current);

    // Use the options value generated from the invocation
    params[params.length-1] = 'options';

    this.source.push("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
  },

  // [appendContent]
  //
  // On stack, before: ...
  // On stack, after: ...
  //
  // Appends the string value of `content` to the current buffer
  appendContent: function(content) {
    this.source.push(this.appendToBuffer(this.quotedString(content)));
  },

  // [append]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Coerces `value` to a String and appends it to the current buffer.
  //
  // If `value` is truthy, or 0, it is coerced into a string and appended
  // Otherwise, the empty string is appended
  append: function() {
    // Force anything that is inlined onto the stack so we don't have duplication
    // when we examine local
    this.flushInline();
    var local = this.popStack();
    this.source.push("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
    if (this.environment.isSimple) {
      this.source.push("else { " + this.appendToBuffer("''") + " }");
    }
  },

  // [appendEscaped]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Escape `value` and append it to the buffer
  appendEscaped: function() {
    this.context.aliases.escapeExpression = 'this.escapeExpression';

    this.source.push(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
  },

  // [getContext]
  //
  // On stack, before: ...
  // On stack, after: ...
  // Compiler value, after: lastContext=depth
  //
  // Set the value of the `lastContext` compiler value to the depth
  getContext: function(depth) {
    if(this.lastContext !== depth) {
      this.lastContext = depth;
    }
  },

  // [lookupOnContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext[name], ...
  //
  // Looks up the value of `name` on the current context and pushes
  // it onto the stack.
  lookupOnContext: function(name) {
    this.push(this.nameLookup('depth' + this.lastContext, name, 'context'));
  },

  // [pushContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext, ...
  //
  // Pushes the value of the current context onto the stack.
  pushContext: function() {
    this.pushStackLiteral('depth' + this.lastContext);
  },

  // [resolvePossibleLambda]
  //
  // On stack, before: value, ...
  // On stack, after: resolved value, ...
  //
  // If the `value` is a lambda, replace it on the stack by
  // the return value of the lambda
  resolvePossibleLambda: function() {
    this.context.aliases.functionType = '"function"';

    this.replaceStack(function(current) {
      return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
    });
  },

  // [lookup]
  //
  // On stack, before: value, ...
  // On stack, after: value[name], ...
  //
  // Replace the value on the stack with the result of looking
  // up `name` on `value`
  lookup: function(name) {
    this.replaceStack(function(current) {
      return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, 'context');
    });
  },

  // [lookupData]
  //
  // On stack, before: ...
  // On stack, after: data[id], ...
  //
  // Push the result of looking up `id` on the current data
  lookupData: function(id) {
    this.push('data');
  },

  // [pushStringParam]
  //
  // On stack, before: ...
  // On stack, after: string, currentContext, ...
  //
  // This opcode is designed for use in string mode, which
  // provides the string value of a parameter along with its
  // depth rather than resolving it immediately.
  pushStringParam: function(string, type) {
    this.pushStackLiteral('depth' + this.lastContext);

    this.pushString(type);

    if (typeof string === 'string') {
      this.pushString(string);
    } else {
      this.pushStackLiteral(string);
    }
  },

  emptyHash: function() {
    this.pushStackLiteral('{}');

    if (this.options.stringParams) {
      this.register('hashTypes', '{}');
      this.register('hashContexts', '{}');
    }
  },
  pushHash: function() {
    this.hash = {values: [], types: [], contexts: []};
  },
  popHash: function() {
    var hash = this.hash;
    this.hash = undefined;

    if (this.options.stringParams) {
      this.register('hashContexts', '{' + hash.contexts.join(',') + '}');
      this.register('hashTypes', '{' + hash.types.join(',') + '}');
    }
    this.push('{\n    ' + hash.values.join(',\n    ') + '\n  }');
  },

  // [pushString]
  //
  // On stack, before: ...
  // On stack, after: quotedString(string), ...
  //
  // Push a quoted version of `string` onto the stack
  pushString: function(string) {
    this.pushStackLiteral(this.quotedString(string));
  },

  // [push]
  //
  // On stack, before: ...
  // On stack, after: expr, ...
  //
  // Push an expression onto the stack
  push: function(expr) {
    this.inlineStack.push(expr);
    return expr;
  },

  // [pushLiteral]
  //
  // On stack, before: ...
  // On stack, after: value, ...
  //
  // Pushes a value onto the stack. This operation prevents
  // the compiler from creating a temporary variable to hold
  // it.
  pushLiteral: function(value) {
    this.pushStackLiteral(value);
  },

  // [pushProgram]
  //
  // On stack, before: ...
  // On stack, after: program(guid), ...
  //
  // Push a program expression onto the stack. This takes
  // a compile-time guid and converts it into a runtime-accessible
  // expression.
  pushProgram: function(guid) {
    if (guid != null) {
      this.pushStackLiteral(this.programExpression(guid));
    } else {
      this.pushStackLiteral(null);
    }
  },

  // [invokeHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // Pops off the helper's parameters, invokes the helper,
  // and pushes the helper's return value onto the stack.
  //
  // If the helper is not found, `helperMissing` is called.
  invokeHelper: function(paramSize, name) {
    this.context.aliases.helperMissing = 'helpers.helperMissing';

    var helper = this.lastHelper = this.setupHelper(paramSize, name, true);
    var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');

    this.push(helper.name + ' || ' + nonHelper);
    this.replaceStack(function(name) {
      return name + ' ? ' + name + '.call(' +
          helper.callParams + ") " + ": helperMissing.call(" +
          helper.helperMissingParams + ")";
    });
  },

  // [invokeKnownHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // This operation is used when the helper is known to exist,
  // so a `helperMissing` fallback is not required.
  invokeKnownHelper: function(paramSize, name) {
    var helper = this.setupHelper(paramSize, name);
    this.push(helper.name + ".call(" + helper.callParams + ")");
  },

  // [invokeAmbiguous]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of disambiguation
  //
  // This operation is used when an expression like `{{foo}}`
  // is provided, but we don't know at compile-time whether it
  // is a helper or a path.
  //
  // This operation emits more code than the other options,
  // and can be avoided by passing the `knownHelpers` and
  // `knownHelpersOnly` flags at compile-time.
  invokeAmbiguous: function(name, helperCall) {
    this.context.aliases.functionType = '"function"';

    this.pushStackLiteral('{}');    // Hash value
    var helper = this.setupHelper(0, name, helperCall);

    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

    var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');
    var nextStack = this.nextStack();

    this.source.push('if (' + nextStack + ' = ' + helperName + ') { ' + nextStack + ' = ' + nextStack + '.call(' + helper.callParams + '); }');
    this.source.push('else { ' + nextStack + ' = ' + nonHelper + '; ' + nextStack + ' = typeof ' + nextStack + ' === functionType ? ' + nextStack + '.apply(depth0) : ' + nextStack + '; }');
  },

  // [invokePartial]
  //
  // On stack, before: context, ...
  // On stack after: result of partial invocation
  //
  // This operation pops off a context, invokes a partial with that context,
  // and pushes the result of the invocation back.
  invokePartial: function(name) {
    var params = [this.nameLookup('partials', name, 'partial'), "'" + name + "'", this.popStack(), "helpers", "partials"];

    if (this.options.data) {
      params.push("data");
    }

    this.context.aliases.self = "this";
    this.push("self.invokePartial(" + params.join(", ") + ")");
  },

  // [assignToHash]
  //
  // On stack, before: value, hash, ...
  // On stack, after: hash, ...
  //
  // Pops a value and hash off the stack, assigns `hash[key] = value`
  // and pushes the hash back onto the stack.
  assignToHash: function(key) {
    var value = this.popStack(),
        context,
        type;

    if (this.options.stringParams) {
      type = this.popStack();
      context = this.popStack();
    }

    var hash = this.hash;
    if (context) {
      hash.contexts.push("'" + key + "': " + context);
    }
    if (type) {
      hash.types.push("'" + key + "': " + type);
    }
    hash.values.push("'" + key + "': (" + value + ")");
  },

  // HELPERS

  compiler: JavaScriptCompiler,

  compileChildren: function(environment, options) {
    var children = environment.children, child, compiler;

    for(var i=0, l=children.length; i<l; i++) {
      child = children[i];
      compiler = new this.compiler();

      var index = this.matchExistingProgram(child);

      if (index == null) {
        this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
        index = this.context.programs.length;
        child.index = index;
        child.name = 'program' + index;
        this.context.programs[index] = compiler.compile(child, options, this.context);
        this.context.environments[index] = child;
      } else {
        child.index = index;
        child.name = 'program' + index;
      }
    }
  },
  matchExistingProgram: function(child) {
    for (var i = 0, len = this.context.environments.length; i < len; i++) {
      var environment = this.context.environments[i];
      if (environment && environment.equals(child)) {
        return i;
      }
    }
  },

  programExpression: function(guid) {
    this.context.aliases.self = "this";

    if(guid == null) {
      return "self.noop";
    }

    var child = this.environment.children[guid],
        depths = child.depths.list, depth;

    var programParams = [child.index, child.name, "data"];

    for(var i=0, l = depths.length; i<l; i++) {
      depth = depths[i];

      if(depth === 1) { programParams.push("depth0"); }
      else { programParams.push("depth" + (depth - 1)); }
    }

    return (depths.length === 0 ? "self.program(" : "self.programWithDepth(") + programParams.join(", ") + ")";
  },

  register: function(name, val) {
    this.useRegister(name);
    this.source.push(name + " = " + val + ";");
  },

  useRegister: function(name) {
    if(!this.registers[name]) {
      this.registers[name] = true;
      this.registers.list.push(name);
    }
  },

  pushStackLiteral: function(item) {
    return this.push(new Literal(item));
  },

  pushStack: function(item) {
    this.flushInline();

    var stack = this.incrStack();
    if (item) {
      this.source.push(stack + " = " + item + ";");
    }
    this.compileStack.push(stack);
    return stack;
  },

  replaceStack: function(callback) {
    var prefix = '',
        inline = this.isInline(),
        stack;

    // If we are currently inline then we want to merge the inline statement into the
    // replacement statement via ','
    if (inline) {
      var top = this.popStack(true);

      if (top instanceof Literal) {
        // Literals do not need to be inlined
        stack = top.value;
      } else {
        // Get or create the current stack name for use by the inline
        var name = this.stackSlot ? this.topStackName() : this.incrStack();

        prefix = '(' + this.push(name) + ' = ' + top + '),';
        stack = this.topStack();
      }
    } else {
      stack = this.topStack();
    }

    var item = callback.call(this, stack);

    if (inline) {
      if (this.inlineStack.length || this.compileStack.length) {
        this.popStack();
      }
      this.push('(' + prefix + item + ')');
    } else {
      // Prevent modification of the context depth variable. Through replaceStack
      if (!/^stack/.test(stack)) {
        stack = this.nextStack();
      }

      this.source.push(stack + " = (" + prefix + item + ");");
    }
    return stack;
  },

  nextStack: function() {
    return this.pushStack();
  },

  incrStack: function() {
    this.stackSlot++;
    if(this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
    return this.topStackName();
  },
  topStackName: function() {
    return "stack" + this.stackSlot;
  },
  flushInline: function() {
    var inlineStack = this.inlineStack;
    if (inlineStack.length) {
      this.inlineStack = [];
      for (var i = 0, len = inlineStack.length; i < len; i++) {
        var entry = inlineStack[i];
        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          this.pushStack(entry);
        }
      }
    }
  },
  isInline: function() {
    return this.inlineStack.length;
  },

  popStack: function(wrapped) {
    var inline = this.isInline(),
        item = (inline ? this.inlineStack : this.compileStack).pop();

    if (!wrapped && (item instanceof Literal)) {
      return item.value;
    } else {
      if (!inline) {
        this.stackSlot--;
      }
      return item;
    }
  },

  topStack: function(wrapped) {
    var stack = (this.isInline() ? this.inlineStack : this.compileStack),
        item = stack[stack.length - 1];

    if (!wrapped && (item instanceof Literal)) {
      return item.value;
    } else {
      return item;
    }
  },

  quotedString: function(str) {
    return '"' + str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
      .replace(/\u2029/g, '\\u2029') + '"';
  },

  setupHelper: function(paramSize, name, missingParams) {
    var params = [];
    this.setupParams(paramSize, params, missingParams);
    var foundHelper = this.nameLookup('helpers', name, 'helper');

    return {
      params: params,
      name: foundHelper,
      callParams: ["depth0"].concat(params).join(", "),
      helperMissingParams: missingParams && ["depth0", this.quotedString(name)].concat(params).join(", ")
    };
  },

  // the params and contexts arguments are passed in arrays
  // to fill in
  setupParams: function(paramSize, params, useRegister) {
    var options = [], contexts = [], types = [], param, inverse, program;

    options.push("hash:" + this.popStack());

    inverse = this.popStack();
    program = this.popStack();

    // Avoid setting fn and inverse if neither are set. This allows
    // helpers to do a check for `if (options.fn)`
    if (program || inverse) {
      if (!program) {
        this.context.aliases.self = "this";
        program = "self.noop";
      }

      if (!inverse) {
       this.context.aliases.self = "this";
        inverse = "self.noop";
      }

      options.push("inverse:" + inverse);
      options.push("fn:" + program);
    }

    for(var i=0; i<paramSize; i++) {
      param = this.popStack();
      params.push(param);

      if(this.options.stringParams) {
        types.push(this.popStack());
        contexts.push(this.popStack());
      }
    }

    if (this.options.stringParams) {
      options.push("contexts:[" + contexts.join(",") + "]");
      options.push("types:[" + types.join(",") + "]");
      options.push("hashContexts:hashContexts");
      options.push("hashTypes:hashTypes");
    }

    if(this.options.data) {
      options.push("data:data");
    }

    options = "{" + options.join(",") + "}";
    if (useRegister) {
      this.register('options', options);
      params.push('options');
    } else {
      params.push(options);
    }
    return params.join(", ");
  }
};

var reservedWords = (
  "break else new var" +
  " case finally return void" +
  " catch for switch while" +
  " continue function this with" +
  " default if throw" +
  " delete in try" +
  " do instanceof typeof" +
  " abstract enum int short" +
  " boolean export interface static" +
  " byte extends long super" +
  " char final native synchronized" +
  " class float package throws" +
  " const goto private transient" +
  " debugger implements protected volatile" +
  " double import public let yield"
).split(" ");

var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

for(var i=0, l=reservedWords.length; i<l; i++) {
  compilerWords[reservedWords[i]] = true;
}

JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
  if(!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name)) {
    return true;
  }
  return false;
};

Handlebars.precompile = function(input, options) {
  if (input == null || (typeof input !== 'string' && input.constructor !== Handlebars.AST.ProgramNode)) {
    throw new Handlebars.Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
  }

  options = options || {};
  if (!('data' in options)) {
    options.data = true;
  }
  var ast = Handlebars.parse(input);
  var environment = new Compiler().compile(ast, options);
  return new JavaScriptCompiler().compile(environment, options);
};

Handlebars.compile = function(input, options) {
  if (input == null || (typeof input !== 'string' && input.constructor !== Handlebars.AST.ProgramNode)) {
    throw new Handlebars.Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
  }

  options = options || {};
  if (!('data' in options)) {
    options.data = true;
  }
  var compiled;
  function compile() {
    var ast = Handlebars.parse(input);
    var environment = new Compiler().compile(ast, options);
    var templateSpec = new JavaScriptCompiler().compile(environment, options, undefined, true);
    return Handlebars.template(templateSpec);
  }

  // Template is only compiled on first use and cached after that point.
  return function(context, options) {
    if (!compiled) {
      compiled = compile();
    }
    return compiled.call(this, context, options);
  };
};

;
// lib/handlebars/runtime.js

Handlebars.VM = {
  template: function(templateSpec) {
    // Just add water
    var container = {
      escapeExpression: Handlebars.Utils.escapeExpression,
      invokePartial: Handlebars.VM.invokePartial,
      programs: [],
      program: function(i, fn, data) {
        var programWrapper = this.programs[i];
        if(data) {
          programWrapper = Handlebars.VM.program(i, fn, data);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = Handlebars.VM.program(i, fn);
        }
        return programWrapper;
      },
      merge: function(param, common) {
        var ret = param || common;

        if (param && common) {
          ret = {};
          Handlebars.Utils.extend(ret, common);
          Handlebars.Utils.extend(ret, param);
        }
        return ret;
      },
      programWithDepth: Handlebars.VM.programWithDepth,
      noop: Handlebars.VM.noop,
      compilerInfo: null
    };

    return function(context, options) {
      options = options || {};
      var result = templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);

      var compilerInfo = container.compilerInfo || [],
          compilerRevision = compilerInfo[0] || 1,
          currentRevision = Handlebars.COMPILER_REVISION;

      if (compilerRevision !== currentRevision) {
        if (compilerRevision < currentRevision) {
          var runtimeVersions = Handlebars.REVISION_CHANGES[currentRevision],
              compilerVersions = Handlebars.REVISION_CHANGES[compilerRevision];
          throw "Template was precompiled with an older version of Handlebars than the current runtime. "+
                "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").";
        } else {
          // Use the embedded version info since the runtime doesn't know about this revision yet
          throw "Template was precompiled with a newer version of Handlebars than the current runtime. "+
                "Please update your runtime to a newer version ("+compilerInfo[1]+").";
        }
      }

      return result;
    };
  },

  programWithDepth: function(i, fn, data /*, $depth */) {
    var args = Array.prototype.slice.call(arguments, 3);

    var program = function(context, options) {
      options = options || {};

      return fn.apply(this, [context, options.data || data].concat(args));
    };
    program.program = i;
    program.depth = args.length;
    return program;
  },
  program: function(i, fn, data) {
    var program = function(context, options) {
      options = options || {};

      return fn(context, options.data || data);
    };
    program.program = i;
    program.depth = 0;
    return program;
  },
  noop: function() { return ""; },
  invokePartial: function(partial, name, context, helpers, partials, data) {
    var options = { helpers: helpers, partials: partials, data: data };

    if(partial === undefined) {
      throw new Handlebars.Exception("The partial " + name + " could not be found");
    } else if(partial instanceof Function) {
      return partial(context, options);
    } else if (!Handlebars.compile) {
      throw new Handlebars.Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    } else {
      partials[name] = Handlebars.compile(partial, {data: data !== undefined});
      return partials[name](context, options);
    }
  }
};

Handlebars.template = Handlebars.VM.template;
;
// lib/handlebars/browser-suffix.js
})(Handlebars);
;

this["CUI"] = this["CUI"] || {};
this["CUI"]["imageeditor"] = this["CUI"]["imageeditor"] || {};
this["CUI"]["imageeditor"]["Templates"] = this["CUI"]["imageeditor"]["Templates"] || {};

this["CUI"]["imageeditor"]["Templates"]["crop-popover"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, stack2, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n    <button class=\"coral-Button popover-button\" name=\"aspectRatio\" value=\""
    + escapeExpression(((stack1 = depth0.ratio),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">"
    + escapeExpression(((stack1 = depth0.name),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</button><br/>\n  ";
  return buffer;
  }

  buffer += "<div class=\"coral-Popover-content imageeditor-popover-content\">\n  <button class=\"coral-Button popover-button\" name=\"aspectRatio\" value=\"removeCrop\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "removecrop", options) : helperMissing.call(depth0, "i18n", "removecrop", options)))
    + "</button><br/>\n  ";
  stack2 = helpers.each.call(depth0, depth0.aspectRatios, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["imageeditor"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};



  return "<div class=\"imageeditor-container\">\n  <div class=\"imageeditor-toolbars icongroup\"></div>\n  <div class=\"imageeditor-controls\">\n    <div class=\"imageeditor-imagemap-polygon-helper\"></div>\n    <div class=\"imageeditor-controls-map-areas\"></div>\n  </div>\n</div>\n";
  });

this["CUI"]["imageeditor"]["Templates"]["map-popover"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {

  var buffer = "", stack1, options;
  buffer += "\n    <input class=\"coral-Textfield\" name=\"href\" type=\"url\" placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path", options) : helperMissing.call(depth0, "i18n", "path", options)))
    + "\" />\n  ";
  return buffer;
  }

function program3(depth0,data) {

  var buffer = "", stack1, options;
  buffer += "\n    <span class=\"coral-PathBrowser pathbrowser\" data-placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path", options) : helperMissing.call(depth0, "i18n", "path", options)))
    + "\" data-root-path=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.pathbrowser),stack1 == null || stack1 === false ? stack1 : stack1.rootPath)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n      <span class=\"coral-InputGroup\">\n        <input class=\"coral-InputGroup-input js-coral-pathbrowser-input coral-Textfield\" type=\"text\" name=\"href\">\n        <span class=\"coral-InputGroup-button\">\n          <button class=\"coral-Button coral-Button--secondary coral-Button--square js-coral-pathbrowser-button\" type=\"button\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path_picker", options) : helperMissing.call(depth0, "i18n", "path_picker", options)))
    + "\">\n            <i class=\"coral-Icon coral-Icon--sizeS coral-Icon--folderSearch\"></i>\n          </button>\n        </span>\n      </span>\n    </span>\n  ";
  return buffer;
  }

function program5(depth0,data) {

  var buffer = "", stack1, options;
  buffer += "\n    <span class=\"coral-DecoratedTextfield pathbrowser\" data-placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "path", options) : helperMissing.call(depth0, "i18n", "path", options)))
    + "\" data-root-path=\""
    + escapeExpression(((stack1 = ((stack1 = depth0.pathbrowser),stack1 == null || stack1 === false ? stack1 : stack1.rootPath)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n      <input class=\"js-coral-pathbrowser-input coral-Textfield\" type=\"text\" name=\"href\">\n    </span>\n  ";
  return buffer;
  }

  buffer += "<div class=\"imageeditor-map-toolbar toolbar\">\n  ";
  stack1 = helpers['if'].call(depth0, depth0.noPathbrowser, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, depth0.pathbrowserPicker, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, depth0.pathbrowserAutocomplete, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  <input class=\"coral-Textfield\" name=\"alt\" type=\"text\" placeholder=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "alt_text", options) : helperMissing.call(depth0, "i18n", "alt_text", options)))
    + "\" />\n  <span class=\"coral-Select\" data-init=\"select\">\n    <button class=\"coral-Select-button coral-MinimalButton\" type=\"button\">\n      <span class=\"coral-Select-button-text\"></span>\n    </button>\n    <select class=\"coral-Select-select\" name=\"target\">\n      <option value=\"\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "target", options) : helperMissing.call(depth0, "i18n", "target", options)))
    + "</option>\n      <option value=\"_self\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "same_tab", options) : helperMissing.call(depth0, "i18n", "same_tab", options)))
    + "</option>\n      <option value=\"_blank\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "new_tab", options) : helperMissing.call(depth0, "i18n", "new_tab", options)))
    + "</option>\n      <option value=\"_parent\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "parent_frame", options) : helperMissing.call(depth0, "i18n", "parent_frame", options)))
    + "</option>\n      <option value=\"_top\">";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "top_frame", options) : helperMissing.call(depth0, "i18n", "top_frame", options)))
    + "</option>\n    </select>\n  </span>\n  <span class=\"actions\">\n    <button class=\"coral-Button coral-Button--square coral-Button--warning imageeditor-map-delete\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "delete", options) : helperMissing.call(depth0, "i18n", "delete", options)))
    + "\">\n      <i class=\"coral-Icon coral-Icon--delete\"></i>\n    </button>\n    <button class=\"coral-Button coral-Button--square imageeditor-map-unlaunch\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "unlaunch", options) : helperMissing.call(depth0, "i18n", "unlaunch", options)))
    + "\">\n      <i class=\"coral-Icon coral-Icon--close\"></i>\n    </button>\n    <button class=\"coral-Button coral-Button--square coral-Button--primary imageeditor-map-confirm\" title=\"";
  options = {hash:{},data:data};
  buffer += escapeExpression(((stack1 = helpers.i18n || depth0.i18n),stack1 ? stack1.call(depth0, "confirm", options) : helperMissing.call(depth0, "i18n", "confirm", options)))
    + "\">\n      <i class=\"coral-Icon coral-Icon--check\"></i>\n    </button>\n  </span>\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["toolbar-item"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<button data-action=\"";
  if (stack1 = helpers.action) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.action; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (stack1 = helpers.title) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.title; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"\n        class=\"coral-Button coral-Button--quiet coral-Button--square ";
  if (stack1 = helpers.addClasses) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.addClasses; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">\n  <i class=\"coral-Icon coral-Icon--";
  if (stack1 = helpers.icon) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.icon; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\"></i>\n</button>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["toolbar"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, stack2;
  buffer += "\n      <div class=\"imageeditor-toolbar-"
    + escapeExpression(((stack1 = ((stack1 = data),stack1 == null || stack1 === false ? stack1 : stack1.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "-hand-side\">\n        ";
  stack2 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack2 || stack2 === 0) { buffer += stack2; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program3(depth0,data) {

  var stack1;
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

  buffer += "<div data-id=\"";
  if (stack1 = helpers.ref) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.ref; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" class=\"imageeditor-toolbar\">\n  ";
  stack1 = helpers.each.call(depth0, depth0.toolbarItems, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["toolbars"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  buffer += "<div data-type=\"";
  if (stack1 = helpers.type) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.type; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\">\n  ";
  if (stack1 = helpers.toolbar) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.toolbar; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers.each.call(depth0, depth0.replacementToolbars, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

this["CUI"]["imageeditor"]["Templates"]["zoomslider-popover"] = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"coral-Popover-content imageeditor-popover-content\">\n  <div class=\"coral-Slider popover-slider\" data-init=\"slider\">\n    <input type=\"range\" value=\"100\" min=\"";
  if (stack1 = helpers.zoomMin) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.zoomMin; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" max=\"";
  if (stack1 = helpers.zoomMax) { stack1 = stack1.call(depth0, {hash:{},data:data}); }
  else { stack1 = depth0.zoomMax; stack1 = typeof stack1 === functionType ? stack1.apply(depth0) : stack1; }
  buffer += escapeExpression(stack1)
    + "\" step=\"1\">\n  </div>\n</div>\n";
  return buffer;
  });
/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, window, CSSRule, undefined) {
  'use strict';

  var eventOutsideOfEditor = function (e) {
    return $(e.target).closest('.imageeditor-container').length === 0;
  };

  var translate = function (rotation, flip, element, box, result) {
    var toggle;

    result = result || $.extend({}, box);

    rotation = rotation % 360; // [-270, 270]
    rotation = rotation + 360; // [  90, 630]
    rotation = rotation % 360; // [  90, 270]

    // change coords to point to 'new' top left
    if (box.hasOwnProperty('top') && box.hasOwnProperty('left')) {
      if (rotation % 180 === 0) {
        toggle = rotation !== 0;

        if (flip.horizontal ^ toggle) {
          result.left = element.width - box.width - box.left;
        }
        else {
          result.left = box.left;
        }
        if (flip.vertical ^ toggle) {
          result.top = element.height - box.height - box.top;
        }
        else {
          result.top = box.top;
        }
      }
      else {
        toggle = rotation !== 90;

        if (flip.vertical ^ toggle) {
          result.left = box.top;
        }
        else {
          result.left = element.height - box.height - box.top;
        }
        if (flip.horizontal ^ toggle) {
          result.top = element.width - box.width - box.left;
        }
        else {
          result.top  = box.left;
        }
      }
    }

    // switch dimensions if necessary
    if (rotation % 180 !== 0) {
      result.width = box.height;
      result.height = box.width;
    }
    else {
      result.width = box.width;
      result.height = box.height;
    }

    return result;
  };

  var isIosVersion7 = function() {
    if (navigator && navigator.userAgent) {
      return (/.*OS 7.{0,4} like Mac OS X.*/).test(navigator.userAgent);
    }
  };


  CUI.ImageEditor = new Class(/** @lends CUI.ImageEditor# */{
    toString: 'ImageEditor',

    extend: CUI.Widget,

    CSS_LAYOUT_CONSTRAINTS: {
      'min-height': 'minHeight',
      'min-width': 'minWidth',
      'max-height': 'maxHeight',
      'max-width': 'maxWidth'
      // don't include width and height here as they are often set without the intention of influencing the editor.
    },

    ZOOM_MIN: 0.1,
    ZOOM_MAX: 3,

    /**
     * Associative array of registered actions; values of type
     * {@link CUI.imageeditor.actions.Action}
     * @private
     * @type Object
     */
    registeredActions: null,

    /**
     * Associative array of registered plugins; values of type
     * {@link CUI.imageeditor.plugins.Plugin}
     * @private
     * @type Object
     */
    registeredPlugins: null,

    defaults: {}, // todo - in use?

    /**
     * The context of the editable element
     * @private
     * @type Object
     */
    elementContext: {},

    /**
     * The imageeditor user interface
     * @private
     * @type Object
     */
    $ui: {},

    /**
     * @extends CUI.Widget
     * @classdesc Adds image editing options toolbar to an image element. Options include cropping, rotation, flipping and masking.
     *
     * <h2 class='line'>Examples</h2>
     *
     * <h3>Default</h3>
     * <img id='myImage' src='http://example.com/images/sponge.png'/>
     *
     * @example
     * <caption>Instantiate with Class</caption>
     * var imageEditor = new CUI.ImageEditor({
     *     element: '#myImage'
     * });
     *
     * @example
     * <caption>Instantiate with jQuery</caption>
     * $('#myImage').imageEditor({
     *     todo - add example options
     * });
     *
     * @description Creates a new image editor
     * @constructs
     *
     * @param  {Object} options Component options
     */
    construct: function (options, i18n) {
      this.options = options || {};
      this.i18n = i18n || new CUI.imageeditor.I18nProvider();
    },

    // Plugin configuration
    // ----------------------------------------------------------

    /**
     *
     * @param {Object} config The config object to be used for configuration
     * @private
     */
    configurePluginsAndActions: function (config) {
      var pluginConfig = config.plugins || {},
          plugin;

      for (var pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          plugin = this.registeredPlugins[pluginId];

          plugin.notifyPluginConfig(pluginConfig[pluginId]);
        }
      }
      for (var actionId in this.registeredActions) {
        if (this.registeredActions.hasOwnProperty(actionId)) {
          plugin = this.registeredActions[actionId];

          plugin.notifyPluginConfig(pluginConfig[actionId]);
        }
      }
    },

    /**
     * <p>Registers a UI-related event handler.</P>
     * <p>Currently the following events are supported:</p>
     * <ul>
     *   <li>updatestate - signals a selection state change</li>
     *   <li>preventdrop - signals that drag & drop on the text component should be
     *     temporarily disabled</li>
     *   <li>reactivatedrop - signals that drag & drop on the text component should be
     *     reactivated</li>
     *   <li>enablesourceedit - signals that source edit mode is requested</li>
     *   <li>disablesourceedit - signals that WYSIWYG edit mode is requested</li>
     *   <li>dialogshow - signals that a dependent dialog has been shown</li>
     *   <li>dialoghide - signals that a dependent dialog has been hidden</li>
     * </ul>
     * @param {String} eventName Event name (see doc for supported values)
     * @param {Function} fn Event handler function
     * @param {Object} scope Scope for fn
     * @private
     */
    bindUIListener: function (eventName, fn, scope) {
      fn = scope ? $.proxy(fn, scope) : fn;

      this.$ui.on(eventName, fn);
    },

    isAnimated : function () {
      return !!this._isAnimated;
    },

    toggleAnimation : function (enable) {
      this._isAnimated = enable;
      // Calling position() to ensure, that the browser is properly
      // positioning all elements, before transitions are activated or
      // deactivated
      if (this.$element) {
        this.$element.position();
        this.$element.toggleClass('imageeditor-editable-animate', enable);
      }
      if (this.$ui) {
        this.$ui.position();
        this.$ui.toggleClass('imageeditor-container-animate', enable);

        if (this.$ui.copy) {
          this.$ui.copy.position();
          this.$ui.copy.toggleClass('imageeditor-editable-copy-animate', enable);
        }
      }
    },

    withoutAnimation : function (callback) {
      if (!this.isAnimated()) {
        return callback.call(this);
      }

      var result;

      this.toggleAnimation(false);

      result = callback.call(this);

      this.toggleAnimation(true);

      return result;
    },
    // User interface --------------------------------------------------------------------

    /**
     * Start editing
     * @param {Object} options The image editor options
     */
    start: function (options) {
      options = options || {};

      this.setupTemplates(options.templates);

      this.setupElementContext();

      this._zoomFactor = options.zoomFactor;
      if (!this._zoomFactor) {
        this._zoomFactor = this.options.zoomFactor;
      }
      if (!this._zoomFactor) {
        this._zoomFactor = 1.0;
      }

      this.createUI();
      if (this.preferCopy()) {
        this.options.image = $(this.options.image);
        this.$ui.copy = this.options.image.addClass('imageeditor-editable-copy');
      }
      else {
        this.$ui.copy = this.$element.clone().addClass('imageeditor-editable-copy');
      }

      this.$ui.copy.css('margin', 0);

      this.$ui.prepend(this.$ui.copy);

      // Register actions
      this.registeredActions = CUI.imageeditor.actions.ActionRegistry.createRegisteredActions(this);

      // Register and configure plugins
      this.registeredPlugins = CUI.imageeditor.plugins.PluginRegistry.createRegisteredPlugins(this);
      this.configurePluginsAndActions(options);

      // Create transform result which stores current state of editing
      this.transformResult = this.createTransformResult(options.result);

      // Overlay img with editing UI
      this.installUI();

      // Create the toolbar
      this.createToolbar(options);

      if (this.options.mode === 'fullscreen') {
        this.switchToFullscreen();
      }
      else {
        this.switchToInline();
      }

      // Eventing
      this.setupEventHandling();

      // Everything ready, trigger an edit start event
      this.$element.trigger('editing-start');
    },

    preferCopy : function () {
      if (this.options.image && $(this.options.image).length) {
        this.preferCopy = function () { return true; };
      }
      else {
        this.preferCopy = function () { return false; };
      }
      return this.preferCopy();
    },

    /**
     * cancel editing
     */
    cancel: function () {
      this.destroyEventHandling();
      this.destroyUI();
      this.$element.trigger('editing-cancelled');
    },

    /**
     * Finish editing
     */
    finish: function () {
      this.destroyEventHandling();
      this.destroyUI();
      this.$element.trigger('editing-finished', {result: this.transformResult.toJSON()});
    },

    /**
     * Calculate the natural size of an HTML image element
     * @param {HTMLElement} img The image element to test
     * @return {Object} The dimension object
     *
     * TODO maybe dead code - anybody using this externally?
     */
    getImageNaturalSize: function (img) {
      var $img = img,
          dim = {},
          tempImage = new Image();

      tempImage.src = $img.attr('src');

      dim.w = tempImage.width;
      dim.h = tempImage.height;

      return dim;
    },

    // Toolbar building
    // ----------------------------------------------------------

    /**
     * Create the toolbar
     * @param {Object} options (optional) options
     */
    createToolbar: function (options) {
      var pluginId, plugin, toolbar,
          toolbarBuilder = this.createToolbarBuilder();

      options = $.extend({}, {'$editable': this.$ui}, options);

      // Give plugins chance to register toolbar items
      for (pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          plugin = this.registeredPlugins[pluginId];
          plugin.initializeUI(toolbarBuilder, options);
        }
      }

      // Create the abstracted toolbar
      this.toolbars = {};
      this.$ui.toolbars = {};


      toolbar = toolbarBuilder.createToolbar(options, 'inline');
      if (toolbar) {
        this.toolbars.inline = toolbar;
        this.$ui.toolbars.inline = this.toolbars.inline.getToolbars();
      }

      toolbar = toolbarBuilder.createToolbar(options, 'fullscreen');
      if (toolbar) {
        this.toolbars.fullscreen = toolbar;
        this.$ui.toolbars.fullscreen = this.toolbars.fullscreen.getToolbars();
      }
    },

    getToolbarHeight: function () {
      var max = 0,
        maxSearcher = function (idx, v) {
          var height = $(v).height();
          if (height > max) {
            max = height;
          }
        };

      this.$ui.find('.imageeditor-toolbar').each(maxSearcher);
      return max;
    },

    /**
     * Create an instance of {@link CUI.imageeditor.ui.ToolbarBuilder}
     * @return {CUI.imageeditor.ui.ToolbarBuilder} The toolbar builder instance to be used
     */
    createToolbarBuilder: function () {
      return new CUI.imageeditor.ui.ToolbarBuilder({templates: this.templates});
    },

    // Transformation result
    // ----------------------------------------------------------

    /**
     * Creates an instance of {@link CUI.imageeditor.TransformResult}.
     * Expects this.registeredPlugins to be setup.
     *
     * @return {TransformResult}
     *
     * @private
     **/
    createTransformResult: function (initialSettings) {
      var pluginId, plugin,
          result = new CUI.imageeditor.TransformResult(),
          plugins = this.registeredPlugins;

      // Each plugin has the opportunity to register its own transform fields
      for (pluginId in plugins) {
        if (plugins.hasOwnProperty(pluginId)) {
          plugin = plugins[pluginId];
          plugin.registerTransformFields(result);
        }
      }

      if (initialSettings) {
        result.setTransformValues(initialSettings, false);
      }

      return result;
    },

    // Event handling
    // ----------------------------------------------------------

    setupEventHandling: function () {
      var self = this;

      // Out of area clicks
      this.$element.parents('body').add(document.body).on('tap.imageeditor-ooa click.imageeditor-ooa', function (e) {
        if (eventOutsideOfEditor(e) && !CUI.imageeditor.UIUtils.isHavingModalParent(e.target)) {
          self.finish();
        }
      });

      // Reposition UI on window resize
      $(window).on('resize.imageeditor orientationchange.imageeditor', function () {
        self.withoutAnimation(function () {
          self.updatePreview();
        });
      });

      // Listen for close requests and prompt a finish
      this.bindUIListener('requestclose', this.finish, this);
    },

    destroyEventHandling: function () {
      this.$element.parents('body').add(document.body).off('.imageeditor-ooa');
      $(window).off('.imageeditor');
    },

    // Form submission logic
    // ----------------------------------------------------------

    submit: function () {
      // todo - handle form submission
      $.ajax({
        type: 'POST',
        url:  'action',
        data: JSON.stringify(this.transformResult.toJSON()),
        success: function () {
          // todo
        },
        error: function () {
          // todo
        }
      });
    },

    // User interface utilities
    // ----------------------------------------------------------

    /**
     * Build the basic UI with placeholders/containers for interaction
     * elements.
     *
     * Needs this.$element to be present
     * Sets this.$ui
     * @private
     */
    createUI : function () {
      var uiTpl = this.templates.get('imageeditor');

      this.$ui = $(uiTpl({}));

      // Apply themeing
      if (this.options.theme === 'dark') {
        this.$ui.attr('data-theme', 'dark');
        this.$ui.addClass('coral--dark');
      }
      else {
        this.$ui.removeAttr('data-theme');
        this.$ui.removeClass('coral--dark');
      }
    },

    getMode : function () {
      return (this.$ui.attr('data-mode') === 'fullscreen') ? 'fullscreen' : 'inline';
    },

    setMode : function (mode) {
      if (mode === 'fullscreen') {
        this.switchToFullscreen();
      }
      else if (mode === 'inline') {
        this.switchToInline();
      }
    },

    switchToFullscreen : function (ignoreOptions) {
      if (!this.toolbars.fullscreen && !ignoreOptions) {
        return this.switchToInline(true);
      }

      this.$ui.attr('data-mode', 'fullscreen');
      this.togglePinchZooming(true);
      this.withoutAnimation(function () {
        this.updatePreview();
        this.scaleToFitForFullscreen();
      });
    },

    switchToInline : function (ignoreOptions) {
      if (!this.toolbars.inline && !ignoreOptions) {
        return this.switchToFullscreen(true);
      }

      this.$ui.attr('data-mode', 'inline');
      this.togglePinchZooming(false);
      this.withoutAnimation(function () {
        // update the element in pageflow so as to reflow page depending on eventual changes:
        this.$element.css(this.createTranslationUtil().getZoomedDimensions());
        this.updatePreview();
      });
    },


    installStylesheet : function () {
      var theirDoc, theirStyleElement, theirStyleSheet, i, j, rules, rule,
          myStyle,
          REGEXP = /\.imageeditor-editable(-animate)?/;

      theirDoc = this.$element.parents('html').get(0).parentNode;

      if (theirDoc.getElementById('imageeditor-editable-stylesheet')) {
        return;
      }

      theirStyleElement = theirDoc.createElement('style');
      theirStyleElement.id = 'imageeditor-editable-stylesheet';
      theirDoc.getElementsByTagName('head')[0].appendChild(theirStyleElement);

      for (i = 0; i < theirDoc.styleSheets.length; i++) {
        if (theirDoc.styleSheets[i].ownerNode === theirStyleElement) {
          theirStyleSheet = theirDoc.styleSheets[i];
          break;
        }
      }

      if (document.styleSheets !== null && theirStyleSheet !== null) {
        for (i = 0; i < document.styleSheets.length; i++) {
          myStyle = document.styleSheets[i];
          // Accessing cssRules throws a Security Exception in FF
          // under certain conditions. This should be handled more
          // gracefully, but I could not come up with a proper
          // workaround.
          try { rules = myStyle.cssRules; } catch (e) { continue; }

          if (rules !== null) {
            for (j = 0; j < rules.length; j++) {
              rule = rules[j];
              if (rule.type === CSSRule.STYLE_RULE && REGEXP.test(rule.selectorText)) {
                theirStyleSheet.insertRule(rule.cssText, theirStyleSheet.cssRules.length);
              }
            }
          }
        }
      }
    },

    /**
     * Overlay img with editing UI
     */
    installUI : function () {
      var dimensions;

      if (this.options.parent) {
        $(this.options.parent).append(this.$ui);
      }
      else {
        this.$element.after(this.$ui);
      }

      this.$clipParent = CUI.imageeditor.UIUtils.getClippingParent(this.$ui);
      this.uiClipped = (this.$clipParent !== undefined);

      this.$element.addClass('imageeditor-editable');

      // FIXME: Best effort - using whichever dimensions work. Ideally we
      // would wait until the copy was loaded. User can specify dimensions also via options.overrides.naturalHeight/Width
      if (this.preferCopy()) {
        dimensions = {
          width: this.$ui.copy.width(),
          height: this.$ui.copy.height()
        };
      }
      else {
        dimensions = {
          width: this.$element.width(),
          height: this.$element.height()
        };
      }

      if (this.options.overrides && this.options.overrides.naturalHeight && this.options.overrides.naturalWidth) {
        dimensions = {
          height: this.options.overrides.naturalHeight,
          width: this.options.overrides.naturalWidth
        };
      }

      this._naturalDimensions = dimensions;
      this.$ui.copy.data('imageeditor-dimensions', dimensions);
      this._layoutConstraints = {
        'max-width': this.$ui.copy.css('max-width'),
        'max-height': this.$ui.copy.css('max-height'),
        'min-width': this.$ui.copy.css('min-width'),
        'min-height': this.$ui.copy.css('min-height')
      };

      this.$element.css(this.getBaseCssPropertiesForElement());
      this.$ui.copy.css('margin', 0); // set here because baseCssProperties are also used as a base to add margin-left etc.
      this.$ui.copy.css(this.getBaseCssPropertiesForCopy());

      // start with something, will be reset later to required size:
      this.$ui.css({
        height : dimensions.height + 'px',
        width  : dimensions.width + 'px'
      });

      if (this.elementContext.iframe !== null) {
        this.installStylesheet();
      }

      this.toggleAnimation(true);
    },

    /**
     * Place the editing UI over the original element
     */
    positionUI : function (using) {
      var fixPositionForIframe = $.proxy(function (position, data) {
        /**
         * Available coordinates:
         *
         *    this.$ui.offset({top: data.element.top, left: data.element.left});
         * or
         *    this.$ui.css(position);
         *
         */

        if (this.elementContext.iframe) {
          var iframe = $(this.elementContext.iframe);
          var iOffset = $(this.elementContext.iframe).offset();

          // TODO: This approach is incomplete. It only works as long as the
          // iframe and this.$ui have the same offsetParent() - I think.
          // Also needs verification in WCM context.
          position.left += iOffset.left + parseInt(iframe.css('border-left-width'), 10);
          position.top  += iOffset.top  + parseInt(iframe.css('border-top-width'),  10);
        }

        // Make sure the toolbar is visible on screen by offsetting the position
        position.top = Math.max(position.top, this.$ui.toolbars.inline.height());

        if ($.isFunction(using)) {
          using.call(this, position);
        }
        else {
          this.$ui.css(position);
        }
      }, this);

      this.$ui.position({
        using      : fixPositionForIframe,
        of         : this.$element,
        my         : 'left top',
        at         : 'left top',
        collision  : 'none'
      });
    },

    togglePinchZooming : function (enable) {
      var self = this,
        ZOOM_NS = '.imageeditorzoom';

      CUI.imageeditor.UIUtils.removePinchZooming(self.$ui, ZOOM_NS);
      if (enable) {
        CUI.imageeditor.UIUtils.installPinchZooming(self.$ui, ZOOM_NS,
          function () {
            return self.getZoomFactor();
          },
          function (newFactor, changeOrEnd) {

            if (changeOrEnd === 'change') {
              self.zoom(newFactor, false);
            } else {
              self.zoom(newFactor, true); // animate last move
            }
          }
        );
      }
    },

    getBaseCssPropertiesForCopy : function () {
      var translationUtil = this.createTranslationUtil(),
        dimensions = translationUtil.getZoomedDimensionsBeforeRotation();

      return {
        'max-width': '9999px',
        'max-height': '9999px',
        'min-width': '0px',
        'min-height': '0px',
        'height': '' + dimensions.height + 'px',
        'width': '' + dimensions.width + 'px',
        'clip': 'rect(0px, ' +
                dimensions.width + 'px, ' +
                dimensions.height + 'px, 0px)',
        'transform-origin': '50% 50%',
        'transform': 'scale(1)'
      };
    },

    getBaseCssPropertiesForElement : function () {
      var dimensions = this.createTranslationUtil().getZoomedDimensionsBeforeRotation();

      return {
        width  : dimensions.width,
        height : dimensions.height
      };
    },

    /**
     * Destroy the UI
     */
    destroyUI: function () {
      var dimensions = this.$ui.copy.data('imageeditor-dimensions');

      this.$ui.remove();

      this.toggleAnimation(false);
      this.$element.removeClass('imageeditor-editable');
      this.$element.css(dimensions);
    },

    /**
     * Sets up the context of the editable element.
     */
    setupElementContext: function () {
      this.elementContext = this.elementContext || {};
      this.elementContext.iframe = CUI.imageeditor.UIUtils.elementInIframe(this.$element);

      if (this.elementContext.iframe === null) {
        this.elementContext.win = window;
        this.elementContext.doc = document;
      }
      else {
        this.elementContext.win = this.elementContext.iframe.contentWindow;
        this.elementContext.doc = this.elementContext.iframe.contentWindow.document;
      }
    },

    // Actions
    // ----------------------------------------------------------

    /**
     * @private
     */
    getCustomAction: function (action) {
      var actn, actionToCheck,
          customAction = this.registeredActions[action];

      if (customAction) {
        return customAction;
      }
      for (actn in this.registeredActions) {
        actionToCheck = this.registeredActions[actn];
        if (actionToCheck.isAction(action)) {
          return actionToCheck;
        }
      }
      return null;
    },

    /**
     * Executes an editor action on the image and performs necessary focus and
     * toolbar updates. Actions that are not supported by a specific browser are emulated
     * accordingly. <b>This should only be called after the editor is initialized.</b>
     * @param {String} action The action
     * @param {Object} value (optional) The value to pass to the action (defaults to null)
     */
    relayAction: function (action, value) {
      CUI.imageeditor.Utils.defer(function () {
        this.execAction(action, value);
      }, 10, this);
    },

    /**
     * Executes an editor action directly. For visual actions, you
     * should use {@link #relayAction} instead. Actions that are not supported by a specific
     * browser are emulated accordingly. <b>This method should only be called after the
     * editor is initialized. Otherwise, it will return immediately if the action is not
     * explicitly flagged for use in uninitialized state.</b>
     * @param {String} action The action
     * @param {Object} value (optional) The value to pass to the action (defaults to null)
     */
    execAction: function (action, value){
      // check if a custom action has to be used instead of browser's implementation
      var customAction = this.getCustomAction(action),
        self = this,
        execRet, execOptions,
        rotation   = this.getRotation(),
        dimensions = this.getImageDisplayDimensions(),
        toolbarHeight = this.getToolbarHeight(),
        viewportCrop = this.getViewportCrop(),
        canvas     = this.getCrop(),
        flip       = this.getFlip();

      delete canvas.right;
      delete canvas.bottom;

      execOptions = {
        action     : action,
        value      : value,
        element    : this.$ui.copy,
        editor     : this,
        ui         : this.$ui,
        result     : this.transformResult,
        mode       : this.getMode(),

        dimensions : dimensions,
        viewportCrop: viewportCrop,
        toolbarHeight: toolbarHeight,
        canvas     : canvas,
        rotation   : rotation,
        flip       : flip,

        translate  : function (box) {
          return translate(rotation, flip, dimensions, box);
        },

        createTranslationUtil : function () {
          return self.createTranslationUtil();
        }
      };

      if (customAction) {
        execRet = customAction.execute(execOptions);
      }

      if (execRet) {
        this.updatePreview();
      }

      return execRet;
    },

    /**
     * @returns {{width: number, height: number}}
     */
    getViewportCrop : function () {
      var hiddenByToolbar,
        translationUtil = this.createTranslationUtil(),
        fullscreenUiDims = {
          top: 0,
          left: 0,
          width: this.$ui.width(),
          height: this.$ui.height()
        },
        $window = $(window),
        pageUiDims,
        imageDimsRotated = translationUtil.rotateDimsIfNecessary(translationUtil.getZoomedCropBeforeRotation()),
        toolbarHeight = this.getMode() === 'fullscreen' ? this.getToolbarHeight() : 0,
        imageOnPage, translatedCrop, imageOffset, imageViewport;

      if (this.getMode() === 'inline') {
        translatedCrop = translationUtil.translate( translationUtil.getZoomedCropBeforeRotation());
        imageOffset = this.$ui.copy.offset();
        imageOnPage = {
          left: imageOffset.left + translatedCrop.left,
          top: imageOffset.top + translatedCrop.top,
          width: translatedCrop.width,
          height: translatedCrop.height
        };
        pageUiDims = {
          top: $window.scrollTop(),
          left: $window.scrollLeft(),
          width: $window.width(),
          height: $window.height()
        };
        imageViewport = {
          left: Math.max(pageUiDims.left, imageOnPage.left),
          top: Math.max(pageUiDims.top, imageOnPage.top),
          right: Math.min(pageUiDims.left + pageUiDims.width, imageOnPage.left + imageOnPage.width),
          bottom: Math.min(pageUiDims.top + pageUiDims.height, imageOnPage.top + imageOnPage.height)
        };
        imageViewport = {
          left: Math.max(0, imageViewport.left - imageOnPage.left),
          top: Math.max(0, imageViewport.top - imageOnPage.top),
          width: Math.max(0, imageViewport.right - imageViewport.left),
          height: Math.max(0, imageViewport.bottom - imageViewport.top)
        };

      } else {
        // fullscreen mode:
        imageViewport = {
          width: Math.min(imageDimsRotated.width, fullscreenUiDims.width),
          height: Math.min(imageDimsRotated.height, fullscreenUiDims.height - toolbarHeight)
        };
        if (imageViewport.width < imageDimsRotated.width) {
          imageViewport.left = (imageDimsRotated.width - imageViewport.width)/2;
        } else {
          imageViewport.left = 0;
        }

        if (imageViewport.height < imageDimsRotated.height) {
          hiddenByToolbar = Math.max(0, Math.min(toolbarHeight, imageDimsRotated.height - imageViewport.height));
          imageViewport.top = hiddenByToolbar + (imageDimsRotated.height - imageViewport.height - hiddenByToolbar)/2;
        } else {
          imageViewport.top = 0;
        }
      }

      return imageViewport;
    },

    /**
     * The size of the image on the ui including zoom - not taking into account crop. This
     * is different from natural, display and zoom sizes.
     */
    getImageDisplayDimensions : function (rotated) {
      return {
        width : this.$ui.copy.width(),
        height : this.$ui.copy.height()
      };
    },

    createTranslationUtil : function () {
      var options = $.extend({}, this.options);

      options.flip = this.getFlip();
      options.rotation = this.getRotation();
      options.zoomFactor = this.getMode() === 'inline' ? 1.0 : this.getZoomFactor();
      options.naturalWidth = this._naturalDimensions.width;
      options.naturalHeight = this._naturalDimensions.height;
      options.cropOnOriginal = this.getCrop();

      if (!this.availableButNotFalse(options, 'ignoreCssLayoutConstraints')) {
        this.copyIfAvailable(options, this._layoutConstraints, this.CSS_LAYOUT_CONSTRAINTS);
      }
      this.copyIfAvailable(options, this.options, this.CSS_LAYOUT_CONSTRAINTS);
      this.copyIfAvailable(options, this.options, {'width': 'fixedWidth', 'height': 'fixedHeight'});

      return new CUI.imageeditor.TranslationUtil(options);
    },

    copyIfAvailable : function (target, src, namesMapping) {
      var toSet = null, key, targetName;

      if (!$.isPlainObject(namesMapping)) {
        namesMapping = {namesMapping: namesMapping};
      }

      for (key in namesMapping) {
        if (!namesMapping.hasOwnProperty(key)) {
          continue;
        }
        targetName = namesMapping[key];
        if (!targetName) {
          targetName = key;
        }

        toSet = src[key];
        if (!toSet) {
          toSet = src[key.toLowerCase()];
        }
        if (!toSet) {
          toSet = src[targetName];
        }
        if (!toSet) {
          toSet = src[targetName.toLowerCase()];
        }

        if (toSet) {
          target[targetName] = toSet;
        }
      }
    },

    availableButNotFalse: function (obj, propertyName) {
      var value = obj[propertyName];
      if (!obj) {
        return false;
      }
      if (obj.hasOwnProperty(propertyName)) {
        value = obj[propertyName];
        if (typeof value === 'string' &&
          value.toLowerCase() in ['no', 'false']) {
          return false;
        }
        return true;
      } else {
        return false;
      }
    },

    getCssPropertiesForCopy : function () {
      var css = this.getBaseCssPropertiesForCopy(),
          translationUtil = this.createTranslationUtil(),
          cssPart, name, attr;

      for (name in this.registeredActions) {
        if (this.registeredActions.hasOwnProperty(name)) {

          cssPart = this.registeredActions[name].toCss(this.transformResult, this.$ui.copy, translationUtil);

          if (!cssPart) {
            continue;
          }

          for (attr in cssPart) {
            if (cssPart.hasOwnProperty(attr)) {

              if (attr === 'transform') {
                // transforms are stacked
                css[attr] += ' ' + cssPart[attr];
              }
              else {
                css[attr] = cssPart[attr];
              }

            }
          }
        }
      }

      return css;
    },

    getCrop : function () {
      var crop;

      if (this.registeredActions.crop) {
        crop = this.registeredActions.crop.getCurrent(this.transformResult);
      }

      if (!crop) {
        var baseDimensions = this._naturalDimensions;

        crop = {
          top    : 0,
          left   : 0,
          width  : baseDimensions.width,
          height : baseDimensions.height
        };
      }

      return crop;
    },

    getRotation : function () {
      var rotate;

      if (this.registeredActions.rotate) {
        rotate = this.registeredActions.rotate.getCurrent(this.transformResult);
      }

      if (isNaN(rotate)) {
        rotate = 0;
      }

      return rotate;
    },

    getFlip : function () {
      var flip;

      if (this.registeredActions.flip) {
        flip = this.registeredActions.flip.getCurrent(this.transformResult);
      }

      if (!flip) {
        flip = {
          horizontal : false,
          vertical   : false
        };
      }

      return flip;
    },

    getZoomFactor : function () {
      return this._zoomFactor;
    },

    getZoomLimits : function () {
      return [this.ZOOM_MIN, this.ZOOM_MAX];
    },

    /**
     * Zoom the picture (fullscreen only).
     * @param newZoomFactor {number} 1 is 100%, 0.5 is 50%, 2 is 200%
     * @param animate {boolean} if true then normal animation will be used, else animation will be disabled
     */
    zoom : function (newZoomFactor, animate) {
      var limitedFactor = Math.min(this.ZOOM_MAX, Math.max(this.ZOOM_MIN, newZoomFactor)),
        self = this;

      // limit to steps of 1 % or 0.01:
      limitedFactor = Math.round(limitedFactor * 100) /100.0;

      if (limitedFactor !== this._zoomFactor) {
        this._zoomFactor = limitedFactor;
        if (animate) {
          this.updatePreview();
        } else {
          this.withoutAnimation(function () {
            self.updatePreview();
          });
        }
      }
    },

    getCssPropertiesForElement : function (css) {
      var translationUtil = this.createTranslationUtil(),
          baseDimensions = translationUtil.getZoomedDimensionsBeforeRotation(),
          dimensions = {},
          crop = translationUtil.getZoomedCropBeforeRotation(),
          rotation = this.getRotation();

      dimensions.width  = crop.width;
      dimensions.height = crop.height;

      css['margin-top']  = - crop.top;
      css['margin-right']  = - (baseDimensions.width - (crop.left + crop.width));
      css['margin-bottom'] = - (baseDimensions.height - (crop.top + crop.height));
      css['margin-left']   = - crop.left;

      if (rotation % 180 !== 0) {
        // switch dimensions
        var height = dimensions.width;
        dimensions.width = dimensions.height;
        dimensions.height = height;

        // move copy appropiately
        var change = (dimensions.width - dimensions.height) / 2;

        css['margin-left']   += change;
        css['margin-right']  += change;
        css['margin-top']  -= change;
        css['margin-bottom'] -= change;
      }

      if (this.getMode() === 'fullscreen') {
        css['margin-top']  -= Math.floor(dimensions.height / 2);
        css['margin-right']  -= Math.floor(dimensions.width  / 2);
        css['margin-bottom'] -= Math.floor(dimensions.height / 2);
        css['margin-left']   -= Math.floor(dimensions.width  / 2);
      }

      return dimensions;
    },

    getCssPropertiesForContainer : function (newDimensions) {
      if (this.getMode() === 'fullscreen') {
        return this.getCssPropertiesForContainerFullscreen(newDimensions);
      }
      else {
        return this.getCssPropertiesForContainerInline(newDimensions);
      }
    },

    getCssPropertiesForContainerFullscreen : function (newDimensions) {
      return {
        left: '',
        top : ''
      };
    },

    getCssPropertiesForContainerInline : function (newDimensions) {
      var newPosition,
        oldDimensions = {
          width : this.$element.width(),
          height: this.$element.height()
        };

      this.withoutAnimation(function () {
        this.$element.css(newDimensions);

        this.positionUI(function (position) { newPosition = position; });

        this.$element.css(oldDimensions);
      });

      return newPosition;
    },

    updatePreview : function () {
      var cssForCopy = this.getCssPropertiesForCopy(),
          cssForElem = this.getCssPropertiesForElement(cssForCopy),
          cssForCont = this.getCssPropertiesForContainer(cssForElem);

      this.$element.css(cssForElem);
      // TODO remove this iOS 7-specific workaround when we stop to support iOS 7
      if (isIosVersion7()) {
        this.updateClipForIosV7(cssForCopy);
      } else {
        this.$ui.copy.css(cssForCopy);
      }
      this.$ui.css(cssForCont);
    },

    scaleToFitForFullscreen : function () {
      var viewcrop = this.getViewportCrop(),
        translationUtil = this.createTranslationUtil(),
        zoomedCrop = translationUtil.translate(translationUtil.getZoomedCropBeforeRotation(), 'zoomed'),
        factor = 1.0, factorTemp;

      if (zoomedCrop.width > viewcrop.width) {
        factor = viewcrop.width / zoomedCrop.width;
      }

      if (zoomedCrop.height > viewcrop.height) {
        factorTemp = viewcrop.height / zoomedCrop.height;
        if (factorTemp < factor) {
          factor = factorTemp;
        }
      }

      this.zoom(this.getZoomFactor() * factor, true);
    },

    updateClipForIosV7 : function (cssForCopy) {
      // CQ-25204 - iOS 7 not hiding overflow areas on clip update without animation
      var copy = this.$ui.copy;
      var clipToSet = cssForCopy.clip || '';
      var currentClip = copy.css('clip');
      if (clipToSet.replace(/, ?/g,' ') === currentClip || (clipToSet === 'rect(0px, 0px, 0px, 0px)' && currentClip === 'auto')) {

        copy.css(cssForCopy);
      } else {
        cssForCopy['clip'] = 'rect(0px, 0px, 0px, 0px);';
        copy.css(cssForCopy);
        setTimeout(function() {
          // this has to happen with an animation
          copy.css('clip', clipToSet);
        }, 1000); // cannot be too short or the bug appears
      }
    },

    /**
     * Allows setting up a custom template provider, if the `start()` template
     * option is not flexible enough.
     *
     * Be sure, to call this before `start()` is called. Otherwise, it may not
     * be possible to override all templates.
     *
     * @param {Object} templates HashMap with template name as key and template
     *                           function as value
     *                        or CUI.imageeditor.TemplateProvider instance
     *                        or else - the default templates will be used
     */
    setupTemplates : function (templates) {
      if (templates && $.isFunction(templates.get)) {
        this.templates = templates;
      }
      else if ($.isPlainObject(templates)) {
        this.templates = new CUI.imageeditor.TemplateProvider(templates);
      }
      else if (!this.templates) {
        this.templates = new CUI.imageeditor.TemplateProvider();
      }
    }
  });

  // Register jQuery plugin
  CUI.util.plugClass(CUI.ImageEditor, 'imageEditor', function (imageeditor) {
    CUI.imageeditor.OptionsUtils.loadOptionsAndStartEditing(imageeditor, $(this));
  });

  // Data API
  if (CUI.options.dataAPI) {
    $(function () {
      $(document.body).on('click.imageeditor.data-api', 'img[data-editable="true"],img[data-editable=""]',
        function (e) {
          if (eventOutsideOfEditor(e) && !CUI.imageeditor.UIUtils.isHavingModalParent(e.target)) {
            $(this).imageEditor();
          }
        });
    });
  }
}(jQuery, this, window.CSSRule));
